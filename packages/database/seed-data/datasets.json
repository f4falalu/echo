[
  {
    "id": "34861566-213a-4e53-845e-c34a09fd5835",
    "name": "product_vendor",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_vendor",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_vendor",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082508+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_vendor",
    "ymlFile": "name: product_vendor\ndescription: >\n  Links products to the vendors that supply them, with purchasing attributes per\n  product–vendor pairing: average lead time (days), standard price, last receipt\n  cost/date, minimum/maximum order quantities, on-order quantity, and the\n  purchasing unit of measure. Use this model to analyze supplier options per\n  product, enforce ordering constraints, and join to product and vendor\n  attributes for sourcing and cost analyses. Dates in this demo are shifted via\n  the shift_date macro in staging; interpret recency accordingly.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: lastreceiptdate\n    description: >\n      Datetime the most recent receipt of this product from this vendor was\n      recorded. Usage notes: reflects receiving activity and is useful for\n      freshness/recency checks. Dates are shifted in staging (shift_date macro)\n      for demo purposes.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: unitmeasurecode\n    description: >\n      Code for the purchasing unit of measure used for quantities and pricing\n      (e.g., each, carton, can). Values are 3-character codes; some appear\n      padded. Join to unit_measure for names/definitions.\n    type: character\n    searchable: false\n    options:\n      - 'EA '\n      - CTN\n      - CAN\n  - name: modifieddate\n    description: >\n      Timestamp when this product–vendor record was last modified in the source.\n      Dates are shifted in staging (shift_date macro) for demo purposes.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: productid\n    description: >\n      Product identifier. Join key to the product model; useful for per-product\n      supplier analysis or counting distinct products covered by vendors.\n    type: integer\n  - name: businessentityid\n    description: >\n      Vendor business entity identifier. Join key to the vendor model; use to\n      bring in vendor attributes such as credit rating or preferredVendorStatus.\n    type: integer\n  - name: averageleadtime\n    description: >\n      Average lead time to receive this product from the vendor. Units: days.\n      Typical values are in the 15–19 day range, with some at 30, 45, 60, or\n      120.\n    type: integer\n  - name: standardprice\n    description: >\n      Vendor's standard unit price for this product in the specified unit of\n      measure. Currency depends on source configuration; compare with\n      lastReceiptCost for variance analysis.\n    type: numeric\n  - name: lastreceiptcost\n    description: >\n      Unit cost recorded on the most recent receipt from this vendor. May differ\n      from standardPrice due to discounts, freight, or other adjustments.\n    type: numeric\n  - name: minorderqty\n    description: >\n      Minimum quantity the vendor accepts per purchase order (in the specified\n      unit of measure). Common values include 1 and 100. Use to validate\n      ordering constraints.\n    type: integer\n  - name: maxorderqty\n    description: >\n      Maximum quantity the vendor allows per purchase order (in the specified\n      unit of measure). Common values include 5 and 1000; higher caps exist for\n      some items.\n    type: integer\n  - name: onorderqty\n    description: >\n      Current quantity on open purchase orders for this product with this vendor\n      (in the specified unit of measure). Often null when nothing is on order;\n      treat null as zero when aggregating.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each product–vendor record to its product. Many vendor options can\n      exist per product. Join on productID; typically near-complete coverage.\n  - name: vendor\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links to the supplier (BusinessEntity). Use to filter or enrich with\n      vendor attributes such as creditRating and preferredVendorStatus.\n  - name: unit_measure\n    source_col: unitmeasurecode\n    ref_col: unitmeasurecode\n    type: left\n    cardinality: many-to-one\n    description: >\n      Resolves unitMeasureCode to a descriptive name and metadata for the unit\n      of measure.\nclarifications:\n  - >-\n    What currency are standardPrice and lastReceiptCost recorded in? Do they\n    include freight/discounts?\n  - >-\n    Are quantities (min/max/onOrderQty) expressed in the unit defined by\n    unitMeasureCode? Confirm behavior for padded codes like 'EA '.\n  - Should onOrderQty nulls be treated as zero in reporting?\n  - >-\n    Confirm date-shifting policy (shift_date): how much shift is applied so\n    recency windows are interpreted correctly?\n  - >-\n    Validate relationship coverage: productID and businessEntityID join rates ≥\n    95%?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "fd9b9d80-fa8b-4bc2-8f10-828750b8a9a8",
    "name": "address",
    "databaseName": "postgres",
    "whenToUse": "Provides detailed location information for customers, employees, and vendors. Useful for geographic analysis, shipping logistics, customer demographics, and operations planning.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.address",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082936+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "address",
    "ymlFile": "name: address\ndescription: |\n  blake is stinky\ndimensions:\n  - name: addressid\n    description: >\n      Surrogate primary key for the address record. Stable identifier to join\n      with mapping tables (e.g., business_entity_address) and other facts that\n      reference addresses.\n    type: integer\n    searchable: false\n  - name: addressline1\n    description: >\n      First address line (street number and name). International formats appear.\n      Contains PII; avoid indexing for free-text search. Often the only\n      populated address line.\n    type: text\n    searchable: false\n  - name: addressline2\n    description: >\n      Second address line (apartment, suite, department). Rarely populated\n      (≈2%). Values often include unit markers like \"#\", \"Unit\", or department\n      labels. Useful for mailing accuracy but generally excluded from grouping.\n    type: text\n    searchable: false\n  - name: city\n    description: >\n      City or locality name. Global coverage (e.g., London, Paris, many US\n      cities). Appropriate for text-based filtering and grouping; not unique.\n    type: string\n    searchable: true\n  - name: stateprovinceid\n    description: >\n      Foreign key to state_province indicating the state, province, or region.\n      Use this to join for region names and country context. Not unique;\n      multiple addresses share a region.\n    type: integer\n    searchable: false\n  - name: postalcode\n    description: >\n      Postal or ZIP code. Contains mixed formats (numeric and alphanumeric)\n      depending on country. Treat as text to preserve leading zeros and embedded\n      spaces. Not standardized for case or whitespace.\n    type: string\n    searchable: false\n  - name: spatiallocation\n    description: >\n      Hex-encoded WKB/EWKB point representing the geospatial location of the\n      address. A constant zero-like token appears for a small subset and\n      indicates missing/unknown coordinates. Not suitable for free-text search.\n    type: text\n    searchable: false\n  - name: rowguid\n    description: >\n      System-generated GUID from the source system. Acts as a secondary unique\n      identifier but is typically not used for joins in analytics.\n    type: string\n    searchable: false\n  - name: modifieddate\n    description: >\n      Last update timestamp for the address record. In staging this field is\n      shifted using the `shift_date` macro for temporal consistency. Use for\n      recency filters or change tracking.\n    type: timestamp\n    searchable: false\nmeasures: []\nmetrics: []\nfilters:\n  - name: recently_modified_90d\n    expr: modifieddate >= CURRENT_DATE - INTERVAL '90 days'\n    description: Records updated in the last 90 days.\n    args: []\n  - name: has_line2\n    expr: addressline2 IS NOT NULL\n    description: Addresses with a non-null second address line.\n    args: []\n  - name: has_geospatial_point\n    expr: >-\n      spatiallocation IS NOT NULL AND spatiallocation <>\n      'E6100000010C00000000000000000000000000000000'\n    description: Addresses with a non-zero geospatial token in spatiallocation.\n    args: []\nrelationships:\n  - name: state_province\n    source_col: stateprovinceid\n    ref_col: stateprovinceid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Many addresses map to a single state/province. Join to enrich with region\n      and country attributes for geographic analysis.\n  - name: business_entity_address\n    source_col: addressid\n    ref_col: addressid\n    type: left\n    cardinality: one-to-many\n    description: >\n      An address can be linked to many business entities (customers, vendors,\n      employees) via the mapping table. Use to see which entities use a given\n      address and the address type.\n  - name: sales_tax_rate\n    source_col: stateprovinceid\n    ref_col: stateprovinceid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Addresses inherit one or more applicable tax rates via their\n      state/province. Useful for tax calculations and regional compliance\n      checks.\nclarifications:\n  - >-\n    Confirm timezone and exact behavior of shift_date applied to modifieddate\n    (e.g., UTC normalization?).\n  - >-\n    Should the zero WKB/EWKB token in spatiallocation be treated as null/missing\n    in downstream models?\n  - >-\n    Is postalcode normalized for case and whitespace upstream, or should\n    consumers trim/upper-case locally?\n  - >-\n    Do we want to define two explicit relationships from sales_order_header to\n    address (billToAddressID and shipToAddressID) in docs, and if so, how should\n    we name them?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "da73b280-374e-4687-a64d-de6c96689516",
    "name": "product_order_count",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_order_count",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_order_count",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081419+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_order_count",
    "ymlFile": "name: product_order_count\ndescription: >\n  Counts distinct sales orders that contain each product by calendar quarter.\n  Use to track product popularity and assortment penetration over time. Derived\n  from sales order details joined to sales order headers (for orderDate) and\n  product (for display name). A single order that contains the same product on\n  multiple lines counts once. No order-status filtering is applied in the model\n  SQL.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Integer product key. Join key to the product model. Use for stable joins\n      and aggregations; recommended over product_name for joins. Present only\n      for product–quarter combinations that actually appear in orders.\n    type: integer\n    searchable: false\n    options: null\n  - name: product_name\n    description: >\n      Human-readable product name from the product table at query time. Useful\n      for labeling and exploration. Not SCD-aware; historical quarters will\n      reflect the current name if names change.\n    type: character varying\n    searchable: true\n    options: null\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderDate. Typical filter\n      for period analysis.\n    type: numeric\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: |\n      Calendar quarter number (1–4) extracted from SalesOrderHeader.orderDate.\n    type: numeric\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_productordercount\n    description: >\n      Distinct count of orders that include the product in the given quarter.\n      Calculated as COUNT(DISTINCT salesOrderID) over SalesOrderDetail joined to\n      SalesOrderHeader for time context. Units: orders. Multiple lines for the\n      same product within one order count as 1.\n    type: bigint\nmetrics: []\nfilters:\n  - name: current_year\n    expr: year = EXTRACT(YEAR FROM CURRENT_DATE)\n    description: Filter to the current calendar year of orders.\n    args: []\n  - name: recent_2_years\n    expr: year >= EXTRACT(YEAR FROM CURRENT_DATE) - 1\n    description: Keep the two most recent calendar years.\n    args: []\n  - name: has_orders\n    expr: metric_productordercount > 0\n    description: >-\n      Exclude zero-order combinations (defensive; metric should be positive when\n      present).\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to the product dimension for attributes and categorization. Each\n      product_order_count row (product, quarter) maps to a single product row;\n      not all products appear every quarter.\n  - name: product_quarterly_sales\n    source_col: productid, year, quarter\n    ref_col: productid, year, quarter\n    type: inner\n    cardinality: one-to-one\n    description: >\n      Peer metric model at the same grain (product, year, quarter). Enables\n      combining order counts with unit sales at a 1:1 row level.\n  - name: product_total_revenue\n    source_col: productid, year, quarter\n    ref_col: productid, year, quarter\n    type: inner\n    cardinality: one-to-one\n    description: >\n      Peer metric model at the same grain (product, year, quarter). Enables\n      combining order counts with revenue at a 1:1 row level.\n  - name: product_gross_profit\n    source_col: productid, year, quarter\n    ref_col: productid, year, quarter\n    type: inner\n    cardinality: one-to-one\n    description: >\n      Peer metric model at the same grain (product, year, quarter). Enables\n      combining order counts with gross profit at a 1:1 row level.\nclarifications:\n  - >-\n    Should canceled or returned orders be excluded? If so, add a status filter\n    on SalesOrderHeader.\n  - >-\n    Confirm that product_name reflects the current name (non-SCD) for historical\n    quarters.\n  - >-\n    Validate one-to-one coverage with peer quarterly product metrics on\n    (productid, year, quarter).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "97ae8d1f-b421-42d5-8203-2884e42b701d",
    "name": "sales_territory_history",
    "databaseName": "postgres",
    "whenToUse": "Generated model for sales_territory_history",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_territory_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08214+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_territory_history",
    "ymlFile": "name: sales_territory_history\ndescription: >\n  Historical sales territory assignments for each salesperson over time. Each\n  row represents a period during which a salesperson was assigned to a specific\n  territory. Use this to track territory changes, analyze assignment duration,\n  and understand historical territory coverage. Most records have null endDate\n  indicating current active assignments. Timestamps are normalized via project\n  date-shifting macros; use startDate as the analytical period anchor for\n  reporting and period joins.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: startdate\n    description: >\n      Effective start date of the territory assignment for the salesperson. This\n      marks when the assignment became active. Use this as the primary time\n      anchor for grouping and trending. Cast to date when joining to calendar\n      tables. Most assignments cluster around quarterly boundaries (March, July,\n      September).\n    type: timestamp without time zone\n    searchable: true\n  - name: enddate\n    description: >\n      End date of the territory assignment. Null values (76% of records)\n      indicate current active assignments. Non-null values mark when the\n      assignment was terminated or changed. Use for calculating assignment\n      duration and identifying historical vs current assignments.\n    type: timestamp without time zone\n    searchable: true\n  - name: rowguid\n    description: >\n      System-generated unique identifier for the territory assignment record\n      (UUID v4). Ensures uniqueness across the table. Primarily technical; not\n      intended for analysis or joining. Pattern follows hyphenated UUID format\n      with no nulls.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: >\n      Timestamp when the territory assignment record was last updated in the\n      source. This value is adjusted using the date_shifting.shift_date macro.\n      Useful for auditing and incremental processing; not the business-effective\n      time.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: businessentityid\n    description: >\n      Identifier of the salesperson/business entity associated with this\n      territory assignment. Join key to business_entity.businessentityid and\n      sales_person.businessentityid. Most salespeople have multiple territory\n      assignments over time (average 1.2 assignments per person).\n    type: integer\n  - name: territoryid\n    description: >\n      Identifier of the assigned sales territory. Join key to\n      sales_territory.territoryid for territory details like name, country, and\n      group. Territory IDs range from 1-10, with territories 1 and 6 being most\n      common assignments.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: business_entity\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each territory assignment to the underlying business entity.\n      Provides access to core entity information and relationships to other\n      entity subtypes.\n  - name: sales_person\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each territory assignment to the salesperson details. Many\n      historical assignments per salesperson showing territory changes over\n      time.\n  - name: sales_territory\n    source_col: territoryid\n    ref_col: territoryid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links to territory details including name, country, region group, and\n      performance metrics. Multiple assignments can reference the same territory\n      over time.\n  - name: date_dimension\n    source_col: startdate\n    ref_col: fulldate\n    type: left\n    cardinality: many-to-one\n    description: >\n      Aligns assignment start dates to calendar for period grouping and\n      reporting. Join on the date portion of startDate to\n      date_dimension.fulldate for time analysis.\nclarifications:\n  - >-\n    Do null endDate values definitively indicate current active assignments, or\n    could they indicate incomplete data?\n  - >-\n    What business rules govern territory assignment changes? Are there\n    restrictions on frequency or timing?\n  - >-\n    Should analysts use startDate as period start, or is there a business rule\n    about assignment effective periods?\n  - >-\n    Can a salesperson be assigned to multiple territories simultaneously, or is\n    this strictly one territory per person at any time?\n  - >-\n    What triggers territory assignment changes - performance, geographic\n    restructuring, or salesperson requests?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "24804424-320e-45c4-b7ed-b5a01eedeca9",
    "name": "product_average_inventory_value",
    "databaseName": "postgres",
    "whenToUse": "Metric model that calculates the average inventory value for each product by quarter",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_average_inventory_value",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081631+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_average_inventory_value",
    "ymlFile": "name: product_average_inventory_value\ndescription: >\n  Average inventory value per product by calendar quarter. Calculated as the\n  average of quantity × standard cost for all product inventory rows, grouped by\n  product and time bucket. Product attributes (name, cost) come from Product;\n  inventory quantities come from ProductInventory. Time context (year, quarter)\n  is derived from SalesOrderHeader.orderdate to align with sales activity\n  periods, but the metric itself is not directly tied to specific inventory\n  snapshot dates. Usage notes: Values may be zero for products with only\n  zero-quantity inventory rows. The metric is not currency-converted; it\n  reflects the same currency as Product.standardcost.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Product identifier used across the warehouse. Primary join key to Product\n      and other product-grain models.\n    type: integer\n    searchable: false\n    options: null\n  - name: product_name\n    description: >\n      Human-readable product name from Product.name. Useful for reporting and\n      searching.\n    type: character varying\n    searchable: true\n    options: null\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderdate. Used as a time\n      bucket for the metric; does not filter inventory rows by date.\n    type: numeric\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: >\n      Calendar quarter (1–4) extracted from SalesOrderHeader.orderdate. Used as\n      a time bucket for the metric; does not filter inventory rows by date.\n    type: numeric\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_productaverageinventoryvalue\n    description: >\n      Average inventory value per product and time bucket. Computed as\n      AVG(ProductInventory.quantity × Product.standardcost). Units: currency\n      (same as Product.standardcost). Typical usage: trend average inventory\n      value by product over quarters; filter out zeros to focus on stocked\n      products.\n    type: numeric\nmetrics: []\nfilters:\n  - name: nonzero_inventory_value\n    expr: metric_productaverageinventoryvalue > 0\n    description: |\n      Focus on products with a positive average inventory value.\n    args: []\n  - name: recent_years\n    expr: year IN (2023, 2024, 2025)\n    description: |\n      Limit to the most recent full years available in this model.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to Product for attributes such as name, category, and costs. Many\n      rows per product across time in this model map to one product row.\n  - name: product_inventory\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Underlying inventory records used in the calculation. One aggregated row\n      in this model may relate to many inventory rows for a product (by\n      location, shelf, bin).\nclarifications:\n  - >-\n    Confirm currency for Product.standardcost; is it always USD or varies by\n    company/currency rate?\n  - >-\n    Time buckets (year/quarter) are derived from SalesOrderHeader.orderdate via\n    cross join; confirm this is intended for providing sales-aligned time\n    context rather than inventory snapshot dates.\n  - >-\n    Should zero-quantity inventory rows be excluded from the average to prevent\n    downward bias?\n  - >-\n    If multi-currency is in scope, should this metric be normalized to a\n    reporting currency?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "5c75c98f-50eb-40d8-9fad-e190f7f8caf5",
    "name": "quarterly_sales_growth_rate",
    "databaseName": "postgres",
    "whenToUse": "Generated model for quarterly_sales_growth_rate",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.quarterly_sales_growth_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081487+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "quarterly_sales_growth_rate",
    "ymlFile": "name: quarterly_sales_growth_rate\ndescription: >\n  Quarter-over-quarter (QoQ) sales growth at calendar-quarter grain. Provides\n  one row per year and quarter with the total sales amount for the current\n  quarter and the QoQ growth rate in percent. Useful for trend analysis,\n  seasonality checks, and executive reporting. Note that only quarters with\n  recorded sales are present; quarters with no orders are omitted. Growth is\n  null when the prior quarter is missing or had zero sales.\ndimensions:\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderDate. Use to group or\n      filter by year when analyzing quarterly trends.\n    type: integer\n    searchable: false\n  - name: quarter\n    description: >\n      Calendar quarter of order activity (1–4) derived from\n      SalesOrderHeader.orderDate. This is a calendar quarter, not fiscal. Join\n      or group at the quarter level; values are 1, 2, 3, 4.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: sales_amount\n    description: >\n      Total sales for the quarter, computed as the sum over all orders in the\n      quarter of unitPrice * orderQty * (1 - unitPriceDiscount). Represents\n      item-level discounted revenue. Does not backfill quarters with no sales;\n      only present when orders exist. Units are in the source transaction\n      currency; confirm currency conventions if mixing currencies.\n    type: number\n  - name: metric_qoq_salesgrowthrate\n    description: >\n      Quarter-over-quarter sales growth rate in percent: (current_quarter_sales\n      - prev_quarter_sales) / prev_quarter_sales * 100. Null when the previous\n      quarter is missing or had zero sales. Can be negative when sales decline\n      and may exceed ±100% when quarters are small/volatile.\n    type: number\nmetrics: []\nfilters:\n  - name: non_null_growth\n    expr: metric_qoq_salesgrowthrate IS NOT NULL\n    description: Filter to quarters where a prior-quarter comparison exists.\n    args: []\nrelationships:\n  - name: total_sales_revenue\n    source_col: year, quarter\n    ref_col: year, quarter\n    type: left\n    cardinality: one-to-many\n    description: >\n      Compare growth to absolute revenue levels. Join on calendar year and\n      quarter. The total_sales_revenue model includes month-level rows, so this\n      is a one-to-many relationship by (year, quarter); aggregate the monthly\n      model to quarter before joining to avoid row duplication.\n  - name: number_of_orders\n    source_col: year, quarter\n    ref_col: year, quarter\n    type: left\n    cardinality: one-to-many\n    description: >\n      Combine growth with order volume context. Join on (year, quarter). The\n      number_of_orders model has month-level rows; aggregate to quarter before\n      joining.\nclarifications:\n  - >-\n    Confirm currency conventions for sales_amount (single currency vs mixed;\n    inclusion/exclusion of tax/shipping/returns).\n  - Confirm timezone/UTC handling of orderDate when extracting year/quarter.\n  - >-\n    Should zero-sales quarters be backfilled via a date spine for continuous\n    time series?\n  - Is there a fiscal calendar to support, or only calendar quarters?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "f00eea00-2b56-46b1-bda2-62341c62f07d",
    "name": "bike_upgrade_cycle",
    "databaseName": "postgres",
    "whenToUse": "A strategic metric that tracks customer bicycle purchase patterns over time, revealing when and how customers upgrade their bikes. This metric helps product managers plan future bike model lifecycles, enables targeted marketing campaigns based on predicted upgrade timelines, and supports inventory forecasting. Use this data to identify high-value upgrade customers, optimize product launch schedules, and create personalized marketing opportunities at the optimal time in a customer's upgrade cycle.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.bike_upgrade_cycle",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081277+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "bike_upgrade_cycle",
    "ymlFile": "name: bike_upgrade_cycle\ndescription: >\n  Per-customer upgrade-cycle summary for Bike purchases only. For each customer,\n  this model captures the number of upgrade intervals, minimum/maximum/average\n  days between consecutive bike purchases, the average upgrade basket value, and\n  a categorical segment based on the average cycle length. Use it to analyze\n  lifecycle behavior, segment customers for retention and upsell, and benchmark\n  upgrade cadence across buyer types. Data is restricted to products in the\n  'Bikes' category; only customers with at least one subsequent bike purchase\n  are included (first-only purchasers without a next purchase are excluded).\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: customerid\n    description: >\n      Unique customer identifier in the sales domain. One row per customer in\n      this model (only customers with at least one subsequent bike purchase).\n      Use to join to the customer model and other customer-grain facts.\n    type: integer\n    searchable: false\n  - name: customer_type\n    description: >\n      Buyer type derived from customer attributes: 'Individual' when personID is\n      present, 'Store' when associated to a store account. Useful for segmenting\n      upgrade patterns. Current data is primarily Individuals for bikes.\n    type: text\n    searchable: false\n    options:\n      - Individual\n      - Store\n  - name: metric_upgradercategory\n    description: >\n      Segmentation based on average days between bike purchases: 'Frequent\n      Upgrader' (< 365 days), 'Annual Upgrader' (365–730 days), 'Long-term\n      Owner' (> 730 days).\n    type: text\n    searchable: false\n    options:\n      - Frequent Upgrader\n      - Annual Upgrader\n      - Long-term Owner\nmeasures:\n  - name: total_upgrades\n    description: >\n      Number of upgrade intervals for the customer (count of purchases that had\n      a subsequent bike purchase). Integer count.\n    type: integer\n  - name: min_days_between_purchases\n    description: >\n      Minimum number of days between consecutive bike purchases for the\n      customer.\n    type: number\n  - name: max_days_between_purchases\n    description: >\n      Maximum number of days between consecutive bike purchases for the\n      customer.\n    type: number\n  - name: metric_avgdaysbetweenpurchases\n    description: >\n      Average number of days between consecutive bike purchases for the\n      customer. Computed as the average of day differences between orderDate and\n      the next bike purchase date.\n    type: number\n  - name: metric_avgupgradevalue\n    description: >\n      Average lineTotal value (monetary) of purchases contributing to upgrades\n      for this customer. Inherits the definition of sales_order_detail.lineTotal\n      (typically net of discounts; taxes and freight excluded). Units follow the\n      sales currency.\n    type: number\nmetrics: []\nfilters:\n  - name: frequent_upgraders\n    expr: metric_upgradercategory = 'Frequent Upgrader'\n    description: Customers with average upgrade cycle under one year.\n    args: []\n  - name: annual_upgraders\n    expr: metric_upgradercategory = 'Annual Upgrader'\n    description: Customers with average upgrade cycle between one and two years.\n    args: []\n  - name: long_term_owners\n    expr: metric_upgradercategory = 'Long-term Owner'\n    description: Customers with average upgrade cycle over two years.\n    args: []\n  - name: individuals_only\n    expr: customer_type = 'Individual'\n    description: Restrict to individual customers.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Join to customer details and segmentation. This model is a per-customer\n      subset (customers with at least one upgrade interval). Use to enrich with\n      demographics/territory.\nclarifications:\n  - >-\n    Confirm the currency and whether metric_avgupgradevalue excludes\n    taxes/freight (inherited from lineTotal).\n  - >-\n    Are canceled/returned orders excluded from sales_order_detail and this\n    model?\n  - >-\n    Validate relationship coverage to customer on customerid is ≥ 95% (expected\n    ~100%).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "51f066bf-3389-4b47-864c-d7dc57b9c546",
    "name": "work_order_routing",
    "databaseName": "postgres",
    "whenToUse": "This model supports production process planning, manufacturing workflow optimization, and resource allocation. It provides critical insights into the routing of work orders through different manufacturing stages, enabling production managers to identify bottlenecks, optimize resource utilization, and improve operational efficiency. The data helps answer business questions related to production lead times, cost variances between planned and actual operations, and resource allocation effectiveness across manufacturing locations.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.work_order_routing",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082892+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "work_order_routing",
    "ymlFile": "name: work_order_routing\ndescription: >\n  Manufacturing routing records that detail the operational steps, locations,\n  and timing for work orders in production. Each row represents a specific\n  operation sequence at a work center/location for a work order. Essential for\n  analyzing manufacturing throughput, capacity utilization, cost tracking, and\n  production efficiency. Includes both scheduled and actual timing/cost data for\n  performance analysis.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: modifieddate\n    description: >\n      Timestamp when this routing record was last updated. Dates are normalized\n      via the shift_date macro in staging. Use for auditing changes and tracking\n      when routing operations were completed.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: workorderid\n    description: >\n      Foreign key linking to the parent work order. Join key to\n      work_order.workorderid to get order details like product quantities and\n      overall scheduling. Use as a grouping key to analyze routing efficiency by\n      work order; not meaningful to sum.\n    type: integer\n  - name: productid\n    description: >\n      Foreign key to the product being manufactured. Join key to\n      product.productid for product details and categorization. Use to analyze\n      routing patterns and efficiency by product type; not meaningful to sum.\n    type: integer\n  - name: operationsequence\n    description: >\n      Sequential step number within the routing for this work order (1-7).\n      Defines the order of manufacturing operations. Lower numbers execute\n      first. Use for sequencing analysis and identifying bottleneck operations\n      in the production flow.\n    type: integer\n  - name: locationid\n    description: >\n      Foreign key to the manufacturing location/work center where this operation\n      is performed. Join key to location.locationid for location details like\n      cost rates and capacity. Use to analyze throughput and utilization by work\n      center; not meaningful to sum.\n    type: integer\n  - name: scheduledstartdate\n    description: >\n      Planned start date and time for this routing operation. Represents the\n      initial production schedule. Compare with actualstartdate to measure\n      schedule adherence and identify planning accuracy issues.\n    type: timestamp without time zone\n  - name: scheduledenddate\n    description: >\n      Planned completion date and time for this routing operation. Represents\n      the target completion time in the production schedule. Compare with\n      actualenddate to measure schedule performance and cycle time variance.\n    type: timestamp without time zone\n  - name: actualstartdate\n    description: >\n      Actual start date and time when this routing operation began. Use to\n      calculate actual lead times, measure schedule adherence (vs\n      scheduledstartdate), and analyze production flow timing and delays.\n    type: timestamp without time zone\n  - name: actualenddate\n    description: >\n      Actual completion date and time when this routing operation finished. Use\n      to calculate actual cycle times, measure schedule adherence (vs\n      scheduledenddate), and analyze operation efficiency and throughput.\n    type: timestamp without time zone\n  - name: actualresourcehrs\n    description: >\n      Actual labor/machine hours consumed for this routing operation. Represents\n      the actual resource consumption for completing the operation. Use to\n      analyze efficiency, compare to planned hours, and calculate labor\n      productivity metrics.\n    type: numeric\n  - name: plannedcost\n    description: >\n      Planned/standard cost for this routing operation in currency units (e.g.,\n      USD). Represents the budgeted cost for the operation based on standard\n      rates and times. Use for cost variance analysis and budgeting; compare\n      with actualcost for performance.\n    type: numeric\n  - name: actualcost\n    description: >\n      Actual cost incurred for this routing operation in currency units (e.g.,\n      USD). Represents the true cost of completing the operation including labor\n      and overhead. Use for cost analysis, variance reporting, and profitability\n      assessment.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: work_order\n    source_col: workorderid\n    ref_col: workorderid\n    type: inner\n    cardinality: many-to-one\n    description: >\n      Parent work order that contains this routing operation. Join on\n      workorderid; one work order to many routing operations. Use to analyze\n      overall work order efficiency and scheduling.\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: inner\n    cardinality: many-to-one\n    description: >\n      Product being manufactured in this routing operation. Join on productid;\n      one product to many routing operations across different work orders. Use\n      to analyze manufacturing patterns and efficiency by product.\n  - name: location\n    source_col: locationid\n    ref_col: locationid\n    type: inner\n    cardinality: many-to-one\n    description: >\n      Manufacturing location/work center where this operation is performed. Join\n      on locationid; one location to many routing operations. Use to analyze\n      capacity utilization and throughput by work center.\nclarifications:\n  - >-\n    Confirm currency units for plannedcost and actualcost (e.g., USD) and\n    whether costs include labor, overhead, or both.\n  - >-\n    Are the date/time fields stored in UTC after shift_date normalization, and\n    what timezone should be used for reporting?\n  - >-\n    What is the business rule for operationsequence numbering - are there gaps\n    allowed or is it always sequential 1-N?\n  - >-\n    How should NULL values in scheduling/actual dates be interpreted -\n    operations not yet started/completed?\n  - >-\n    Are there dependencies between operation sequences that must be completed in\n    order, or can some run in parallel?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "9d05d999-aa98-4956-8d91-428bc100cea0",
    "name": "product_product_photo",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_product_photo",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_product_photo",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081911+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_product_photo",
    "ymlFile": "name: product_product_photo\ndescription: >\n  Junction table linking each product to its associated product photo. This\n  model currently surfaces the primary image per product (isPrimary) and the\n  last modification timestamp from the source. Use it to: - join product to\n  product_photo to retrieve the primary image assets for catalog\n    pages and analytics\n  - audit photo coverage and identify products using a shared/placeholder photo\n  - build product galleries when paired with non-primary associations, if\n  available upstream\n\n  Usage notes: - Current dataset only contains rows where isPrimary = true;\n  there is at most one row per product. - productphotoid is highly skewed, with\n  a dominant placeholder-like id used by many products. - modifieddate is\n  standardized in staging via a date-shifting macro and can represent a relative\n    rather than exact source timestamp.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: isprimary\n    description: >\n      Boolean flag indicating whether the linked photo is the product’s\n      primary/default image. Derived from\n      Production.ProductProductPhoto.\"Primary\" (quoted due to reserved word). In\n      this model all rows are primary; use this to filter when integrating with\n      other photo associations.\n    type: boolean\n    searchable: false\n  - name: modifieddate\n    description: >\n      Timestamp when this product–photo association was last updated in the\n      source. Standardized via the date-shifting macro in staging to keep\n      recency aligned across models.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: productid\n    description: >\n      Product identifier. Use for joins to product.productid; not intended for\n      aggregation except counts or distincts in QA/coverage checks.\n    type: integer\n  - name: productphotoid\n    description: >\n      Photo identifier. Use for joins to product_photo.productphotoid. Many\n      products may share the same photo (e.g., placeholder assets).\n    type: integer\nmetrics: []\nfilters:\n  - name: only_primary\n    expr: isprimary = true\n    description: >\n      Filters to primary images. Included for explicitness in downstream\n      queries.\n    args: []\n  - name: placeholder_photo\n    expr: productphotoid = 1\n    description: >\n      Identifies associations using the common placeholder/default photo id\n      observed in this dataset. Validate the constant in your environment before\n      relying on it.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Links each product–photo mapping to its product record. With only primary\n      associations present, this is effectively one-to-one at the product level.\n  - name: product_photo\n    source_col: productphotoid\n    ref_col: productphotoid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links to photo details (binary/image filenames). Many products can point\n      to the same photo identifier, especially for placeholders.\nclarifications:\n  - >-\n    Are non-primary product–photo associations intentionally excluded from this\n    model?\n  - >-\n    Confirm that productphotoid = 1 represents a placeholder/shared asset and\n    whether it is stable over time.\n  - >-\n    Should the relationship to product be documented as one-to-one, or can\n    multiple rows per product be expected if non-primary photos are introduced\n    later?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "ecdb5f81-eefe-4586-ad57-91ee222d722f",
    "name": "person_credit_card",
    "databaseName": "postgres",
    "whenToUse": "Generated model for person_credit_card",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.person_credit_card",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082496+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "person_credit_card",
    "ymlFile": "name: person_credit_card\ndescription: >\n  Junction table that links people to the credit cards associated with them. Use\n  it to look up all cards held by a person or all people linked to a card, and\n  to connect people to transactions that reference a given credit card. Records\n  are updated via `modifiedDate` (timezone-normalized in staging); typical usage\n  is to join to `person` and `credit_card`, and optionally to\n  `sales_order_header` through `creditCardID` for downstream order analysis.\n  Avoid treating the individual ID columns as unique keys; the effective\n  uniqueness is typically the composite of `(businessEntityID, creditCardID)`.\ndimensions:\n  - name: businessEntityID\n    description: >\n      Identifier of the person/business entity. Links to the `person` model. Use\n      to count cards per person or to filter to a given person. Not unique by\n      itself in this model.\n    type: integer\n    searchable: false\n  - name: creditCardID\n    description: >\n      Identifier of the credit card. Links to the `credit_card` model. Often\n      used to join to `sales_order_header` for orders paid by this card. Not\n      unique by itself in this model.\n    type: integer\n    searchable: false\n  - name: modifiedDate\n    description: >\n      Timestamp when the link record was last updated. In staging, a date-shift\n      macro is applied for consistency. Useful for recency filters (e.g., last\n      12 months).\n    type: timestamp\n    searchable: false\nmeasures: []\nmetrics:\n  - name: cards_per_person\n    expr: COUNT(DISTINCT creditCardID)\n    description: Distinct number of credit cards linked per person.\n    args: []\n  - name: people_per_card\n    expr: COUNT(DISTINCT businessEntityID)\n    description: Distinct number of people linked to a given card.\n    args: []\nfilters:\n  - name: recently_modified_12m\n    expr: modifiedDate >= CURRENT_DATE - INTERVAL '365 day'\n    description: Restrict to links updated in the last 12 months.\n    args: []\nrelationships:\n  - name: person\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to person details. Each link row belongs to exactly one person;\n      multiple link rows may exist per person when they hold multiple cards.\n  - name: credit_card\n    source_col: creditCardID\n    ref_col: creditCardID\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to card details. Each link row belongs to exactly one credit card;\n      multiple link rows may exist per card when shared across people.\n  - name: sales_order_header\n    source_col: creditCardID\n    ref_col: creditCardID\n    type: left\n    cardinality: one-to-many\n    description: >\n      Analytical join via card usage. Orders that reference a credit card can be\n      connected to people through this model. Coverage is <100% because not all\n      orders use a credit card.\nclarifications:\n  - >-\n    Confirm composite key uniqueness on (businessEntityID, creditCardID) at this\n    layer.\n  - >-\n    Does modifiedDate reflect business assignment updates or ETL load time?\n    Confirm timezone handling of the date-shift macro.\n  - >-\n    Are unlinked cards removed or soft-deleted? Is historical linkage retained\n    elsewhere?\n  - >-\n    Estimate relationship coverage to person and credit_card (expected ~100%)\n    and to sales_order_header (<100% due to optional card usage).\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "e77b58a9-d4fd-4465-8e58-d097e32fef91",
    "name": "person_phone",
    "databaseName": "postgres",
    "whenToUse": "Generated model for person_phone",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.person_phone",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082649+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "person_phone",
    "ymlFile": "name: person_phone\ndescription: >\n  Phone numbers associated with people. Use this model when you need to list,\n  filter, or join on a person’s phone contacts. Each row represents a specific\n  phone number for a given person and type (cell, home, work). Phone formats\n  vary (e.g., \"NNN-555-0123\", \"1 (11) 500 555-01xx\"); numbers are not\n  normalized. Modified timestamps are shifted by the date_shifting macro used in\n  staging and reflect a consistent demo time context.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: businessEntityID\n    description: >\n      Person identifier; foreign key to person.businessentityid. Not unique on\n      its own in this model because a person can have multiple phone numbers and\n      types. Use with phoneNumber and phoneNumberTypeID for composite\n      uniqueness.\n    type: integer\n    searchable: false\n  - name: phoneNumber\n    description: >\n      Raw phone number string as stored in the source system. Formats vary and\n      may include dashes and parentheses. Treat as display text; avoid numeric\n      math or strict equality comparisons without normalization.\n    type: character varying\n    searchable: false\n  - name: phoneNumberTypeID\n    description: >\n      Phone number category. See phone_number_type for names and details.\n      Typical values map to: 1 = Cell, 2 = Home, 3 = Work.\n    type: integer\n    searchable: false\n    options:\n      - value: 1\n        description: Cell\n      - value: 2\n        description: Home\n      - value: 3\n        description: Work\n  - name: modifiedDate\n    description: >\n      Record last modified timestamp (shifted using the staging date_shifting\n      macro). Useful for recency filters; not a creation date.\n    type: timestamp without time zone\n    searchable: false\nmeasures: []\nmetrics: []\nfilters:\n  - name: is_cell_phone\n    expr: phoneNumberTypeID = 1\n    description: Keep only cell/mobile phone numbers.\n    args: []\n  - name: is_home_phone\n    expr: phoneNumberTypeID = 2\n    description: Keep only home phone numbers.\n    args: []\n  - name: is_work_phone\n    expr: phoneNumberTypeID = 3\n    description: Keep only work phone numbers.\n    args: []\nrelationships:\n  - name: person\n    source_col: businessEntityID\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each phone record to its person. Many phone records per person; join\n      on businessEntityID.\n  - name: phone_number_type\n    source_col: phoneNumberTypeID\n    ref_col: phonenumbertypeid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Categorizes the phone number (Cell/Home/Work). One type per phone record;\n      join on phoneNumberTypeID.\nclarifications:\n  - >-\n    Confirm that composite uniqueness is (businessEntityID, phoneNumber,\n    phoneNumberTypeID) and no additional surrogate keys exist at this layer.\n  - >-\n    Is phoneNumber formatting guaranteed to remain as-is, or should downstream\n    models normalize (strip punctuation, country codes) for matching?\n  - >-\n    Are multiple phone numbers of the same type allowed for a single person, or\n    is at most one per type expected?\n  - >-\n    Does modifiedDate represent source last update, or any transformation/load\n    time adjustments beyond date shifting?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "71c15234-7a27-4e85-a16b-72017d8afd53",
    "name": "department",
    "databaseName": "postgres",
    "whenToUse": "Organizational structure model supporting departmental performance analysis, workforce planning, and resource allocation optimization. Enables headcount tracking by organizational unit, departmental budget analysis, and cross-functional team composition studies. Essential for organizational design initiatives, reporting hierarchy visualization, and operational efficiency assessment.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.department",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082752+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "department",
    "ymlFile": "name: department\ndescription: >\n  Reference list of business departments within the organization. Use this model\n  to look up department attributes (name and high‑level functional group) and to\n  categorize employee assignments and history. Commonly joined to employee\n  assignment history to analyze headcount and movement by department. Notes:\n  `modifiedDate` is normalized via the `shift_date` macro in staging; the set of\n  departments is small and relatively stable.\ndimensions:\n  - name: departmentID\n    description: >\n      Unique identifier for the department. Sequential integer used as the\n      primary key for this model and the foreign key in employee assignment\n      history. Usage notes: join to `employee_department_history.departmentID`.\n    type: integer\n    searchable: false\n  - name: name\n    description: >\n      Department name (human‑readable). Useful for grouping and display in\n      reporting. Values include items like Engineering, Sales, Marketing, etc.\n    type: string\n    searchable: true\n  - name: groupName\n    description: >\n      High‑level functional grouping of departments. Good for rollups and\n      dashboards where fewer categories are preferred.\n    type: string\n    searchable: false\n    options:\n      - Executive General and Administration\n      - Research and Development\n      - Manufacturing\n      - Inventory Management\n      - Quality Assurance\n      - Sales and Marketing\n  - name: modifiedDate\n    description: >\n      Source system modified timestamp for the department record, normalized in\n      staging. Often constant in this dataset but should be treated as an audit\n      timestamp, not a business effective date.\n    type: timestamp\n    searchable: false\nmeasures: []\nmetrics: []\nfilters:\n  - name: is_research_and_development\n    expr: groupName = 'Research and Development'\n    description: Filter departments to Research and Development only.\n    args: []\n  - name: is_sales_and_marketing\n    expr: groupName = 'Sales and Marketing'\n    description: Filter departments to Sales and Marketing only.\n    args: []\nrelationships:\n  - name: employee_department_history\n    source_col: departmentID\n    ref_col: departmentID\n    cardinality: one-to-many\n    description: >\n      Links departments to employee assignment history to analyze staffing and\n      movements over time by department.\nclarifications:\n  - >-\n    Confirm that `modifiedDate` reflects the source record modified timestamp\n    and not a business effective date.\n  - >-\n    Validate that `departmentID` values are stable and never reused if\n    departments are renamed/retired.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "749f1077-c025-4f0b-bc36-d647437b4150",
    "name": "address_type",
    "databaseName": "postgres",
    "whenToUse": "Categorizes addresses by their purpose (e.g., home, billing, shipping). Essential for contact management, targeted communications, and understanding address usage patterns across the organization.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.address_type",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082973+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "address_type",
    "ymlFile": "name: address_type\ndescription: >\n  Reference table that enumerates address categories used across the system (for\n  example, Shipping, Billing, Home, Main Office, Primary, Archive). Use it to\n  classify and filter addresses or address mappings by purpose. Values are a\n  small, stable set; prefer equality filters on name or use the numeric key for\n  joins. Includes a UUID for replication/integration and a last-updated\n  timestamp.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable label for the address type. Typical values include\n      Shipping, Billing, Home, Main Office, Primary, and Archive. Use for\n      filtering and presentation; treat as an enum rather than free text.\n    type: character varying\n    searchable: false\n    options:\n      - Billing\n      - Home\n      - Primary\n      - Shipping\n      - Main Office\n      - Archive\n  - name: rowguid\n    description: >\n      System-generated UUID (v4, hyphenated) used for replication and\n      cross-system integration. Unique per record; generally not used for\n      analytics.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp of the most recent update to this record. Useful for change\n      tracking; not a business date. Values may be identical across rows in a\n      snapshot. Timezone not encoded in the type; interpret consistently (often\n      UTC) across analyses.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: addresstypeid\n    description: >\n      Surrogate key for the address type. Use as the join key to related models\n      (e.g., business_entity_address). Not intended for aggregation.\n    type: integer\nmetrics: []\nfilters:\n  - name: is_shipping\n    expr: LOWER(name) = 'shipping'\n    description: Filter rows to the Shipping address type.\n    args: []\n  - name: is_billing\n    expr: LOWER(name) = 'billing'\n    description: Filter rows to the Billing address type.\n    args: []\nrelationships:\n  - name: business_entity_address\n    source_col: addresstypeid\n    ref_col: addresstypeid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Categorizes address mappings to business entities by type (e.g., Shipping\n      vs Billing). Join on addresstypeid; one address_type maps to many\n      business_entity_address rows.\nclarifications:\n  - >-\n    Confirm that the set of address type names is stable and closed (no\n    additional values expected).\n  - >-\n    Should modifieddate be interpreted as UTC? If not, provide timezone\n    guidance.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "88f15028-49f1-4b54-9769-dafddf145a1f",
    "name": "seasonal_product_velocity",
    "databaseName": "postgres",
    "whenToUse": "Generated model for seasonal_product_velocity",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.seasonal_product_velocity",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08167+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "seasonal_product_velocity",
    "ymlFile": "name: seasonal_product_velocity\ndescription: >\n  Seasonality analysis by product at a quarterly grain. For each product and\n  quarter (Q1–Q4), this model provides average units sold and average revenue\n  across years, plus seasonality indices that compare a quarter to the product’s\n  own annual average. Use it to identify peak and low seasons for products, plan\n  inventory, and prioritize promotions. Revenue is derived from order line\n  totals (includes discounts). Category thresholds for seasonality are based on\n  unit index.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Product identifier from the product master. Use for joins to the product\n      model and other product-grained datasets. Multiple seasonal rows (one per\n      quarter) exist per product.\n    type: integer\n    searchable: false\n  - name: product_name\n    description: >\n      Human-readable product name from the product master (e.g., \"Road-150 Red,\n      62\"). Useful for reporting and search; not guaranteed unique.\n    type: text\n    searchable: true\n  - name: quarter\n    description: >\n      Quarter of year for the seasonal aggregation. Values are 1 (Q1) through 4\n      (Q4).\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n  - name: metric_seasoncategory\n    description: >\n      Season label derived from seasonal_unit_index: > 1.25 = High Season; <\n      0.75 = Low Season; otherwise Regular Season.\n    type: text\n    searchable: false\n    options:\n      - High Season\n      - Regular Season\n      - Low Season\nmeasures:\n  - name: avg_quarterly_units\n    description: >\n      Average number of units sold in the quarter across years for the given\n      product. Computed as AVG(quarterly_units) after aggregating monthly sales\n      into quarterly totals by product and year.\n    type: number\n  - name: avg_quarterly_revenue\n    description: >\n      Average revenue in the quarter across years for the given product. Revenue\n      is summed from sales_order_detail.lineTotal and then averaged across\n      years. Note: lineTotal includes discounts (unitpricediscount);\n      returns/cancellations are not explicitly adjusted here.\n    type: number\n  - name: seasonal_unit_index\n    description: >\n      Ratio of avg_quarterly_units to the product’s avg_annual_units. 1.0\n      indicates on-par with the product’s annual average; > 1.0 above-average\n      seasonal demand; < 1.0 below-average.\n    type: float\n  - name: seasonal_revenue_index\n    description: >\n      Ratio of avg_quarterly_revenue to the product’s avg_annual_revenue.\n      Interpreted analogously to seasonal_unit_index but for revenue.\n    type: float\n  - name: metric_seasonalvalue\n    description: >\n      Revenue-weighted seasonal score: seasonal_unit_index *\n      avg_quarterly_revenue. Higher values indicate higher expected seasonal\n      revenue impact for the quarter.\n    type: number\nmetrics: []\nfilters:\n  - name: high_season\n    expr: metric_seasoncategory = 'High Season'\n    description: Keep only quarters categorized as High Season.\n    args: []\n  - name: regular_season\n    expr: metric_seasoncategory = 'Regular Season'\n    description: Keep only quarters categorized as Regular Season.\n    args: []\n  - name: low_season\n    expr: metric_seasoncategory = 'Low Season'\n    description: Keep only quarters categorized as Low Season.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to the product master for attributes and categorization. One product\n      has up to four seasonal rows (one per quarter). Use for enrichment; join\n      key is productid.\n  - name: sales_order_detail\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Underlying order line items that roll up into this seasonal aggregation.\n      Joining will fan out rows (one-to-many) and is typically used for\n      drill-through or validation, not for aggregation.\nclarifications:\n  - >-\n    Confirm unit-based thresholds for season categorization: > 1.25 = High, <\n    0.75 = Low. Should revenue index also influence the category?\n  - >-\n    Should averages be weighted or adjusted for missing months/years (sparse\n    sales)? Currently simple averages across years are used.\n  - >-\n    Are returns/cancellations or post-order adjustments reflected in revenue, or\n    should a net-revenue definition be used?\n  - >-\n    Is currency conversion required to a base currency before aggregation, or is\n    all revenue already standardized?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "4db3f53f-9b69-4011-9010-da39385986fc",
    "name": "sales_territory",
    "databaseName": "sales_territory",
    "whenToUse": "A strategic model for geographic sales analysis and market segmentation. Supports detailed regional performance evaluation, enables market penetration measurements across territories, facilitates geographic expansion planning, and provides insights for territory realignment decisions. Essential for identifying high-potential markets, optimizing resource allocation, and developing region-specific strategies to maximize sales effectiveness and profitability across different geographic areas.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .sales_territory",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082204+00",
    "updatedAt": "2025-05-02 17:10:46.082204+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: sales_territory\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: A strategic model for geographic sales analysis and market segmentation. Supports detailed regional performance evaluation, enables market penetration measurements across territories, facilitates geographic expansion planning, and provides insights for territory realignment decisions. Essential for identifying high-potential markets, optimizing resource allocation, and developing region-specific strategies to maximize sales effectiveness and profitability across different geographic areas.\\n  model: null\\n  entities:\\n  - name: country_region\\n    ref_: null\\n    expr: countryregioncode\\n    type: foreign\\n    description: Reference to the country region\\n    project_path: null\\n  - name: sales_territory_history\\n    ref_: null\\n    expr: territoryid\\n    type: foreign\\n    description: Reference to the sales territory history\\n    project_path: null\\n  - name: customer\\n    ref_: null\\n    expr: territoryid\\n    type: foreign\\n    description: Reference to customers in this territory\\n    project_path: null\\n  - name: sales_person\\n    ref_: null\\n    expr: territoryid\\n    type: foreign\\n    description: Reference to sales people in this territory\\n    project_path: null\\n  - name: sales_order_header\\n    ref_: null\\n    expr: territoryid\\n    type: foreign\\n    description: Reference to sales orders in this territory\\n    project_path: null\\n  dimensions:\\n  - name: name\\n    expr: name\\n    type: character varying\\n    description: Name of the sales territory\\n    searchable: true\\n  - name: countryregioncode\\n    expr: countryregioncode\\n    type: character varying\\n    description: Country/Region code that identifies the territory\\n    searchable: true\\n  - name: groupname\\n    expr: groupname\\n    type: character varying\\n    description: Group name associated with the sales territory\\n    searchable: true\\n  - name: rowguid\\n    expr: rowguid\\n    type: uuid\\n    description: Unique identifier for the sales territory record\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp indicating when the record was last modified\\n    searchable: false\\n  measures:\\n  - name: territoryid\\n    expr: territoryid\\n    agg: sum\\n    description: Aggregated territory identifier\\n    type: integer\\n  - name: salesytd\\n    expr: salesytd\\n    agg: sum\\n    description: Year-to-date sales aggregated for the territory\\n    type: numeric\\n  - name: saleslastyear\\n    expr: saleslastyear\\n    agg: sum\\n    description: Aggregated sales from the last year for the territory\\n    type: numeric\\n  - name: costytd\\n    expr: costytd\\n    agg: sum\\n    description: Year-to-date cost aggregated for the territory\\n    type: numeric\\n  - name: costlastyear\\n    expr: costlastyear\\n    agg: sum\\n    description: Aggregated cost from the last year for the territory\\n    type: numeric\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "1b2d4b68-d706-48b6-9b62-e44f11253a97",
    "name": "business_entity_contact",
    "databaseName": "postgres",
    "whenToUse": "This relationship model facilitates contact relationship management, communication channel analysis, and business network mapping. It helps answer key business questions about relationship types between entities and people, contact distribution across departments, communication preference patterns, and relationship network growth over time. The model is valuable for stakeholder analysis, relationship mapping, communication strategy development, and identifying key business relationships that drive organizational success.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.business_entity_contact",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082608+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "business_entity_contact",
    "ymlFile": "name: business_entity_contact\ndescription: >\n  Mapping between a business entity and the person who serves as its contact,\n  with a role defined by contact type. Use this model to understand which person\n  represents a given business entity and the nature of that relationship (e.g.,\n  contact role). Typical usage includes joining to person for demographics and\n  to business_entity for entity-level context, filtered or grouped by contact\n  type. Timestamps reflect last update to the mapping.\ndimensions:\n  - name: businessEntityID\n    description: >\n      Identifier of the business entity the person represents. Foreign key to\n      business_entity.businessEntityID. Multiple rows can share the same\n      businessEntityID when an entity has multiple contacts or roles.\n    type: integer\n    searchable: false\n  - name: personID\n    description: >\n      Identifier of the person serving as the contact. Foreign key to\n      person.businessEntityID. Profiling shows personID is unique in this table\n      (one row per person) in current data.\n    type: integer\n    searchable: false\n  - name: contactTypeID\n    description: >\n      Identifier of the contact role/type for this relationship. Foreign key to\n      contact_type.contactTypeID. Use the joined contact_type.name for human-\n      readable role labels.\n    type: integer\n    searchable: false\n  - name: modifiedDate\n    description: >\n      Timestamp when this contact mapping record was last updated. Useful for\n      recency tracking and change audits.\n    type: timestamp\n    searchable: false\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: business_entity\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each contact mapping to the referenced business entity for\n      entity-level attributes and context.\n  - name: person\n    source_col: personID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-one\n    description: >\n      Links each contact mapping to the person record. In current data personID\n      is unique in this table, indicating one contact mapping per person.\n  - name: contact_type\n    source_col: contactTypeID\n    ref_col: contactTypeID\n    type: left\n    cardinality: many-to-one\n    description: |\n      Links to the catalog of contact roles/types for human-readable labels.\nclarifications:\n  - >-\n    Confirm that personID is the unique key for this model (profiling shows\n    1:1).\n  - >-\n    Validate relationship coverage: ≥ 95% matches to person and business_entity\n    on the specified keys?\n  - >-\n    Can a person appear multiple times with different contact types, or is it\n    strictly one role per person?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "a3eff32e-ee11-4fac-bdce-a77d8354d604",
    "name": "product",
    "databaseName": "postgres",
    "whenToUse": "Central product catalog model that serves as the backbone for inventory management, sales performance analysis, and product lifecycle tracking. Enables product profitability assessment, manufacturing planning, and supply chain optimization while supporting customer-facing product information needs.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082031+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product",
    "ymlFile": "name: product\ndescription: >\n  Product represents items in the Adventure Works catalog, including complete\n  bikes, frames, components, and accessories. Use this model when you need the\n  canonical product attributes (name, SKU/product number, pricing, dimensions,\n  flags) and the derived merchandising filters that categorize bikes by riding\n  discipline, skill level, component grade, seasonality, and frame material.\n  Typical analyses include joining from sales order lines, inventory, vendor\n  sourcing, reviews, and bill of materials. Note that several coded fields are\n  CHARs and may include padding; color and size are often null for components;\n  and some pricing/cost fields are zero for non-sellable parts. Filter fields\n  are heuristics derived from name/category/price.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Primary key for the product. Stable identifier used to join with sales\n      order lines, inventory, reviews, vendor sourcing, BOM, and other\n      product-related models.\n    type: integer\n    searchable: false\n  - name: name\n    description: >\n      Human-readable product name shown in the catalog. Often includes color and\n      size (e.g., \"Road-150 Red, 62\"). Usage notes: Good for display and search;\n      unique per row.\n    type: character varying\n    searchable: true\n  - name: productnumber\n    description: >\n      SKU-style alphanumeric identifier used operationally (e.g., \"BK-R93R-62\").\n      Stable across systems; useful for lookups and user-facing SKU references.\n    type: character varying\n    searchable: false\n  - name: makeflag\n    description: >\n      Indicates whether the product is manufactured in-house (true) versus\n      purchased or otherwise not manufactured internally (false).\n    type: boolean\n    searchable: false\n    options:\n      - true\n      - false\n  - name: finishedgoodsflag\n    description: >\n      Indicates whether this row represents a finished good (true) that can be\n      sold, or a non-finished component/subassembly (false).\n    type: boolean\n    searchable: false\n    options:\n      - true\n      - false\n  - name: color\n    description: >\n      Color of the product when applicable. Usage notes: Frequently null for\n      components and some accessories.\n    type: character varying\n    searchable: false\n    options:\n      - Black\n      - Silver\n      - Red\n      - Yellow\n      - Blue\n      - Multi\n      - Silver/Black\n      - White\n      - Grey\n  - name: safetystocklevel\n    description: >\n      Minimum desired inventory level for planning/replenishment. Usage notes:\n      Discrete planning values; not a measure of demand.\n    type: smallint\n    searchable: false\n  - name: reorderpoint\n    description: >\n      Inventory level that triggers a replenishment order. Usage notes: Discrete\n      planning values; coordinate with safety stock.\n    type: smallint\n    searchable: false\n  - name: size\n    description: >\n      Size designation for the product (e.g., frame size in cm or apparel\n      S/M/L). Usage notes: Often null for components; units indicated by\n      sizeUnitMeasureCode.\n    type: character varying\n    searchable: false\n  - name: sizeunitmeasurecode\n    description: >\n      Unit of measure code for size (maps to unit_measure.unitMeasureCode).\n      Examples: \"CM\".\n    type: character\n    searchable: false\n  - name: weightunitmeasurecode\n    description: >\n      Unit of measure code for weight (maps to unit_measure.unitMeasureCode).\n      Examples: \"LB\", \"G\".\n    type: character\n    searchable: false\n  - name: productline\n    description: >\n      Product line code (single-character CHAR, padded). Commonly represents\n      categories like Road, Mountain, Touring, etc. Used primarily for\n      merchandising.\n    type: character\n    searchable: false\n  - name: class\n    description: >\n      Product class code (single-character CHAR, padded) roughly indicating tier\n      (e.g., H, M, L). Used by derived component grade filter.\n    type: character\n    searchable: false\n  - name: style\n    description: >\n      Product style code (single-character CHAR, padded). Used in conjunction\n      with price and class to infer component grade.\n    type: character\n    searchable: false\n  - name: sellstartdate\n    description: |\n      Date the product became available for sale.\n    type: timestamp without time zone\n    searchable: false\n  - name: sellenddate\n    description: >\n      Date the product stopped being sold. Often null for products still on\n      sale. Usage notes: Combine with discontinuedDate for active status logic.\n    type: timestamp without time zone\n    searchable: false\n  - name: discontinueddate\n    description: >\n      Date the product was discontinued. Often null; when present, indicates\n      product is no longer produced/supported.\n    type: timestamp without time zone\n    searchable: false\n  - name: rowguid\n    description: System GUID for the product row.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: Last modification timestamp in the source system.\n    type: timestamp without time zone\n    searchable: false\n  - name: productsubcategoryid\n    description: >-\n      Foreign key to product_subcategory.productSubcategoryID (nullable for\n      components).\n    type: integer\n    searchable: false\n  - name: productmodelid\n    description: >-\n      Foreign key to product_model.productModelID (nullable for some\n      parts/components).\n    type: integer\n    searchable: false\n  - name: filter_riding_discipline\n    description: >\n      Derived merchandising filter inferred from subcategory/name (bike\n      discipline).\n    type: text\n    searchable: false\n    options:\n      - Mountain\n      - Road\n      - Touring\n      - Cruiser\n      - Gravel\n      - Commuter\n      - General Riding\n  - name: filter_skill_level\n    description: >\n      Derived merchandising filter inferred from list price for Bikes category.\n      Non-bike items are labeled \"Not Applicable\".\n    type: text\n    searchable: false\n    options:\n      - Beginner\n      - Intermediate\n      - Advanced\n      - Professional\n      - Not Applicable\n      - All Levels\n  - name: filter_component_grade\n    description: |\n      Derived merchandising filter inferred from class/style and price.\n    type: text\n    searchable: false\n    options:\n      - Professional\n      - Elite\n      - Sport\n      - Entry\n      - Standard\n  - name: filter_seasonality\n    description: |\n      Derived seasonality indicator based on subcategory/name cues.\n    type: text\n    searchable: false\n    options:\n      - Winter-focused\n      - Summer-focused\n      - Year-round\n  - name: filter_frame_material\n    description: >\n      Derived frame material for bikes based on name cues and weight bands; null\n      for non-bike items.\n    type: text\n    searchable: false\n    options:\n      - Carbon\n      - Aluminum\n      - Steel\n      - Titanium\n      - Composite\nmeasures:\n  - name: standardcost\n    description: >\n      Standard cost for the product in company currency. Often zero for\n      components or placeholder items; use with care when aggregating across\n      mixed product types.\n    type: numeric\n  - name: listprice\n    description: >\n      Catalog/list price (MSRP) for sellable items. Frequently zero for\n      non-sellable components; prefer sales facts for realized prices.\n    type: numeric\n  - name: weight\n    description: |\n      Product weight. Units determined by weightUnitMeasureCode (e.g., LB, G).\n    type: numeric\n  - name: daystomanufacture\n    description: >\n      Lead time (days) to manufacture the product. Zero for purchased or\n      non-assembled items; useful for planning and service calculations.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: sales_order_detail\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Sales order line items for this product.\n  - name: product_inventory\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Inventory records by location/shelf/bin for this product.\n  - name: product_review\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Customer reviews associated with this product.\n  - name: product_document\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Documents linked to this product.\n  - name: product_product_photo\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Mapping of product to photos; use to reach product_photo.\n  - name: product_vendor\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Vendors that supply this product and their sourcing details.\n  - name: bill_of_materials_component\n    source_col: productid\n    ref_col: componentid\n    cardinality: one-to-many\n    description: BOM rows where this product is used as a component.\n  - name: bill_of_materials_assembly\n    source_col: productid\n    ref_col: productassemblyid\n    cardinality: one-to-many\n    description: BOM rows where this product is the assembled product.\n  - name: product_subcategory\n    source_col: productsubcategoryid\n    ref_col: productsubcategoryid\n    cardinality: many-to-one\n    description: Subcategory this product belongs to (nullable for some components).\n  - name: product_model\n    source_col: productmodelid\n    ref_col: productmodelid\n    cardinality: many-to-one\n    description: Product model metadata (nullable for some components).\n  - name: unit_measure_size\n    source_col: sizeunitmeasurecode\n    ref_col: unitmeasurecode\n    cardinality: many-to-one\n    description: Unit of measure record for sizeUnitMeasureCode.\n  - name: unit_measure_weight\n    source_col: weightunitmeasurecode\n    ref_col: unitmeasurecode\n    cardinality: many-to-one\n    description: Unit of measure record for weightUnitMeasureCode.\n  - name: special_offer_product\n    source_col: productid\n    ref_col: productid\n    cardinality: one-to-many\n    description: Special offers applicable to this product.\nclarifications:\n  - >-\n    Confirm mapping/meaning for productLine, class, and style codes and whether\n    trailing spaces are padding.\n  - >-\n    Verify full set of unit measure codes for size and weight (e.g., CM, LB, G,\n    KG) and expected mappings to unit_measure.\n  - >-\n    Validate that listPrice = 0 and standardCost = 0 indicate non-sellable\n    components rather than missing data.\n  - >-\n    Confirm the preferred definition for \"active\" products (sellEndDate vs\n    discontinuedDate vs both).\n  - >-\n    Confirm expected null rates and business rules for productSubcategoryID and\n    productModelID (especially for components).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "e277bc07-e004-4db1-83ce-6a21dd3d748c",
    "name": "product_list_price_history",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_list_price_history",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_list_price_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081989+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_list_price_history",
    "ymlFile": "name: product_list_price_history\ndescription: >\n  Tracks historical list prices for each product with effective date ranges. Use\n  this model to analyze price changes over time, identify the currently\n  effective list price, and join to product attributes for enrichment. Contains\n  one row per product and effective period defined by startdate and enddate\n  (enddate is null for the currently active price). Timestamps are normalized\n  via the shift_date macro in staging. List prices reflect the catalog/list\n  price and do not include transactional discounts or promotions.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: startdate\n    description: >\n      Start timestamp when this list price became effective for the product.\n      Usage notes: Typically a small set of standardized change dates per year;\n      treat as the inclusive boundary of the effective period. For calendar\n      reporting, join or truncate to date (see date_dimension). Timestamps are\n      normalized via shift_date in staging.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: enddate\n    description: >\n      End timestamp when this list price stopped being effective. Null indicates\n      the current/open-ended price period. Treat as the exclusive boundary for\n      filtering by effective ranges. For calendar reporting, join or truncate to\n      date (see date_dimension). Timestamps are normalized via shift_date in\n      staging.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp of the last modification recorded for this row in the source.\n      Often aligns with batch processing or price change cutover times. Use for\n      auditing or recency checks rather than effective-period logic. Normalized\n      via shift_date in staging.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: productid\n    description: >\n      Product identifier associated with this price record. Use as the foreign\n      key to join with the product model. Not unique in this table. For counts,\n      prefer count_distinct(productid) rather than summation.\n    type: integer\n  - name: listprice\n    description: >\n      List/catalog price for the product during the effective period. Represents\n      the nominal price before discounts or promotions. Typical usage: latest\n      active price, historical price trend analysis, and comparisons across\n      products or categories.\n    type: numeric\nmetrics: []\nfilters:\n  - name: active_price\n    expr: enddate IS NULL\n    description: |\n      Selects the currently effective price record for each product.\n    args: []\n  - name: historical_price\n    expr: enddate IS NOT NULL\n    description: |\n      Selects price records that are no longer effective.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Enrich price history with product attributes (name, category, etc.). One\n      or more price records per product over time; many-to-one on the product\n      dimension.\n  - name: date_dimension\n    source_col: startdate\n    ref_col: fulldate\n    type: left\n    cardinality: many-to-one\n    description: >\n      Calendar attributes for the start of the effective period. Join on date\n      (cast or truncate startdate to date) when grouping by calendar. Many price\n      records can share the same start date.\n  - name: date_dimension\n    source_col: enddate\n    ref_col: fulldate\n    type: left\n    cardinality: many-to-one\n    description: >\n      Calendar attributes for the end of the effective period. Only applicable\n      when enddate is not null; join on date (cast or truncate enddate to date)\n      when needed.\n  - name: date_dimension\n    source_col: modifieddate\n    ref_col: fulldate\n    type: left\n    cardinality: many-to-one\n    description: >\n      Calendar attributes for the modification timestamp (auditing/recency\n      views). Join on date (cast or truncate modifieddate to date) when grouping\n      by calendar.\nclarifications:\n  - >-\n    Confirm timezone and exact behavior of the shift_date macro used for\n    startdate/enddate/modifieddate.\n  - >-\n    Are effective period boundaries interpreted as [startdate, enddate) with\n    enddate exclusive?\n  - >-\n    Is listprice always in a single currency, or can currency conversion apply\n    upstream/downstream?\n  - >-\n    Does every product have at least one price record? If not, what is expected\n    coverage when joining to product?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "8d9c9e41-d08c-4845-a871-12e96d9885a3",
    "name": "unit_measure",
    "databaseName": "unit_measure",
    "whenToUse": "This model supports standardized measurement systems, international unit conversions, and consistent product specifications. It serves as a critical reference for maintaining measurement consistency across the organization's product catalog, inventory management, and procurement processes. The data helps answer business questions related to unit standardization, conversion requirements for global markets, and measurement compatibility across products and suppliers, ensuring accurate specifications and pricing throughout the supply chain.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .unit_measure",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083004+00",
    "updatedAt": "2025-05-02 17:10:46.083004+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: unit_measure\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: This model supports standardized measurement systems, international unit conversions, and consistent product specifications. It serves as a critical reference for maintaining measurement consistency across the organization's product catalog, inventory management, and procurement processes. The data helps answer business questions related to unit standardization, conversion requirements for global markets, and measurement compatibility across products and suppliers, ensuring accurate specifications and pricing throughout the supply chain.\\n  model: null\\n  entities:\\n  - name: product\\n    ref_: null\\n    expr: unitmeasurecode\\n    type: foreign\\n    description: Reference to products using this unit measure\\n    project_path: null\\n  - name: bill_of_materials\\n    ref_: null\\n    expr: unitmeasurecode\\n    type: foreign\\n    description: Reference to bill of materials using this unit measure\\n    project_path: null\\n  - name: product_vendor\\n    ref_: null\\n    expr: unitmeasurecode\\n    type: foreign\\n    description: Reference to product vendors using this unit measure\\n    project_path: null\\n  dimensions:\\n  - name: unitmeasurecode\\n    expr: unitmeasurecode\\n    type: character\\n    description: Unique code assigned to the unit measure.\\n    searchable: true\\n  - name: name\\n    expr: name\\n    type: character varying\\n    description: Name of the unit measure.\\n    searchable: true\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp indicating the last modification date of the unit measure.\\n    searchable: false\\n  measures: []\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "a534029d-59db-426a-83d7-cac75470d938",
    "name": "purchase_order_detail",
    "databaseName": "postgres",
    "whenToUse": "Generated model for purchase_order_detail",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.purchase_order_detail",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082558+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "purchase_order_detail",
    "ymlFile": "name: purchase_order_detail\ndescription: >\n  Line-item level details for each purchase order. Each row represents a single\n  product line on a purchase order, including the ordered quantity, unit price,\n  and receipt outcomes (received and rejected quantities). Use this model for\n  procurement analysis such as order composition, unit pricing,\n  fulfillment/receipt tracking, and quality issues. Join to\n  purchase_order_header for vendor, dates, and totals; join to product for\n  product attributes and categorization.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: purchaseorderid\n    description: >\n      Parent purchase order identifier. Use to join to purchase_order_header.\n      Not unique by itself; many detail lines can share the same value.\n    type: integer\n    searchable: false\n  - name: purchaseorderdetailid\n    description: >\n      Unique identifier for the purchase order line item. In the source, this is\n      part of a composite key with purchaseorderid; in this model it is unique\n      on its own and can be used to reference a specific line.\n    type: integer\n    searchable: false\n  - name: productid\n    description: >\n      Identifier of the product on this line. Join to product to access names,\n      categories, and other product attributes.\n    type: integer\n    searchable: false\n  - name: duedate\n    description: >\n      Expected delivery date for this line item. Timestamp without time zone.\n      Useful for expected receipt timelines and backlog analysis.\n    type: timestamp without time zone\n    searchable: false\n  - name: modifieddate\n    description: >\n      Last time this line item record was modified. Can help identify recent\n      changes or late updates to orders and receipts.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: orderqty\n    description: >\n      Quantity ordered for this line (units). Typical aggregation is SUM for\n      ordered volume. Common lot sizes appear frequently (e.g., 3, 60, 550),\n      indicating standardized order quantities.\n    type: smallint\n  - name: unitprice\n    description: >\n      Unit purchase price for the product on this line. Monetary numeric value\n      used to compute line amounts. Typically aggregated in derived metrics\n      (e.g., orderqty * unitprice). Currency and inclusion/exclusion of\n      taxes/fees may vary by system configuration.\n    type: numeric\n  - name: receivedqty\n    description: >\n      Quantity received for this line (units). Often equals orderqty when fully\n      received. Use SUM to compute total receipts and to derive fulfillment\n      rates.\n    type: numeric\n  - name: rejectedqty\n    description: >\n      Quantity rejected upon receipt (units). Mostly zero; non-zero values\n      indicate quality issues or discrepancies. Use SUM and rates to monitor\n      rejection patterns.\n    type: numeric\nmetrics:\n  - name: line_extended_amount\n    expr: orderqty * unitprice\n    description: Line amount before tax/freight orderqty * unitprice.\n    args: []\n  - name: receipt_rejection_rate\n    expr: >-\n      CASE WHEN receivedqty > 0 THEN rejectedqty::numeric / receivedqty ELSE\n      NULL END\n    description: Share of received items rejected for this line.\n    args: []\nfilters:\n  - name: fully_received\n    expr: (receivedqty = orderqty) AND (rejectedqty = 0)\n    description: Lines fully received with no rejections.\n    args: []\n  - name: has_rejects\n    expr: rejectedqty > 0\n    description: Lines with any rejected quantity.\n    args: []\nrelationships:\n  - name: purchase_order_header\n    source_col: purchaseorderid\n    ref_col: purchaseorderid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Parent purchase order header providing vendor, dates, and financial\n      totals. Use this join to analyze line items in the context of the overall\n      purchase order.\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: |\n      Product dimension providing names, categories, and product attributes.\nclarifications:\n  - >-\n    Confirm currency for unitprice and whether it excludes tax, freight, and\n    discounts.\n  - >-\n    Is purchaseorderdetailid guaranteed globally unique, or unique only within\n    purchaseorderid?\n  - >-\n    Does receivedqty represent cumulative receipts (supporting partial\n    receipts), or final receipt only?\n  - >-\n    Confirm duedate semantics: expected delivery date at the line level;\n    timezone handling/assumption (stored as timestamp without time zone).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "5048146e-556c-4087-a74f-5898d72602ae",
    "name": "transaction_history_archive",
    "databaseName": "postgres",
    "whenToUse": "Generated model for transaction_history_archive",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.transaction_history_archive",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083108+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "transaction_history_archive",
    "ymlFile": "name: transaction_history_archive\ndescription: >\n  Archived inventory transaction records for historical analysis. Contains older\n  product movement  data including sales fulfillment, work order consumption,\n  and purchase receipts that have been  moved from the active\n  transaction_history table. Same structure as transaction_history but for \n  archived periods. Use for long-term trend analysis, historical reconciliation,\n  and compliance  reporting when combined with current transaction_history data.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: transactiontype\n    description: >\n      Single-character code indicating transaction source: 'S' for Sales order\n      shipments,  'W' for Work order consumption, 'P' for Purchase order\n      receipts. Same codes as  transaction_history for consistency.\n    type: character\n    searchable: true\n    options:\n      - S\n      - W\n      - P\n  - name: transactiondate\n    description: >\n      Timestamp when inventory movement occurred. Historical dates from archived\n      periods.  Date-shifted via macro in staging. Use for historical\n      time-series analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Last modification timestamp for archived transaction. Date-shifted in\n      staging.  May reflect archive date rather than original modification.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: transactionid\n    description: >\n      Primary key uniquely identifying each archived transaction. May overlap\n      with IDs  in current transaction_history. Use with transactiondate for\n      unique identification.\n    type: integer\n  - name: productid\n    description: >\n      Foreign key to product being moved. Links to product master for historical\n      product  analysis. Some products may no longer be active.\n    type: integer\n  - name: referenceorderid\n    description: >\n      ID of originating order from archived period. Interpretation depends on\n      transactiontype.  Historical orders may be purged from active tables.\n    type: integer\n  - name: referenceorderlineid\n    description: >\n      Line item within the originating order. Historical reference that may no\n      longer  exist in active order tables.\n    type: integer\n  - name: quantity\n    description: >\n      Number of units moved in archived transaction. Always positive; direction\n      implied  by transactiontype. Historical quantities for trend analysis.\n    type: integer\n  - name: actualcost\n    description: >\n      Historical cost per unit at time of transaction. May differ from current\n      costs.  Use for historical margin and valuation analysis.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Product master for archived transactions. Some products may be\n      discontinued.  Use left join to handle missing products.\nclarifications:\n  - >\n    What determines when transactions move from active to archive? Age, fiscal\n    year  closure, or volume thresholds?\n  - >\n    Are transactionid values unique within archive or can they duplicate IDs\n    from  the active transaction_history table?\n  - >\n    Should archived transactions be included in current inventory calculations\n    or  are they purely for historical analysis?\n  - >\n    How far back does the archive extend and is there a retention policy for \n    purging very old transactions?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "9fc519eb-6c97-44a3-b8db-cc83dd2830e5",
    "name": "total_sales_revenue",
    "databaseName": "postgres",
    "whenToUse": "Generated model for total_sales_revenue",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.total_sales_revenue",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08156+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "total_sales_revenue",
    "ymlFile": "name: total_sales_revenue\ndescription: >\n  Calculates the total sales revenue across all orders and time periods. This\n  key financial  metric sums the line total values from all order details,\n  providing comprehensive revenue  tracking by year, quarter, and month.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: metric_totalsalesrevenue\n    description: >-\n      Total revenue calculated as SUM(line total) from all sales order details\n      aggregated by time periods\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "f36dceb3-3a25-4996-aecb-bf7684d7281f",
    "name": "special_offer",
    "databaseName": "postgres",
    "whenToUse": "A critical model for promotion strategy analysis and discount program management. Enables detailed evaluation of promotion effectiveness, supports discount strategy optimization, facilitates seasonal campaign planning, and provides insights on customer response to different offer types. Essential for marketing teams to develop targeted promotions, measure ROI on discount programs, identify optimal discount thresholds, and create effective promotional calendars that maximize revenue while protecting margins.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.special_offer",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082428+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "special_offer",
    "ymlFile": "name: special_offer\ndescription: >\n  Catalog of promotions and discounts available to customers or resellers. Each\n  row represents a distinct special offer with its discount percent and any\n  quantity thresholds, along with the active date range. Use this model to\n  understand offer definitions, filter for currently-active offers, and join to\n  product assignments and order lines via specialofferid.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: description\n    description: >\n      Human-readable offer name/label (e.g., \"Volume Discount 41 to 60\"). Useful\n      for reporting and UX display. Generally unique per offer definition.\n    type: character varying\n    searchable: true\n    options: null\n  - name: type\n    description: |\n      Offer type/category describing the promotion mechanics. Treat as an enum.\n    type: character varying\n    searchable: false\n    options:\n      - Volume Discount\n      - Seasonal Discount\n      - Excess Inventory\n      - Discontinued Product\n      - New Product\n      - No Discount\n  - name: category\n    description: >\n      Target segment for the offer. Treat as an enum. Most offers target\n      Resellers; some target Customers. A small number may be labeled \"No\n      Discount\" to indicate a placeholder or non-discount classification.\n    type: character varying\n    searchable: false\n    options:\n      - Reseller\n      - Customer\n      - No Discount\n  - name: startdate\n    description: >\n      Offer start timestamp. Use with enddate to derive whether an offer is\n      active. Typical filter: CURRENT_DATE BETWEEN DATE(startdate) AND\n      DATE(enddate).\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: enddate\n    description: >\n      Offer end timestamp. When NULL is not observed here; compare with\n      startdate to determine active windows. Boundary handling is typically\n      inclusive.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: rowguid\n    description: >\n      UUID identifier for the offer record (UUID v4). Stable technical\n      identifier; not generally used for analytics joins.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: |\n      Timestamp when the offer record was last updated.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: specialofferid\n    description: >\n      Primary key for the special offer. Use to join to special_offer_product\n      and sales_order_detail.\n    type: integer\n  - name: discountpct\n    description: >\n      Discount percentage expressed as a fraction of price (0–1). Example\n      values: 0, 0.02, 0.05, 0.10, 0.15, 0.20, 0.30, 0.35, 0.40, 0.50. Zero\n      indicates no discount.\n    type: numeric\n  - name: minqty\n    description: >\n      Minimum quantity required for the offer to apply. Zero indicates no\n      minimum.\n    type: integer\n  - name: maxqty\n    description: >\n      Maximum quantity for which the offer applies; NULL indicates no upper\n      limit.\n    type: integer\nmetrics: []\nfilters:\n  - name: active_offers\n    expr: CURRENT_DATE BETWEEN DATE(startdate) AND DATE(enddate)\n    description: Offers active on the evaluation date.\n    args: []\n  - name: discounted_offers\n    expr: discountpct > 0\n    description: Offers that apply a non-zero discount.\n    args: []\n  - name: reseller_offers\n    expr: category = 'Reseller'\n    description: Offers targeted to resellers.\n    args: []\n  - name: customer_offers\n    expr: category = 'Customer'\n    description: Offers targeted to customers.\n    args: []\nrelationships:\n  - name: special_offer_product\n    source_col: specialofferid\n    ref_col: specialofferid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Maps offer definitions to the products they apply to. One special_offer\n      can be linked to many product assignments.\n  - name: sales_order_detail\n    source_col: specialofferid\n    ref_col: specialofferid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Join to order line items that reference a special offer. Not all order\n      lines have a special offer; expect sparse matches.\nclarifications:\n  - >-\n    Are startdate and enddate interpreted in local time, and are the boundaries\n    inclusive?\n  - >-\n    Category includes a value \"No Discount\". Is this a true segment/category or\n    a placeholder?\n  - >-\n    Confirm whether discountpct is applied to unit price before taxes/fees/other\n    discounts.\n  - Is maxqty NULL consistently used to mean \"no upper limit\"?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "359fb049-8b58-4708-89e5-873ada86ecb7",
    "name": "product_inventory",
    "databaseName": "postgres",
    "whenToUse": "This model provides comprehensive visibility into product stock levels across different locations, supporting inventory management and supply chain optimization. It enables answering critical business questions about inventory distribution, stock availability, warehouse space utilization, and product placement efficiency. The model is essential for inventory forecasting, stockout prevention, warehouse layout optimization, and implementing just-in-time inventory practices. It helps identify optimal reorder points, track inventory turnover by location, and balance stock levels across the distribution network.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_inventory",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081842+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_inventory",
    "ymlFile": "name: product_inventory\ndescription: >\n  Current on-hand inventory by product and location with physical storage\n  coordinates. Includes shelf (letter code or 'N/A'), bin (numeric slot within a\n  shelf), on-hand quantity, and the last-modified timestamp for the row. Use\n  this model to analyze stock levels, storage distribution across locations, and\n  to derive inventory value when joined to product standard cost. Typical\n  patterns: many records have shelf = 'N/A' with bin = 0 for non-shelved\n  storage; locationID spans a small set of plant/storage areas; quantity ranges\n  widely and includes zeros. modifiedDate reflects the last update time for the\n  record and is date-shifted via the staging macro for consistency.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Foreign key to the product. Join to product.productid to bring product\n      attributes like name, standard cost, and product line for valuation and\n      segmentation.\n    type: integer\n    searchable: false\n  - name: locationid\n    description: >\n      Inventory location identifier. Join to location.locationid to get\n      human-readable location names and operational attributes (e.g.,\n      availability, cost rate).\n    type: smallint\n    searchable: false\n    options:\n      - '50'\n      - '6'\n      - '1'\n      - '7'\n      - '60'\n      - '5'\n      - '10'\n      - '20'\n      - '2'\n      - '40'\n      - '30'\n      - '3'\n      - '4'\n      - '45'\n  - name: shelf\n    description: >\n      Shelf code within the location. Single-letter codes or 'N/A' when the item\n      is not stored on a physical shelf. Often paired with bin to identify a\n      precise slot. Usage note: 'N/A' commonly appears with bin = 0.\n    type: character varying\n    searchable: false\n    options:\n      - N/A\n      - A\n      - B\n      - C\n      - D\n      - E\n      - F\n      - G\n      - H\n      - J\n      - K\n      - L\n      - M\n      - 'N'\n      - R\n      - S\n      - T\n      - U\n      - V\n      - W\n      - 'Y'\n  - name: bin\n    description: >\n      Numeric bin index within a shelf. Used with shelf to precisely locate\n      inventory. Common values include 0–10 with a long tail up to the low 60s;\n      0 is frequent for non-shelved storage (shelf = 'N/A'). Treat as a\n      categorical location code rather than a value to aggregate.\n    type: smallint\n    searchable: false\n  - name: rowguid\n    description: >\n      Row-level UUID identifier (v4, hyphenated). Unique per record and useful\n      for lineage and deduplication checks. Not intended for business joins.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: >\n      Last time this record was updated. Useful for recency/refresh checks and\n      identifying recently changed inventory. Staging applies a date-shift macro\n      for timestamp consistency.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: quantity\n    description: >\n      On-hand quantity at the specified product and location at the time of last\n      update. Aggregate with SUM() for totals by product, location, or other\n      groupings. Units are item units (not monetary).\n    type: integer\nmetrics: []\nfilters:\n  - name: is_shelved\n    expr: shelf <> 'N/A'\n    description: Filter to only include items assigned to a physical shelf.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to bring product attributes (name, standard cost, category) to value\n      and analyze inventory. Expect many product_inventory rows per product;\n      coverage ~100% for valid stocked items.\n  - name: location\n    source_col: locationid\n    ref_col: locationid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to resolve location names and operational attributes. One location\n      per locationid; many inventory rows roll up to a single location.\nclarifications:\n  - >-\n    Confirm that quantity reflects current on-hand stock (not allocated or\n    on-order).\n  - >-\n    Shelf code domain: are codes strictly A–Z plus 'N/A', or can additional\n    codes appear?\n  - >-\n    Bin semantics: is 0 reserved for non-shelved items and otherwise 1–n per\n    shelf?\n  - >-\n    modifiedDate: does it represent last update only, or can it be used as a\n    temporal snapshot key?\n  - >-\n    Expected join coverage: product_inventory.productid to product.productid and\n    product_inventory.locationid to location.locationid ≥ 95%?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "7fc573d3-f733-4dfc-afb2-ab5c78982ba5",
    "name": "sales_person",
    "databaseName": "postgres",
    "whenToUse": "A comprehensive model for sales team performance analysis and management. Enables detailed evaluation of individual sales representatives, supports territory management decisions, automates commission calculations, tracks progress against quota targets, and provides year-over-year performance comparisons. Essential for sales leadership to optimize team structure, incentive plans, and territory assignments.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_person",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082454+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_person",
    "ymlFile": "name: sales_person\ndescription: >\n  SalesPerson provides one row per sales employee with current assignment and\n  performance attributes. Use this model to analyze sales staff quotas, bonus\n  and commission settings, and compare salesYTD vs salesLastYear. Join to\n  sales_territory for regional context and to sales_order_header/store for\n  activity tied to a salesperson.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: rowguid\n    description: >\n      UUID for the sales person record. Useful for lineage/traceability; not\n      intended for business joins.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when this record was last updated in the source system. Helpful\n      for change tracking and freshness checks.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: businessentityid\n    description: >\n      Primary identifier for the salesperson (mirrors\n      HumanResources.Employee/Person BusinessEntityID). Use to join to\n      sales_order_header.salespersonid, store.salespersonid,\n      sales_person_quota_history, and territory history.\n    type: integer\n  - name: territoryid\n    description: >\n      Identifier of the salesperson's current sales territory. Null indicates no\n      active territory assignment. Join to sales_territory.territoryid for\n      region details.\n    type: integer\n  - name: salesquota\n    description: >\n      Target sales amount assigned to the salesperson. Often set to tiered\n      values; may be null when no quota is assigned. Monetary value in company\n      currency; confirm quota period (monthly/quarterly/annual) before\n      time-based comparisons.\n    type: numeric\n  - name: bonus\n    description: >\n      Monetary bonus amount associated with the salesperson. Zero is valid when\n      no bonus is awarded.\n    type: numeric\n  - name: commissionpct\n    description: >\n      Commission rate expressed as a fraction (e.g., 0.015 = 1.5%). Multiply by\n      sales amounts to estimate commission.\n    type: numeric\n  - name: salesytd\n    description: >\n      Year-to-date sales amount attributed to the salesperson. Used for pacing\n      vs target; resets each year.\n    type: numeric\n  - name: saleslastyear\n    description: >\n      Total sales amount attributed to the salesperson in the prior year. Use\n      for YoY comparison.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: sales_territory\n    source_col: territoryid\n    ref_col: territoryid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Current territory of the salesperson; enrich with region name and group.\n      Coverage < 100% when territoryID is null.\n  - name: sales_order_header\n    source_col: businessentityid\n    ref_col: salespersonid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Orders handled by this salesperson. Expect optional linkage (some orders\n      have no salesperson).\n  - name: store\n    source_col: businessentityid\n    ref_col: salespersonid\n    type: left\n    cardinality: one-to-many\n    description: |\n      Retail stores associated with (managed by) this salesperson.\n  - name: sales_person_quota_history\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-many\n    description: |\n      Historical quota assignments for this salesperson over time.\n  - name: sales_territory_history\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-many\n    description: |\n      Historical territory assignments for this salesperson.\nclarifications:\n  - >-\n    Is salesQuota defined as a monthly, quarterly, or annual target, and what is\n    the currency convention?\n  - >-\n    Do salesYTD and salesLastYear align to calendar or fiscal year, and do they\n    include tax/freight or only product subtotal?\n  - >-\n    Does a null territoryID explicitly mean 'unassigned'? Can a salesperson hold\n    multiple territories concurrently, or is it one current territory with\n    history tracked separately?\n  - >-\n    What is the expected join coverage between sales_order_header.salespersonid\n    and sales_person.businessentityid (e.g., % of orders with a salesperson)?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "1575dab0-1372-4d83-8e90-3a618dc772ea",
    "name": "transaction_history",
    "databaseName": "transaction_history",
    "whenToUse": "Transaction history model that supports inventory movement tracking, historical cost analysis, and audit trail requirements. This model provides a comprehensive view of product transactions over time, enabling detailed tracking of inventory movements, analysis of historical costs for financial reporting and valuation, and maintaining a robust audit trail for compliance with regulatory requirements and internal control policies.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .transaction_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083029+00",
    "updatedAt": "2025-05-02 17:10:46.083029+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: transaction_history\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Transaction history model that supports inventory movement tracking, historical cost analysis, and audit trail requirements. This model provides a comprehensive view of product transactions over time, enabling detailed tracking of inventory movements, analysis of historical costs for financial reporting and valuation, and maintaining a robust audit trail for compliance with regulatory requirements and internal control policies.\\n  model: null\\n  entities:\\n  - name: product\\n    ref_: null\\n    expr: productid\\n    type: foreign\\n    description: Reference to the product\\n    project_path: null\\n  dimensions:\\n  - name: transactiondate\\n    expr: transactiondate\\n    type: timestamp without time zone\\n    description: The date and time when the transaction occurred\\n    searchable: false\\n  - name: transactiontype\\n    expr: transactiontype\\n    type: character\\n    description: The category or type of transaction (e.g., sale, refund)\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: The date and time when the record was last modified\\n    searchable: false\\n  measures:\\n  - name: transactionid\\n    expr: transactionid\\n    agg: sum\\n    description: The unique identifier for each transaction\\n    type: integer\\n  - name: productid\\n    expr: productid\\n    agg: sum\\n    description: The identifier for the product involved in the transaction\\n    type: integer\\n  - name: referenceorderid\\n    expr: referenceorderid\\n    agg: sum\\n    description: The identifier for the associated order\\n    type: integer\\n  - name: referenceorderlineid\\n    expr: referenceorderlineid\\n    agg: sum\\n    description: The identifier for the specific line item in the order\\n    type: integer\\n  - name: quantity\\n    expr: quantity\\n    agg: sum\\n    description: The total quantity of items involved in the transaction\\n    type: integer\\n  - name: actualcost\\n    expr: actualcost\\n    agg: sum\\n    description: The actual cost incurred in the transaction\\n    type: numeric\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "6ad33d35-8ae2-4863-b8b6-56366fb0c835",
    "name": "product_review",
    "databaseName": "product_review",
    "whenToUse": "Generated model for product_review",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .product_review",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081864+00",
    "updatedAt": "2025-05-02 17:10:46.081864+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: product_review\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Generated model for product_review\\n  model: null\\n  entities:\\n  - name: product\\n    ref_: null\\n    expr: productid\\n    type: foreign\\n    description: Reference to the product being reviewed\\n    project_path: null\\n  dimensions:\\n  - name: reviewername\\n    expr: reviewername\\n    type: character varying\\n    description: Name of the reviewer.\\n    searchable: true\\n  - name: reviewdate\\n    expr: reviewdate\\n    type: timestamp without time zone\\n    description: Date when the review was submitted.\\n    searchable: false\\n  - name: emailaddress\\n    expr: emailaddress\\n    type: character varying\\n    description: Email address of the reviewer.\\n    searchable: true\\n  - name: comments\\n    expr: comments\\n    type: character varying\\n    description: Text content of the review.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Date of the last update to the review.\\n    searchable: false\\n  measures:\\n  - name: productreviewid\\n    expr: productreviewid\\n    agg: sum\\n    description: Unique identifier for the product review.\\n    type: integer\\n  - name: productid\\n    expr: productid\\n    agg: sum\\n    description: Unique identifier for the product.\\n    type: integer\\n  - name: rating\\n    expr: rating\\n    agg: sum\\n    description: Numerical rating assigned in the review.\\n    type: integer\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "25023926-f401-46f2-b212-f00e0ee22742",
    "name": "work_order",
    "databaseName": "work_order",
    "whenToUse": "Core manufacturing operations model that enables production planning analysis, capacity utilization tracking, and manufacturing performance monitoring. Supports production scheduling, material requirements planning (MRP), bottleneck identification, and quality control metrics for production workflow optimization.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .work_order",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082857+00",
    "updatedAt": "2025-05-02 17:10:46.082857+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: work_order\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Core manufacturing operations model that enables production planning analysis, capacity utilization tracking, and manufacturing performance monitoring. Supports production scheduling, material requirements planning (MRP), bottleneck identification, and quality control metrics for production workflow optimization.\\n  model: null\\n  entities:\\n  - name: product\\n    ref_: null\\n    expr: productid\\n    type: foreign\\n    description: Reference to the product being manufactured\\n    project_path: null\\n  - name: scrap_reason\\n    ref_: null\\n    expr: scrapreasonid\\n    type: foreign\\n    description: Reference to the scrap reason\\n    project_path: null\\n  - name: work_order_routing\\n    ref_: null\\n    expr: workorderid\\n    type: foreign\\n    description: Reference to the work order routing\\n    project_path: null\\n  dimensions:\\n  - name: startdate\\n    expr: startdate\\n    type: timestamp without time zone\\n    description: The start date of the work order.\\n    searchable: false\\n  - name: enddate\\n    expr: enddate\\n    type: timestamp without time zone\\n    description: The end date of the work order.\\n    searchable: false\\n  - name: duedate\\n    expr: duedate\\n    type: timestamp without time zone\\n    description: The due date for the work order completion.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: The last modified date for the work order.\\n    searchable: false\\n  measures:\\n  - name: workorderid\\n    expr: workorderid\\n    agg: sum\\n    description: Unique identifier for the work order.\\n    type: integer\\n  - name: productid\\n    expr: productid\\n    agg: sum\\n    description: Identifier for the product associated with the work order.\\n    type: integer\\n  - name: orderqty\\n    expr: orderqty\\n    agg: sum\\n    description: Quantity ordered in the work order.\\n    type: integer\\n  - name: scrappedqty\\n    expr: scrappedqty\\n    agg: sum\\n    description: Quantity scrapped in the work order.\\n    type: smallint\\n  - name: scrapreasonid\\n    expr: scrapreasonid\\n    agg: sum\\n    description: Identifier for the reason the work order was scrapped.\\n    type: smallint\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "c8499b97-f725-443a-8aa6-45c7e924a69c",
    "name": "credit_card",
    "databaseName": "credit_card",
    "whenToUse": "Credit card model that supports payment method analysis, financial transaction security, and customer payment preferences. This model enables analysis of payment method distribution across customer segments, ensures secure handling of financial transaction data through masked card numbers, and provides insights into customer payment preferences to optimize checkout experiences and payment processing strategies.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .credit_card",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082393+00",
    "updatedAt": "2025-05-02 17:10:46.082393+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: credit_card\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Credit card model that supports payment method analysis, financial transaction security, and customer payment preferences. This model enables analysis of payment method distribution across customer segments, ensures secure handling of financial transaction data through masked card numbers, and provides insights into customer payment preferences to optimize checkout experiences and payment processing strategies.\\n  model: null\\n  entities:\\n  - name: person_credit_card\\n    ref_: null\\n    expr: creditcardid\\n    type: foreign\\n    description: Reference to the person credit card junction table\\n    project_path: null\\n  - name: sales_order_header\\n    ref_: null\\n    expr: creditcardid\\n    type: foreign\\n    description: Reference to sales orders using this credit card\\n    project_path: null\\n  dimensions:\\n  - name: cardtype\\n    expr: cardtype\\n    type: character varying\\n    description: Credit card type, such as Visa or MasterCard\\n    searchable: true\\n  - name: cardnumber\\n    expr: cardnumber\\n    type: character varying\\n    description: Masked representation of the credit card number\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp indicating when the record was last updated\\n    searchable: false\\n  measures:\\n  - name: creditcardid\\n    expr: creditcardid\\n    agg: sum\\n    description: Unique identifier for the credit card\\n    type: integer\\n  - name: expmonth\\n    expr: expmonth\\n    agg: sum\\n    description: Expiration month for the credit card\\n    type: smallint\\n  - name: expyear\\n    expr: expyear\\n    agg: sum\\n    description: Expiration year for the credit card\\n    type: smallint\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "ff2afb24-9cf2-4737-a230-6696e8fc35eb",
    "name": "store",
    "databaseName": "store",
    "whenToUse": "A foundational model for retail network analysis and location-based performance evaluation. Supports comprehensive store performance comparison, enables retail location optimization, facilitates network expansion planning, and provides demographic insights for targeted merchandising. Essential for retail management to identify high-performing store attributes, optimize staffing levels, plan strategic expansions, and develop location-specific strategies to maximize retail effectiveness across the store network.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .store",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082477+00",
    "updatedAt": "2025-05-02 17:10:46.082477+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: store\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: A foundational model for retail network analysis and location-based performance evaluation. Supports comprehensive store performance comparison, enables retail location optimization, facilitates network expansion planning, and provides demographic insights for targeted merchandising. Essential for retail management to identify high-performing store attributes, optimize staffing levels, plan strategic expansions, and develop location-specific strategies to maximize retail effectiveness across the store network.\\n  model: null\\n  entities:\\n  - name: business_entity\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to the business entity\\n    project_path: null\\n  - name: sales_person\\n    ref_: null\\n    expr: salespersonid\\n    type: foreign\\n    description: Reference to the sales person assigned to this store\\n    project_path: null\\n  - name: customer\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to customers associated with this store\\n    project_path: null\\n  dimensions:\\n  - name: name\\n    expr: name\\n    type: character varying\\n    description: The name of the store.\\n    searchable: true\\n  - name: demographics\\n    expr: demographics\\n    type: xml\\n    description: XML representation of store demographics.\\n    searchable: false\\n  - name: rowguid\\n    expr: rowguid\\n    type: uuid\\n    description: Unique identifier for the store.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp indicating the last modification date of the store record.\\n    searchable: false\\n  measures:\\n  - name: businessentityid\\n    expr: businessentityid\\n    agg: sum\\n    description: Aggregate sum of business entity identifiers associated with the store.\\n    type: integer\\n  - name: salespersonid\\n    expr: salespersonid\\n    agg: sum\\n    description: Aggregate sum of salesperson identifiers associated with the store.\\n    type: integer\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "559dea18-7ef1-4953-a410-be6897694f49",
    "name": "job_candidate",
    "databaseName": "job_candidate",
    "whenToUse": "Comprehensive model for tracking and analyzing recruitment activities. Supports recruitment pipeline analysis, hiring efficiency metrics, and talent acquisition monitoring. Valuable for identifying top candidate sources, tracking application-to-hire conversion rates, forecasting hiring needs, and evaluating recruitment process effectiveness. Essential for HR teams managing applicant qualification assessment and recruitment strategy optimization.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .job_candidate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082825+00",
    "updatedAt": "2025-05-02 17:10:46.082825+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: job_candidate\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Comprehensive model for tracking and analyzing recruitment activities. Supports recruitment pipeline analysis, hiring efficiency metrics, and talent acquisition monitoring. Valuable for identifying top candidate sources, tracking application-to-hire conversion rates, forecasting hiring needs, and evaluating recruitment process effectiveness. Essential for HR teams managing applicant qualification assessment and recruitment strategy optimization.\\n  model: null\\n  entities:\\n  - name: business_entity\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to the business entity or employee\\n    project_path: null\\n  dimensions:\\n  - name: resume\\n    expr: resume\\n    type: xml\\n    description: XML formatted resume data extracted from candidate submissions.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp indicating the last modification of the candidate record.\\n    searchable: false\\n  measures:\\n  - name: jobcandidateid\\n    expr: jobcandidateid\\n    agg: sum\\n    description: Unique identifier for each job candidate, aggregated for summary reporting.\\n    type: integer\\n  - name: businessentityid\\n    expr: businessentityid\\n    agg: sum\\n    description: Identifier for the associated business entity, used in aggregation queries.\\n    type: integer\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "050c2888-a8ed-4182-a287-a7bb8035497c",
    "name": "document",
    "databaseName": "document",
    "whenToUse": "Enterprise document management model supporting technical documentation tracking, product specification management, and organizational knowledge management. Facilitates document versioning analysis, content lifecycle tracking, and cross-reference capabilities between products and their documentation. Essential for regulatory compliance, technical support, and content governance initiatives.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .document",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083081+00",
    "updatedAt": "2025-05-02 17:10:46.083081+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: document\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Enterprise document management model supporting technical documentation tracking, product specification management, and organizational knowledge management. Facilitates document versioning analysis, content lifecycle tracking, and cross-reference capabilities between products and their documentation. Essential for regulatory compliance, technical support, and content governance initiatives.\\n  model: null\\n  entities:\\n  - name: product_document\\n    ref_: null\\n    expr: documentnode\\n    type: foreign\\n    description: Reference to products linked to this document\\n    project_path: null\\n  dimensions:\\n  - name: documentnode\\n    expr: documentnode\\n    type: character varying\\n    description: Identifier of the document node in the system\\n    searchable: false\\n  - name: title\\n    expr: title\\n    type: character varying\\n    description: Title of the document\\n    searchable: true\\n  - name: filename\\n    expr: filename\\n    type: character varying\\n    description: Name of the file\\n    searchable: true\\n  - name: fileextension\\n    expr: fileextension\\n    type: character varying\\n    description: File extension of the document file\\n    searchable: true\\n  - name: revision\\n    expr: revision\\n    type: character\\n    description: Revision number or letter of the document\\n    searchable: true\\n  - name: documentsummary\\n    expr: documentsummary\\n    type: text\\n    description: Short summary or abstract of the document\\n    searchable: false\\n  - name: document\\n    expr: document\\n    type: bytea\\n    description: Binary content of the document\\n    searchable: false\\n  - name: rowguid\\n    expr: rowguid\\n    type: uuid\\n    description: Row GUID for unique identification\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp when the document was last modified\\n    searchable: false\\n  - name: status\\n    expr: status\\n    type: smallint\\n    description: Status code for the document\\n    searchable: true\\n  measures:\\n  - name: changenumber\\n    expr: changenumber\\n    agg: sum\\n    description: Total number of changes to the document\\n    type: integer\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "c3d631ee-6868-45d9-86c3-3f9759059c9f",
    "name": "email_address",
    "databaseName": "email_address",
    "whenToUse": "Customer and stakeholder contact information model supporting communication strategy development, customer reach analysis, and digital engagement tracking. Enables email campaign segmentation, customer contact preference analysis, and communication effectiveness measurement. Essential for CRM integration and maintaining unified customer contact records.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .email_address",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082663+00",
    "updatedAt": "2025-05-02 17:10:46.082663+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: email_address\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Customer and stakeholder contact information model supporting communication strategy development, customer reach analysis, and digital engagement tracking. Enables email campaign segmentation, customer contact preference analysis, and communication effectiveness measurement. Essential for CRM integration and maintaining unified customer contact records.\\n  model: null\\n  entities:\\n  - name: person\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to the person\\n    project_path: null\\n  dimensions:\\n  - name: emailaddress\\n    expr: emailaddress\\n    type: character varying\\n    description: The email address of the user or contact.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: The date and time when the record was last modified.\\n    searchable: false\\n  measures:\\n  - name: businessentityid\\n    expr: businessentityid\\n    agg: sum\\n    description: Identifier for the associated business entity.\\n    type: integer\\n  - name: emailaddressid\\n    expr: emailaddressid\\n    agg: sum\\n    description: Unique identifier for the email address record.\\n    type: integer\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "f132d68d-4ce7-442b-9d49-61e655b32698",
    "name": "shopping_cart_item",
    "databaseName": "postgres",
    "whenToUse": "A vital model for analyzing online shopping behavior and e-commerce performance. Enables detailed understanding of cart abandonment patterns, supports conversion rate optimization efforts, facilitates product affinity analysis, and provides insights on customer purchase intent. Essential for e-commerce teams to identify conversion bottlenecks, optimize product recommendations, improve checkout flows, and develop targeted strategies to increase basket size and reduce cart abandonment.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.shopping_cart_item",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08241+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "shopping_cart_item",
    "ymlFile": "name: shopping_cart_item\ndescription: >\n  Items that shoppers add to their online cart. One row per cart line item\n  (product + quantity) at the time it was added/last updated. Useful for\n  analyzing pre-purchase behavior such as add-to-cart volume, cart composition,\n  and abandonment patterns. Contains the cart/session identifier, product\n  reference, quantity, and created/modified timestamps. Note: timestamps in this\n  environment may be uniformly shifted to a fixed reference date to preserve\n  relative intervals while keeping analyses recency-aligned.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: shoppingcartid\n    description: >\n      Identifier for the shopping cart/session. High-cardinality string that\n      represents a browser/session token rather than a customer ID. Values may\n      appear numeric but are stored as text. Use for distinct-cart counts and\n      cart-level grouping when analyzing abandonment or composition.\n    type: character varying\n    searchable: false\n    options: null\n  - name: datecreated\n    description: >\n      Timestamp when the item was added to the cart. Use for recency analyses,\n      cohorting, and building add-to-cart time series. In this environment,\n      timestamps may be uniformly shifted to a fixed reference date; relative\n      intervals are preserved.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when the cart item was last updated (for example, after a\n      quantity change). Often equals datecreated when no edits occurred.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: shoppingcartitemid\n    description: >\n      Unique identifier for the cart line item. Use COUNT(DISTINCT\n      shoppingcartitemid) for row-level counts; not intended as a numeric\n      measure for summation.\n    type: integer\n  - name: quantity\n    description: >\n      Number of units of the product in this cart line. Typical aggregation is\n      SUM(quantity). Values should be positive integers.\n    type: integer\n  - name: productid\n    description: >\n      Foreign key referencing product.productid. Use to join for product\n      attributes such as name, category, and price.\n    type: integer\nmetrics:\n  - name: cart_item_events\n    expr: COUNT(*)\n    description: Count of cart line events (one per row).\n    args: []\n  - name: total_cart_units\n    expr: SUM(quantity)\n    description: Total units added across selected carts/items.\n    args: []\n  - name: unique_carts\n    expr: COUNT(DISTINCT shoppingcartid)\n    description: Distinct shopping carts represented in the selection.\n    args: []\n  - name: avg_units_per_cart\n    expr: SUM(quantity) * 1.0 / NULLIF(COUNT(DISTINCT shoppingcartid), 0)\n    description: Average units per cart in the selection.\n    args: []\nfilters:\n  - name: recent_30d\n    expr: datecreated >= CURRENT_DATE - INTERVAL '30 days'\n    description: Keep items added in the last 30 days.\n    args: []\n  - name: positive_quantity\n    expr: quantity > 0\n    description: Exclude any zero or negative quantities.\n    args: []\n  - name: updated_after_created\n    expr: modifieddate > datecreated\n    description: >-\n      Items where the record was updated after creation (indicates user\n      adjustment).\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Enrich cart items with product attributes (name, category, list price).\n      Many cart items map to one product.\nclarifications:\n  - >-\n    Confirm whether datecreated/modifieddate are timezone-normalized to UTC and\n    whether date shifting is applied in production.\n  - >-\n    Is shoppingcartid stable across sessions/devices or regenerated per session?\n    Does it map to a customer anywhere?\n  - >-\n    Are deletions or item removals captured (e.g., via separate table), or are\n    only current/last-known items retained?\n  - >-\n    Guarantee that shoppingcartitemid is the primary key and unique across the\n    table?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "25998901-5d33-495e-a9cd-9f5cd7493e58",
    "name": "business_entity_address",
    "databaseName": "business_entity_address",
    "whenToUse": "This relationship model connects business entities to their physical locations, enabling multi-location business analysis and geographic distribution insights. It helps answer critical business questions about regional market penetration, location-based performance differences, address type distribution, and geographic expansion opportunities. The model is particularly valuable for territory management, logistics optimization, customer demographic analysis, and regional sales performance tracking.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .business_entity_address",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08292+00",
    "updatedAt": "2025-05-02 17:10:46.08292+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: business_entity_address\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: This relationship model connects business entities to their physical locations, enabling multi-location business analysis and geographic distribution insights. It helps answer critical business questions about regional market penetration, location-based performance differences, address type distribution, and geographic expansion opportunities. The model is particularly valuable for territory management, logistics optimization, customer demographic analysis, and regional sales performance tracking.\\n  model: null\\n  entities:\\n  - name: business_entity\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to the business entity\\n    project_path: null\\n  - name: address\\n    ref_: null\\n    expr: addressid\\n    type: foreign\\n    description: Reference to the address\\n    project_path: null\\n  - name: address_type\\n    ref_: null\\n    expr: addresstypeid\\n    type: foreign\\n    description: Reference to the address type\\n    project_path: null\\n  dimensions:\\n  - name: rowguid\\n    expr: rowguid\\n    type: uuid\\n    description: Unique identifier for the row.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp indicating last modification date of the record.\\n    searchable: false\\n  measures:\\n  - name: businessentityid\\n    expr: businessentityid\\n    agg: sum\\n    description: Aggregated sum of business entity identifiers.\\n    type: integer\\n  - name: addressid\\n    expr: addressid\\n    agg: sum\\n    description: Aggregated sum of address identifiers.\\n    type: integer\\n  - name: addresstypeid\\n    expr: addresstypeid\\n    agg: sum\\n    description: Aggregated sum of address type identifiers.\\n    type: integer\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "bed482cc-89a2-4750-a4c8-aea315059689",
    "name": "business_entity",
    "databaseName": "postgres",
    "whenToUse": "Generated model for business_entity",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.business_entity",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082768+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "business_entity",
    "ymlFile": "name: business_entity\ndescription: >-\n  Central registry of all entities that interact with Adventure Works (people,\n  employees, vendors, and stores). Use this as a lightweight hub to join subtype\n  and relationship tables via businessEntityID. Contains only identifiers and\n  audit-style fields; no business attributes live here. Note modifiedDate is\n  shifted with a demo macro to align recency and should be used for relative\n  time windows, not exact historical timestamps.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: rowguid\n    description: >-\n      System-generated GUID for the business entity; unique and stable across\n      related subtype tables. Useful for cross-system reconciliation; not\n      intended for reporting. Pattern hyphenated UUID v4; no nulls observed.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >-\n      Last update timestamp for the business entity record. This value is\n      adjusted using the date_shifting.shift_date macro so that the column’s max\n      date aligns with an anchor date (e.g., 2025-03-28). Use for relative\n      recency filters and freshness checks; do not treat as the exact original\n      operational timestamp.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: businessentityid\n    description: >-\n      Surrogate primary key for the business entity. Primary join key to subtype\n      and relationship models (e.g., person, employee, store, vendor). Non-null\n      and unique.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: person\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-one\n    description: >-\n      Person subtype for entities that are individuals. Join on\n      businessEntityID; not all business entities are persons (coverage < 100%).\n  - name: employee\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-one\n    description: >-\n      Employee subtype for business entities who are employees. Join on\n      businessEntityID; only a subset of entities (coverage < 100%).\n  - name: store\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-one\n    description: >-\n      Store subtype for retail stores associated with Adventure Works. Join on\n      businessEntityID; only applicable to store entities (coverage < 100%).\n  - name: vendor\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-one\n    description: >-\n      Vendor subtype for suppliers. Join on businessEntityID; only applicable to\n      vendor entities (coverage < 100%).\n  - name: business_entity_address\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Mapping of addresses to entities. A business entity can have zero or many\n      addresses.\n  - name: business_entity_contact\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Mapping of contacts to entities. A business entity can have zero or many\n      contacts.\n  - name: email_address\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Email addresses for person entities. A business entity (person) can have\n      multiple emails.\n  - name: person_phone\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Phone numbers for person entities. A business entity (person) can have\n      multiple phone numbers/types.\n  - name: product_vendor\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Vendor-to-product assignments. A vendor entity can be linked to many\n      products.\n  - name: sales_person\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-one\n    description: >-\n      Sales person subtype for employee entities who sell. Only applicable to\n      entities that are sales people.\n  - name: sales_person_quota_history\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Historical quota records for sales people. One entity may have many quota\n      periods.\n  - name: sales_territory_history\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Historical territory assignments for sales people. One entity may have\n      many assignments over time.\n  - name: person_credit_card\n    source_col: businessEntityID\n    ref_col: businessEntityID\n    type: left\n    cardinality: one-to-many\n    description: >-\n      Mapping of credit cards to person entities. One entity may hold multiple\n      cards.\nclarifications:\n  - >-\n    Confirm approximate coverage of subtypes (person/employee/vendor/store)\n    relative to all business entities to guide cardinality expectations.\n  - >-\n    Confirm consumer guidance for modifiedDate given date shifting (acceptable\n    for recency/freshness only vs. audit/SLAs?).\n  - >-\n    Should rowguid be used for any cross-system joins, or is businessEntityID\n    sufficient within the warehouse?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "27d21b4d-23ff-439b-94cb-e5d903e2a34a",
    "name": "vendor",
    "databaseName": "vendor",
    "whenToUse": "Comprehensive supplier management model that enables vendor performance evaluation, procurement optimization, and supply chain risk analysis. Supports strategic sourcing decisions, vendor consolidation opportunities, and quality management while providing visibility into supplier relationships and spend analytics.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .vendor",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082536+00",
    "updatedAt": "2025-05-02 17:10:46.082536+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: vendor\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: Comprehensive supplier management model that enables vendor performance evaluation, procurement optimization, and supply chain risk analysis. Supports strategic sourcing decisions, vendor consolidation opportunities, and quality management while providing visibility into supplier relationships and spend analytics.\\n  model: null\\n  entities:\\n  - name: business_entity\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to the business entity\\n    project_path: null\\n  - name: purchase_order_header\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to purchase orders from this vendor\\n    project_path: null\\n  - name: product_vendor\\n    ref_: null\\n    expr: businessentityid\\n    type: foreign\\n    description: Reference to products provided by this vendor\\n    project_path: null\\n  dimensions:\\n  - name: accountnumber\\n    expr: accountnumber\\n    type: character varying\\n    description: Vendor account identification number.\\n    searchable: true\\n  - name: name\\n    expr: name\\n    type: character varying\\n    description: The vendor's name.\\n    searchable: true\\n  - name: preferredvendorstatus\\n    expr: preferredvendorstatus\\n    type: boolean\\n    description: Indicates if the vendor is a preferred choice.\\n    searchable: true\\n  - name: activeflag\\n    expr: activeflag\\n    type: boolean\\n    description: Specifies whether the vendor is currently active.\\n    searchable: true\\n  - name: purchasingwebserviceurl\\n    expr: purchasingwebserviceurl\\n    type: character varying\\n    description: URL for accessing the vendor's purchasing web service.\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Timestamp when the vendor record was last updated.\\n    searchable: false\\n  measures:\\n  - name: businessentityid\\n    expr: businessentityid\\n    agg: sum\\n    description: Unique identifier for the vendor's business entity.\\n    type: integer\\n  - name: creditrating\\n    expr: creditrating\\n    agg: sum\\n    description: Numeric representation of the vendor's credit rating.\\n    type: smallint\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "7c501b74-f2eb-4a93-bc6f-8751508ec84e",
    "name": "sales_order_detail",
    "databaseName": "sales_order_detail",
    "whenToUse": "This model captures detailed order line item data, enabling granular analysis of product sales performance, revenue breakdown by product and order, and order fulfillment tracking. It supports critical business questions such as which products are top sellers, how special offers impact sales volume, what the average order value is per product category, and how unit pricing affects order quantities. This is essential for sales performance monitoring, inventory planning, and product profitability analysis.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "select * from .sales_order_detail",
    "schema": "ont_ont",
    "enabled": true,
    "imported": false,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082177+00",
    "updatedAt": "2025-05-02 17:10:46.082177+00",
    "deletedAt": null,
    "model": null,
    "ymlFile": "version: 0\\nmodels:\\n- name: sales_order_detail\\n  data_source_name: null\\n  schema: ont_ont\\n  database: postgres\\n  description: This model captures detailed order line item data, enabling granular analysis of product sales performance, revenue breakdown by product and order, and order fulfillment tracking. It supports critical business questions such as which products are top sellers, how special offers impact sales volume, what the average order value is per product category, and how unit pricing affects order quantities. This is essential for sales performance monitoring, inventory planning, and product profitability analysis.\\n  model: null\\n  entities:\\n  - name: sales_order_header\\n    ref_: null\\n    expr: salesorderid\\n    type: foreign\\n    description: Reference to the sales order header\\n    project_path: null\\n  - name: product\\n    ref_: null\\n    expr: productid\\n    type: foreign\\n    description: Reference to the product\\n    project_path: null\\n  - name: special_offer\\n    ref_: null\\n    expr: specialofferid\\n    type: foreign\\n    description: Reference to the special offer\\n    project_path: null\\n  dimensions:\\n  - name: carriertrackingnumber\\n    expr: carriertrackingnumber\\n    type: character varying\\n    description: Tracking number provided by the carrier.\\n    searchable: true\\n  - name: rowguid\\n    expr: rowguid\\n    type: uuid\\n    description: Unique row identifier (GUID).\\n    searchable: false\\n  - name: modifieddate\\n    expr: modifieddate\\n    type: timestamp without time zone\\n    description: Date of last modification.\\n    searchable: false\\n  measures:\\n  - name: salesorderid\\n    expr: salesorderid\\n    agg: sum\\n    description: Identifier for the sales order.\\n    type: integer\\n  - name: salesorderdetailid\\n    expr: salesorderdetailid\\n    agg: sum\\n    description: Identifier for the sales order detail line.\\n    type: integer\\n  - name: orderqty\\n    expr: orderqty\\n    agg: sum\\n    description: Quantity of items ordered.\\n    type: smallint\\n  - name: productid\\n    expr: productid\\n    agg: sum\\n    description: Identifier for the product.\\n    type: integer\\n  - name: specialofferid\\n    expr: specialofferid\\n    agg: sum\\n    description: Identifier for any special offer applied.\\n    type: integer\\n  - name: unitprice\\n    expr: unitprice\\n    agg: sum\\n    description: Unit price of the product.\\n    type: numeric\\n  - name: unitpricediscount\\n    expr: unitpricediscount\\n    agg: sum\\n    description: Discount applied on the unit price.\\n    type: numeric\\n  - name: linetotal\\n    expr: linetotal\\n    agg: sum\\n    description: Total price for the order line.\\n    type: numeric\\n  metrics: []\\n  segments: []\\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "2733e4db-956b-4e46-8591-030cb741549f",
    "name": "product_description",
    "databaseName": "postgres",
    "whenToUse": "Comprehensive product information model that supports detailed product documentation, marketing content creation, and customer information needs. Essential for product catalog management, search engine optimization, and consistent product messaging across sales channels. Enables content personalization and localization strategies.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_description",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081947+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_description",
    "ymlFile": "name: product_description\ndescription: >\n  Localized product description texts used across the catalog. Each row is a\n  standalone description string that can be linked to a specific Product Model\n  and Culture via the product_model_product_description_culture junction. Use\n  this model when you need the human‑readable, marketing/feature copy for a\n  product model in a given language. Notes: content is multilingual (e.g.,\n  English, French, Hebrew, Arabic, Chinese, Thai), and language context comes\n  from the junction (this table does not carry a culture field). modifieddate\n  reflects ETL update time rather than editorial change time.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: description\n    description: >\n      Free‑text product description copy. Multilingual content observed\n      (EN/FR/HE/AR/CH/TH). Usage notes: choose the appropriate language by\n      joining through product_model_product_description_culture and filtering on\n      culture.cultureid as needed. Typical content is sentence/paragraph style\n      marketing/spec text.\n    type: character varying\n    searchable: true\n  - name: rowguid\n    description: >\n      Globally unique row identifier (UUID v4). Useful for auditing or lineage\n      checks; not intended for analytics or business joins.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: >\n      Timestamp of the last warehouse update for this row. Often reflects batch\n      loads rather than editorial last‑modified. Use for change detection or\n      partitioning, not as a business timeline.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: productdescriptionid\n    description: >\n      Surrogate key for the product description. Use primarily for joining and\n      counting distinct descriptions (prefer COUNT DISTINCT over SUM in\n      analyses). Also serves as the join key to\n      product_model_product_description_culture.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_model_product_description_culture\n    source_col: productdescriptionid\n    ref_col: productdescriptionid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Links descriptions to product models in specific cultures/languages. Join\n      on productdescriptionid; expect one description to map to many\n      model/culture rows.\nclarifications:\n  - >-\n    Should we default to a specific culture (for example, 'en') for global\n    reporting? If yes, we can add a reusable filter.\n  - >-\n    Confirm that modifieddate reflects ETL load time and not editorial\n    last-changed time.\n  - >-\n    What is the coverage by culture in product_model_product_description_culture\n    for each product model? Any cultures with sparse mappings to call out?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "5b2d07b2-0968-486f-854f-a20271bdec80",
    "name": "product_document",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_document",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_document",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081793+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_document",
    "ymlFile": "name: product_document\ndescription: >\n  Association table linking products to their related documents. Use this model\n  to find which documents (manuals, specifications, drawings) are associated\n  with a given product and to retrieve documents for product detail pages or\n  operational workflows. Join to the product model for product attributes and to\n  the document model for document metadata (title, filename, status). Each row\n  represents a single product-to-document link; products commonly have multiple\n  documents.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: documentnode\n    description: >\n      Identifier of the document in the document catalog; joins to\n      document.documentnode. Values appear as path-like strings (for example\n      \"/2/1/\", \"/3/4/\") that encode document hierarchy. Use to look up document\n      attributes via the document model.\n    type: character varying\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when this product-to-document link was last modified in the\n      source system. Useful as an audit field to understand when associations\n      changed; not a guarantee of document content update time.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: productid\n    description: >\n      Product identifier for the associated product; foreign key to\n      product.productid. Typically used for joining rather than aggregation (use\n      counts/distinct counts when needed).\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each association to its product for product attributes and\n      categorization. Join on productid; many associations map to one product.\n  - name: document\n    source_col: documentnode\n    ref_col: documentnode\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each association to its document to access document metadata (title,\n      filename, status). Join on documentnode; many associations can reference\n      the same document.\nclarifications:\n  - >-\n    Does modifieddate reflect the last change to the link record only, or also\n    changes to the underlying document/product?\n  - >-\n    Confirm that (productid, documentnode) pairs are unique in this model (as in\n    the source schema).\n  - >-\n    Confirm whether documentnode is a hierarchy path representation and whether\n    its format is stable across environments.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "5b328764-f621-409f-815b-77da617a2df8",
    "name": "product_gross_profit",
    "databaseName": "postgres",
    "whenToUse": "Metric model that calculates the gross profit (revenue minus cost) for each product",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_gross_profit",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081365+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_gross_profit",
    "ymlFile": "name: product_gross_profit\ndescription: >\n  Calculates gross profit by product and calendar time. Revenue is derived from\n  sales order details as unit_price × quantity × (1 − discount), and cost uses\n  the product's standard_cost × quantity. The model is aggregated at product ×\n  year × quarter and is useful for profitability analysis, category rollups, and\n  time trend comparisons. Note: negative values indicate unprofitable periods;\n  cost uses standard_cost and does not reflect historical cost changes unless\n  modeled upstream.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Product identifier from the product dimension. Use to join to the\n      `product` model. Not unique in this model (repeats across year and\n      quarter).\n    type: integer\n    searchable: false\n  - name: product_name\n    description: >\n      Display name of the product from the product dimension. Useful for\n      searching and presentation; not unique. Consider using `productid` for\n      joins and strict grouping.\n    type: character varying\n    searchable: true\n  - name: year\n    description: >\n      Calendar year extracted from the sales order date. Use for time slicing\n      and to group with `quarter`.\n    type: numeric\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: >\n      Calendar quarter (1=Q1, 2=Q2, 3=Q3, 4=Q4) extracted from the sales order\n      date.\n    type: numeric\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_productgrossprofit\n    description: >\n      Gross profit by product and period. Calculated as: SUM(unit_price ×\n      order_qty × (1 − unit_price_discount)) − SUM(standard_cost × order_qty).\n      Units are monetary; can be negative for unprofitable periods. Revenue\n      excludes tax/freight.\n    type: numeric\nmetrics:\n  - name: total_gross_profit\n    expr: SUM(metric_productgrossprofit)\n    description: |\n      Total gross profit across the selected time frame and filters.\n    args: []\nfilters:\n  - name: profitable_only\n    expr: metric_productgrossprofit > 0\n    description: Keep only rows where gross profit is positive.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Relates each row to the corresponding product. Join on `productid`.\n      Cardinality is many-to-one from this model to `product`.\nclarifications:\n  - >-\n    Should historical cost from `product_cost_history` be used (by order date)\n    instead of `product.standardCost`?\n  - >-\n    Confirm whether revenue should exclude tax and freight for profitability\n    reporting.\n  - >-\n    Are returns/cancellations modeled and should they be netted out of\n    revenue/cost?\n  - >-\n    Confirm currency assumptions and whether FX conversion is needed if\n    multi-currency applies.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "75eb7aa8-2a26-4917-b0ec-9b6843e83aed",
    "name": "purchase_order_header",
    "databaseName": "postgres",
    "whenToUse": "Purchase order header model that enables procurement analysis, vendor performance evaluation, and spend management. This model provides a centralized view of all purchase orders, supporting in-depth analysis of procurement patterns, assessment of vendor performance metrics such as on-time delivery and pricing consistency, and comprehensive spend management across the organization to identify cost-saving opportunities and optimize purchasing strategies.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.purchase_order_header",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082581+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "purchase_order_header",
    "ymlFile": "name: purchase_order_header\ndescription: >\n  Header-level records for each purchase order issued by Adventure Works. Use\n  this model to analyze procurement activity at the order level: buyer\n  (employee), vendor, ship method, key dates (order/ship/last modified), and\n  monetary amounts (subtotal, tax, freight). Typical use cases include spend\n  analysis, vendor performance, lead-time tracking (order to ship), and\n  freight/tax impact. Join to purchase_order_detail for line-level analysis, to\n  vendor for supplier attributes, and to employee for buyer attributes. Note:\n  status and revision are numeric codes; meanings should be confirmed.\n  Timestamps are standardized via a date shifting macro in staging.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: revisionnumber\n    description: >\n      Revision sequence number for the order header. Higher values indicate\n      subsequent edits to the same purchase order. Often 4 in this dataset.\n      Treat as an enum-like code rather than a continuous metric.\n    type: smallint\n    searchable: false\n    options:\n      - 4\n      - 5\n      - 6\n      - 7\n      - 8\n      - 9\n      - 10\n      - 12\n      - 14\n      - 20\n  - name: status\n    description: >\n      Lifecycle status code for the purchase order (numeric code). Common values\n      are 1–4 with 4 being the predominant terminal state in this dataset.\n      Meanings to be confirmed with the business/system.\n    type: smallint\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n  - name: orderdate\n    description: >\n      Datetime when the order was placed. Useful for cohorting and period-based\n      spend trends. Timezone normalized in staging. Often paired with shipDate\n      to calculate lead times.\n    type: timestamp without time zone\n    searchable: false\n  - name: shipdate\n    description: >\n      Datetime when the order shipped (or was scheduled to ship). Can be\n      compared with orderDate for lead-time analysis. Validate NULL semantics\n      for open/unshipped orders in your analysis.\n    type: timestamp without time zone\n    searchable: false\n  - name: modifieddate\n    description: >\n      Last update datetime for the header record. Can be used to identify recent\n      changes or audit windows.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: purchaseorderid\n    description: >\n      Primary key for the purchase order header. Use as the unique order\n      identifier and to join with purchase_order_detail.\n    type: integer\n  - name: employeeid\n    description: >\n      Buyer employee identifier; foreign key to employee.businessEntityID. Many\n      orders can map to one employee.\n    type: integer\n  - name: vendorid\n    description: >\n      Supplier identifier; foreign key to vendor.businessEntityID. Many orders\n      per vendor.\n    type: integer\n  - name: shipmethodid\n    description: >\n      Numeric identifier for the shipping method/service used. No corresponding\n      model exists in this repository; treat as an enum-like code.\n    type: integer\n  - name: subtotal\n    description: >\n      Sum of all line items before tax and freight. Currency unit is the\n      business base currency for this dataset. Right-skewed distribution (heavy\n      tails).\n    type: numeric\n  - name: taxamt\n    description: >\n      Total tax amount applied to the order. Typically non-negative and\n      proportional to subtotal. Analyze alongside subtotal and freight.\n    type: numeric\n  - name: freight\n    description: >\n      Freight/shipping charges for the order. Typically non-negative; varies\n      with ship method and order size.\n    type: numeric\nmetrics:\n  - name: total_due\n    expr: subTotal + taxAmt + freight\n    description: >\n      Total order amount including tax and freight. Used for spend analyses and\n      vendor performance reporting.\n    args: []\nfilters:\n  - name: has_ship_date\n    expr: shipDate IS NOT NULL\n    description: >-\n      Filter to orders with a non-null ship date (usually indicates\n      shipped/closed orders).\n    args: []\nrelationships:\n  - name: purchase_order_detail\n    source_col: purchaseorderid\n    ref_col: purchaseorderid\n    cardinality: one-to-many\n    description: >\n      Line items for each purchase order. Join on purchaseorderid to analyze\n      SKUs, quantities, and unit prices per order.\n  - name: vendor\n    source_col: vendorid\n    ref_col: businessentityid\n    cardinality: many-to-one\n    description: >\n      Supplier providing the goods. Join on vendorid = businessentityid to\n      analyze orders and spend by vendor.\n  - name: employee\n    source_col: employeeid\n    ref_col: businessentityid\n    cardinality: many-to-one\n    description: >\n      Buyer/agent who created the order. Join on employeeid = businessentityid\n      to analyze orders by buyer or org structure.\nclarifications:\n  - >-\n    Confirm status code mapping for purchase orders (meanings of 1–4) and\n    whether 4 represents a closed/received state.\n  - >-\n    Does subTotal include any discounts or adjustments? Are taxAmt and freight\n    always non-negative?\n  - >-\n    Is shipDate ever null for open/unshipped orders, and should analysts treat\n    NULLs as not yet shipped?\n  - >-\n    Do employeeID values always represent buyer agents\n    (employee.businessEntityID), or can other roles appear?\n  - >-\n    What lookup/dimension defines shipMethodID, and should it be\n    modeled/documented for analyses?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "f15bbf40-9847-44cd-8755-40561b8bb2d7",
    "name": "service_capacity_utilization",
    "databaseName": "postgres",
    "whenToUse": "A critical operational efficiency metric that measures how effectively service resources are being utilized across locations and time periods. This model supports optimized service operations by identifying capacity constraints, enabling data-driven staff scheduling based on historical utilization patterns, and providing insights for resource planning to match demand fluctuations. Use this data to reduce service bottlenecks, balance workloads across locations, make informed capital investment decisions for service capacity expansion, and improve overall customer satisfaction through more efficient service delivery.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.service_capacity_utilization",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081451+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "service_capacity_utilization",
    "ymlFile": "name: service_capacity_utilization\ndescription: >\n  Aggregated operational efficiency by manufacturing location. Use this model to\n  compare work centers on throughput, on-time completion, resource utilization,\n  scrap, and a composite service efficiency score. Useful for monitoring\n  bottlenecks, spotting locations with schedule risk or scrap spikes, and\n  benchmarking cost efficiency across locations. Metrics are aggregated over the\n  available data window (no date partitioning in this model); join to `location`\n  if you need additional attributes like cost rate or availability.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: locationid\n    description: >\n      Identifier for the manufacturing/work center location (from\n      Production.Location). Usage: primary key to join with the `location`\n      model; not suitable for free-text search.\n    type: smallint\n    searchable: false\n    options: null\n  - name: location_name\n    description: >\n      Human-readable name of the location/work center (e.g., \"Frame Welding\",\n      \"Paint\"). Useful for reporting, grouping, and search.\n    type: character varying\n    searchable: true\n    options: null\nmeasures:\n  - name: total_work_orders\n    description: >\n      Count of distinct work orders processed at the location. Proxy for\n      workload/throughput. Calculation: COUNT(DISTINCT workOrderID) aggregated\n      per location.\n    type: bigint\n  - name: total_resource_hours\n    description: >\n      Total actual resource hours recorded on work orders at the location.\n      Units: hours. Calculation: SUM(actualResourceHrs).\n    type: numeric\n  - name: metric_ontimecompletionrate\n    description: >\n      Percentage of work orders that completed on or before their scheduled end\n      time. Units: percent (0–100). Calculation: (on-time work orders / total\n      work orders) * 100, where on-time = actualEndDate <= scheduledEndDate.\n    type: numeric\n  - name: metric_resourceutilizationrate\n    description: >\n      Average ratio of actual resource hours to elapsed wall-clock time for work\n      orders, expressed as a percentage. Units: percent (0–100 typically).\n      Calculation: AVG(actualResourceHrs / duration_hours) * 100, where\n      duration_hours = hours between actualStartDate and actualEndDate. Notes:\n      Negative or >100% values may indicate timestamp anomalies; consider using\n      the provided filter to exclude implausible values.\n    type: numeric\n  - name: metric_costefficiencyrate\n    description: >\n      Cost performance relative to plan. 100% indicates actual cost matched\n      planned cost; >100% indicates overspend; <100% indicates underspend.\n      Calculation: (total_actual_cost / total_planned_cost) * 100.\n    type: numeric\n  - name: total_scrapped_units\n    description: >\n      Total number of units scrapped at the location across work orders.\n      Calculation: SUM(scrappedQty).\n    type: bigint\n  - name: metric_serviceefficiencyscore\n    description: >\n      Composite efficiency score combining schedule, resource, and cost\n      components. Units: percent-like score. Calculation: 100 * [ 0.4 *\n      on_time_completion_fraction + 0.3 * resource_utilization_fraction + 0.3 *\n      (planned_cost / actual_cost) ]. Higher is better.\n    type: numeric\nmetrics: []\nfilters:\n  - name: plausible_utilization\n    expr: metric_resourceutilizationrate BETWEEN 0 AND 200\n    description: >-\n      Exclude negative or extreme utilization values; keeps records within a\n      reasonable 0–200% range.\n    args: []\n  - name: nonzero_workload\n    expr: total_work_orders > 0\n    description: Keep only locations with at least one work order.\n    args: []\nrelationships:\n  - name: location\n    source_col: locationid\n    ref_col: locationid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Join to production location attributes (e.g., costRate, availability) for\n      additional context. Uses locationID as the key. At this aggregate level\n      there is effectively one row per location.\nclarifications:\n  - >-\n    Confirm whether metric_resourceutilizationrate is intended to be expressed\n    as percent (0–100) or fraction (0–1). SQL multiplies by 100, while profiled\n    values appear fractional.\n  - >-\n    Validate timestamp integrity for utilization: are actualStartDate and\n    actualEndDate guaranteed in-order and timezone-consistent?\n  - >-\n    Confirm cost efficiency interpretation: 100% = on plan; >100% = overspend;\n    <100% = underspend.\n  - >-\n    Confirm relationship coverage with `location` ≥ 95% on locationid =\n    locationid (no orphaned location IDs).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "e9918c35-d7be-43e7-9fba-be5294ea1452",
    "name": "total_orders_count",
    "databaseName": "postgres",
    "whenToUse": "Generated model for total_orders_count",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.total_orders_count",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081166+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "total_orders_count",
    "ymlFile": "name: total_orders_count\ndescription: >\n  Counts the total number of distinct orders placed across all time periods.\n  This fundamental  sales metric tracks order volume trends by aggregating the\n  count of unique sales orders by  year, quarter, and month.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: metric_totalorderscount\n    description: Count of distinct sales orders aggregated by time periods\n    type: bigint\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "bb0c88b2-90a1-49be-8f5c-f10e3c06e09b",
    "name": "basket_composition_analysis",
    "databaseName": "postgres",
    "whenToUse": "A powerful analytics metric that reveals product category relationships and purchase patterns within customer orders. This model supports strategic cross-selling initiatives by identifying high-affinity product combinations, informs merchandising decisions for optimal product placements, and uncovers bundling opportunities to increase average order value. Use these insights to create targeted promotions, develop effective product bundles, and enhance the customer shopping experience through data-driven recommendations based on established purchasing behaviors.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.basket_composition_analysis",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081386+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "basket_composition_analysis",
    "ymlFile": "name: basket_composition_analysis\ndescription: >\n  Identifies which high-level product categories commonly appear together in the\n  same sales orders. Each row represents an unordered pair of categories with\n  co-purchase counts, per-category order counts for context, an affinity score\n  indicating strength of association, and a popularity rank by frequency. Use it\n  to inform cross-sell and bundling strategies, merchandising, and category\n  planning. Category labels align with product_category.name.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: category_1\n    description: >\n      First category label in the pair. For each order, category pairs are\n      de-duplicated by alphabetical ordering of names, so category_1 ≤\n      category_2 lexicographically. Values mirror product_category.name.\n    type: character varying\n    searchable: false\n    options:\n      - Accessories\n      - Bikes\n      - Clothing\n      - Components\n  - name: category_2\n    description: >\n      Second category label in the pair, complementing category_1. Together with\n      category_1 forms an unordered pair; ordering is alphabetical only to\n      ensure uniqueness. Values mirror product_category.name.\n    type: character varying\n    searchable: false\n    options:\n      - Accessories\n      - Bikes\n      - Clothing\n      - Components\nmeasures:\n  - name: orders_with_both\n    description: >\n      Distinct sales orders that contained products from both category_1 and\n      category_2. Unit: orders. Higher values indicate more frequent\n      co-purchase.\n    type: bigint\n  - name: category_1_orders\n    description: >\n      Distinct sales orders that contained products in category_1. Unit: orders.\n      Provides context for the affinity calculation.\n    type: bigint\n  - name: category_2_orders\n    description: >\n      Distinct sales orders that contained products in category_2. Unit: orders.\n      Provides context for the affinity calculation.\n    type: bigint\n  - name: metric_affinityscore\n    description: >\n      Affinity ratio for the pair: orders_with_both / LEAST(category_1_orders,\n      category_2_orders). Range: 0–1. A value of 1 means every order for the\n      smaller category also included the other category; lower values indicate\n      weaker association.\n    type: numeric\n  - name: popularity_rank\n    description: >\n      1-based rank of the pair by orders_with_both (most common pairs have rank\n      1). Useful for top-N analyses and default sorting.\n    type: bigint\nmetrics: []\nfilters:\n  - name: top_pairs_by_popularity\n    expr: popularity_rank <= 10\n    description: Keep only the top 10 most frequent category pairs by orders_with_both.\n    args: []\n  - name: high_affinity_pairs\n    expr: metric_affinityscore >= 0.5\n    description: Category pairs with strong co-purchase affinity (at least 0.5).\n    args: []\nrelationships:\n  - name: product_category\n    source_col: category_1\n    ref_col: name\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to category metadata for category_1 via name. Many pairs map to one\n      product_category row. Use to enrich with category attributes.\n  - name: product_category\n    source_col: category_2\n    ref_col: name\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to category metadata for category_2 via name. Many pairs map to one\n      product_category row. Use to enrich with category attributes.\nclarifications:\n  - >-\n    Confirm casting to numeric in metric_AffinityScore to avoid integer division\n    producing zeros for ratios < 1.\n  - >-\n    Are category names guaranteed stable keys over time/language? If not,\n    consider joining on productCategoryID and projecting those IDs.\n  - >-\n    Should popularity_rank be constrained to a top-N set (e.g., top 100 pairs)\n    for downstream consumers?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "5cf80d72-57b5-48ba-90f6-3a19a5a92edc",
    "name": "product_cost_history",
    "databaseName": "postgres",
    "whenToUse": "This model tracks the evolution of product costs over time, supporting cost trend analysis, margin management, and historical profitability assessments. It enables business users to identify cost fluctuations, evaluate the impact of supplier changes or manufacturing process improvements, analyze seasonal cost patterns, and make data-driven decisions for pricing strategies and inventory valuation.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_cost_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081927+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_cost_history",
    "ymlFile": "name: product_cost_history\ndescription: >\n  Historical standard cost tracking for products with effective date ranges.\n  Each row represents  a cost version with start/end validity dates, similar to\n  product_list_price_history but for  internal cost basis rather than list\n  prices. Essential for inventory valuation, cost variance  analysis, margin\n  calculations over time, and understanding product profitability evolution. \n  Use with date ranges to get point-in-time costs or analyze cost changes. 49%\n  of records have  null enddate indicating currently active costs.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: startdate\n    description: >\n      Effective start date for this standard cost. Inclusive boundary; the cost\n      applies from  this date forward until enddate. Date-shifted via macro in\n      staging for consistency. Use  for point-in-time cost lookups and change\n      analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: enddate\n    description: >\n      Effective end date for this standard cost. NULL indicates currently active\n      cost (49% of  records). When populated, exclusive boundary (cost valid up\n      to but not including this date).  Use with startdate for date range\n      validations.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when cost record was last modified. Date-shifted via macro in\n      staging. Use for  audit trails and change tracking. May indicate when cost\n      was approved rather than when  it became effective.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: productid\n    description: >\n      Foreign key to product table. Identifies which product this cost applies\n      to. 293 distinct  products have cost history (395 total records). Use for\n      joining to product attributes and  counting products with cost changes.\n    type: integer\n  - name: standardcost\n    description: >\n      Standard unit cost for the product during this date range. Currency\n      assumed USD. Ranges  from $1.87 to $1,912.15 in dataset. Use for inventory\n      valuation, COGS calculations, and  margin analysis when joined with sales\n      prices.\n    type: numeric\nmetrics: []\nfilters:\n  - name: active_cost\n    expr: enddate IS NULL\n    description: Currently effective standard costs\n    args: []\n  - name: historical_cost\n    expr: enddate IS NOT NULL\n    description: Expired cost records\n    args: []\n  - name: recent_cost_changes\n    expr: startdate >= '2024-01-01'\n    description: Cost records effective since 2024\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: inner\n    cardinality: many-to-one\n    description: >\n      Product master for this cost record. Many cost history records per product\n      over time.  Access product details, categories, and specifications for\n      cost analysis.\n  - name: date_dimension_start\n    source_col: DATE(startdate)\n    ref_col: date_key\n    type: left\n    cardinality: many-to-one\n    description: >\n      Calendar attributes for cost start date. Enables time-based cost analysis,\n      seasonality  studies, and period aggregations. Truncate startdate to date\n      for join.\n  - name: date_dimension_end\n    source_col: DATE(enddate)\n    ref_col: date_key\n    type: left\n    cardinality: many-to-one\n    description: >\n      Calendar attributes for cost end date when not null. Use for analyzing\n      cost lifecycle  durations and change patterns. Truncate enddate to date\n      for join.\n  - name: product_list_price_history\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-many\n    description: >\n      List price history for margin analysis. Join on productid and overlapping\n      date ranges  to calculate historical margins. Many-to-many as date ranges\n      may not align perfectly.\nclarifications:\n  - >\n    Are startdate and enddate boundaries inclusive/exclusive? Standard practice\n    is [start, end)  but needs confirmation for accurate point-in-time queries.\n  - >\n    Is standardcost always in USD or does it vary by region/currency? How should\n    multi-currency  scenarios be handled?\n  - >\n    What triggers a new cost record creation? Supplier price changes, annual\n    reviews, or  procurement events?\n  - >\n    Should products without cost history (missing from this table) be assumed\n    zero cost or  excluded from analysis?\n  - >\n    How do standard costs relate to actual costs in purchase orders and work\n    orders? Which  should be used for different analyses?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "564b4e99-ad80-4964-93d3-f7d209c02f45",
    "name": "total_undiscounted_value",
    "databaseName": "postgres",
    "whenToUse": "Generated model for total_undiscounted_value",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.total_undiscounted_value",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081545+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "total_undiscounted_value",
    "ymlFile": "name: total_undiscounted_value\ndescription: >\n  Calculates the total value of all orders before any discounts are applied.\n  This metric shows  the gross order value by summing (unit price × quantity)\n  for all order line items, useful  for analyzing discount impact and pricing\n  strategies.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: metric_totalundiscountedvalue\n    description: >-\n      Total undiscounted value calculated as SUM(unit price × quantity) before\n      discounts are applied, aggregated by time periods\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "dfc63d8f-1346-4ef7-a266-c8affb115a7c",
    "name": "average_order_value",
    "databaseName": "postgres",
    "whenToUse": "Tracks the average monetary value of customer orders over time. Essential for monitoring sales performance, customer spending patterns, pricing strategy effectiveness, and identifying seasonal trends. Supports revenue forecasting and sales team performance evaluation.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.average_order_value",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081303+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "average_order_value",
    "ymlFile": "name: average_order_value\ndescription: >\n  Calculates the average value of orders grouped by time periods. This metric\n  shows the mean  order value trends over time by computing the average of (unit\n  price × quantity × (1 - discount))  for all order line items within each time\n  period.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: metric_averageordervalue\n    description: >-\n      Average order line value calculated as AVG(unit price × quantity × (1 -\n      discount)) aggregated by time periods\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "ca9868ea-dce9-43f3-adbd-cdf562c82f78",
    "name": "product_photo",
    "databaseName": "postgres",
    "whenToUse": "This model supports comprehensive digital asset management for product imagery, enabling efficient product visualization across sales channels and organized marketing material creation. It helps answer business questions about product visual representation completeness, digital asset utilization across marketing campaigns, image quality consistency standards, and tracking of product appearance changes over time to support both e-commerce and physical merchandising strategies.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_photo",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082007+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_photo",
    "ymlFile": "name: product_photo\ndescription: >\n  Central repository for product image binary data and metadata. Contains\n  thumbnail and large  format photos in binary format (primarily GIF) along with\n  filenames. Many products share the  same photo, especially productphotoid=1\n  which appears to be a placeholder image. Use for  product catalog displays,\n  e-commerce interfaces, and marketing materials. Binary data is  stored as\n  bytea/Buffer; handle with appropriate image processing libraries.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productphotoid\n    description: >\n      Primary key uniquely identifying each photo. Many products can reference\n      the same photo ID.  ID=1 appears frequently as a default/placeholder\n      image. Use for deduplication and as join  key to product_product_photo\n      mapping table.\n    type: integer\n    searchable: false\n    options: null\n  - name: thumbnailphotofilename\n    description: >\n      Filename for the thumbnail image (e.g., \"racer02_thumb.gif\"). Indicates\n      format and content  type. Searchable for finding specific image files.\n      Predominantly GIF format in current data.\n    type: character varying\n    searchable: true\n    options: null\n  - name: largephotofilename\n    description: >\n      Filename for the large format image (e.g., \"racer02.gif\"). Full-size\n      product image filename.  Searchable for catalog management. Usually\n      matches thumbnail name without \"_thumb\" suffix.\n    type: character varying\n    searchable: true\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when photo record was last modified. Date-shifted via macro in\n      staging. Use for  change tracking and cache invalidation. May not reflect\n      actual image content changes.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: thumbnailphoto\n    description: >\n      Binary thumbnail image data stored as bytea/Buffer. Smaller resolution for\n      quick loading  in lists and previews. Requires image processing library to\n      decode and display. Check for  NULL before processing.\n    type: bytea\n  - name: largephoto\n    description: >\n      Binary large format image data stored as bytea/Buffer. Full resolution for\n      product detail  pages. Larger file size impacts query performance and\n      bandwidth. Decode with appropriate  image libraries.\n    type: bytea\nmetrics: []\nfilters:\n  - name: has_thumbnail\n    expr: thumbnailphoto IS NOT NULL\n    description: Photos with thumbnail data present\n    args: []\n  - name: has_large_photo\n    expr: largephoto IS NOT NULL\n    description: Photos with large format data present\n    args: []\n  - name: placeholder_images\n    expr: productphotoid = 1\n    description: Default/placeholder photos (commonly ID=1)\n    args: []\n  - name: gif_format\n    expr: largephotofilename LIKE '%.gif'\n    description: GIF format images based on filename\n    args: []\nrelationships:\n  - name: product_product_photo\n    source_col: productphotoid\n    ref_col: productphotoid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Junction table linking photos to products. One photo can be used by\n      multiple products.  Use to find all products using a specific photo or all\n      photos for a product.\nclarifications:\n  - >\n    What image formats are supported beyond GIF? Are there standards for\n    resolution, aspect  ratio, or file size limits?\n  - >\n    Should binary photo data be included in analytical queries or should a\n    separate image  service handle retrieval to avoid performance impacts?\n  - >\n    Is productphotoid=1 officially designated as a placeholder, or is this\n    coincidental?  Should it be excluded from certain analyses?\n  - >\n    Are there plans to migrate from binary storage in database to external\n    object storage  (S3, CDN) for better performance?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "37aa691f-1f5f-47a7-ae6e-e3a6d6fc4d6d",
    "name": "state_province",
    "databaseName": "postgres",
    "whenToUse": "Generated model for state_province",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.state_province",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082987+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "state_province",
    "ymlFile": "name: state_province\ndescription: >\n  Reference dimension for first-level administrative divisions (states,\n  provinces, departments) across multiple countries/regions. Contains a\n  surrogate key, a country/region code, a short local code, a human-readable\n  name, and the source modified timestamp. Use this model to standardize\n  geography joins for addresses, tax rates, and other regional data. Note:\n  stateProvinceCode formatting varies by country (e.g., US two-letter codes\n  often padded with spaces; France uses numeric departmental codes). Prefer\n  joins on stateProvinceID for reliability; combine countryRegionCode with\n  stateProvinceCode or name when codes/names are needed for presentation.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: stateprovincecode\n    description: >\n      Short local code for the state/province. Formats vary by country. US\n      entries are typically two-letter codes with possible trailing spaces\n      (e.g., \"MO \"), while France commonly uses numeric departmental codes\n      (e.g., 52, 79, 87). Not globally unique and may require normalization for\n      comparisons. Usage notes: TRIM and UPPER when comparing; combine with\n      countryRegionCode for disambiguation.\n    type: character\n    searchable: false\n  - name: countryregioncode\n    description: >\n      Country/region identifier associated with the state/province. Useful for\n      filtering and joining to the country_region model on countryRegionCode.\n      Low-cardinality enum across the dataset.\n    type: character varying\n    searchable: false\n    options:\n      - FR\n      - US\n      - CA\n      - DE\n      - AU\n      - AS\n      - FM\n      - GB\n      - MH\n      - MP\n      - PW\n      - VI\n  - name: name\n    description: >\n      Official state/province name. May include diacritics and parentheses\n      (e.g., \"Vienne (Haute)\"). Not guaranteed to be globally unique; combine\n      with countryRegionCode for clarity in reports and deduplication.\n      Recommended for display and free-text search.\n    type: character varying\n    searchable: true\n  - name: modifieddate\n    description: >\n      Source system last-modified timestamp. Values cluster into a small set of\n      dates corresponding to source updates; not intended for time-series trend\n      analysis of the geography itself. Treat as a technical lineage timestamp\n      rather than a business event time.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: stateprovinceid\n    description: >\n      Surrogate integer identifier for the state/province. Primary key of this\n      model and the preferred key for joins. Not meaningful to aggregate.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: address\n    source_col: stateProvinceID\n    ref_col: stateProvinceID\n    type: left\n    cardinality: one-to-many\n    description: >\n      Addresses located within this state/province. Join on stateProvinceID.\n      Typically one state/province to many addresses.\n  - name: sales_tax_rate\n    source_col: stateProvinceID\n    ref_col: stateProvinceID\n    type: left\n    cardinality: one-to-many\n    description: >\n      Sales tax rates defined for this state/province. Join on stateProvinceID.\n      Typically one state/province to many tax rate records (by type or\n      effective period).\n  - name: country_region\n    source_col: countryRegionCode\n    ref_col: countryRegionCode\n    type: left\n    cardinality: many-to-one\n    description: >\n      The country/region that this state/province belongs to. Join on\n      countryRegionCode. Many states/provinces map to one country/region.\nclarifications:\n  - >-\n    Confirm whether stateProvinceCode is padded with spaces for all US entries\n    and whether consumers should TRIM in downstream models, or if we should\n    standardize in this model.\n  - >-\n    Are French numeric department codes expected to remain numeric in\n    stateProvinceCode, or should they be cast to text consistently? Any\n    cross-country harmonization desired?\n  - >-\n    Validate relationship coverage address.stateProvinceID and\n    sales_tax_rate.stateProvinceID match to state_province.stateProvinceID at >=\n    95%.\n  - >-\n    Is modifiedDate intended purely as a technical last-modified field, or are\n    there cases where it reflects a business-effective change that analysts\n    should consider?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "faee30ae-26c2-43d9-bae3-d49af31652ec",
    "name": "product_model_illustration",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_model_illustration",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_model_illustration",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081962+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_model_illustration",
    "ymlFile": "name: product_model_illustration\ndescription: >\n  Bridge table mapping product models to their associated illustrations. Use\n  this model to attach diagrams/illustrations to product model records, or to\n  count how many illustrations a model has. Typical usage is joining to\n  product_model on productmodelid and to illustration on illustrationid.\n  Many-to-many by design; expect repeated ids on both sides. modifieddate\n  reflects the last update timestamp from the source system.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productmodelid\n    description: >\n      Identifier of the product model this illustration is linked to. Use to\n      join to product_model.productmodelid. Not unique in this table because a\n      model can have multiple illustrations.\n    type: integer\n    searchable: false\n    options: null\n  - name: illustrationid\n    description: >\n      Identifier of the illustration linked to the product model. Use to join to\n      illustration.illustrationid. Not unique in this table because an\n      illustration can be used by multiple product models.\n    type: integer\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when the mapping record was last updated in the source. Useful\n      for change tracking or recency filters; values often cluster around a few\n      recent timestamps.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_model\n    source_col: productmodelid\n    ref_col: productmodelid\n    cardinality: many-to-one\n    description: >\n      Links each mapping to its product model. Join on\n      product_model_illustration.productmodelid = product_model.productmodelid.\n      Many-to-one from this table to product_model.\n  - name: illustration\n    source_col: illustrationid\n    ref_col: illustrationid\n    cardinality: many-to-one\n    description: >\n      Links each mapping to its illustration asset. Join on\n      product_model_illustration.illustrationid = illustration.illustrationid.\n      Many-to-one from this table to illustration.\nclarifications:\n  - >-\n    Confirm whether the composite key is (productmodelid, illustrationid) and if\n    duplicates are fully prevented upstream.\n  - >-\n    Are modifieddate timestamps standardized to UTC or another canonical\n    timezone across staging?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "4d101611-edcd-4137-b270-3f568227d06c",
    "name": "sales_order_header_sales_reason",
    "databaseName": "postgres",
    "whenToUse": "Generated model for sales_order_header_sales_reason",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_order_header_sales_reason",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082348+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_order_header_sales_reason",
    "ymlFile": "name: sales_order_header_sales_reason\ndescription: >\n  Bridge table that maps sales orders to the reasons associated with those\n  orders. Use it to analyze why customers placed orders by joining to\n  sales_order_header (for order context) and sales_reason (for human-readable\n  reason names and types). Orders can have multiple reasons; some orders may\n  have none. This table is most commonly used to count reasons, segment orders\n  by reason type, and build reason-based funnels or cohorts.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: salesorderid\n    description: >\n      Sales order identifier. Foreign key to sales_order_header.salesorderid.\n      Use as the join key when bringing in order-level attributes or aggregating\n      reasons per order.\n    type: integer\n    searchable: false\n    options: null\n  - name: salesreasonid\n    description: >\n      Sales reason identifier. Foreign key to sales_reason.salesreasonid.\n      Low-cardinality FK (a small set of reason IDs). Join to sales_reason to\n      access the human-readable reason name and reason type for analysis and\n      filtering.\n    type: integer\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when the order–reason relationship was last updated in the\n      source system. Useful for audits and recency checks; not the primary\n      business event time for the order. Stored without timezone; treat\n      timestamps as UTC unless otherwise noted.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: sales_order_header\n    source_col: salesorderid\n    ref_col: salesorderid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each reason assignment back to its order. Many reason rows can map\n      to one order; coverage may be less than 100% of orders depending on\n      capture practices.\n  - name: sales_reason\n    source_col: salesreasonid\n    ref_col: salesreasonid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Provides the human-readable reason name and reason type for each\n      assignment.\nclarifications:\n  - >-\n    Confirm that modifieddate reflects the assignment/update time of the reason\n    (not the order's event time).\n  - >-\n    What percentage of orders have at least one associated sales reason? Aim for\n    ≥95% coverage?\n  - >-\n    Can an order have multiple reasons, and is there a designated primary reason\n    when multiples exist?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "61b5c22f-e2f1-4ded-9369-6aef760e4fa7",
    "name": "bill_of_materials",
    "databaseName": "postgres",
    "whenToUse": "This model provides critical insights into product component tracking, manufacturing cost breakdown, and assembly process planning. It enables analysis of component usage across products, helps identify opportunities for component standardization, facilitates inventory planning based on assembly requirements, and supports cost optimization through component-level analysis. The model is essential for understanding product dependencies, managing supply chain relationships, and ensuring efficient manufacturing operations.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.bill_of_materials",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081887+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "bill_of_materials",
    "ymlFile": "name: bill_of_materials\ndescription: >\n  Bill of materials lines linking an assembly product to its component\n  product(s), with effective dating, quantities, and units of measure. Use this\n  to traverse product structure, analyze component usage, or derive material\n  requirements. Dates are shifted via the shift_date macro in staging; enddate\n  is typically null for active/open-ended lines. bomlevel indicates hierarchy\n  depth (0 = top-level assembly; higher = deeper subcomponents).\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: startdate\n    description: >\n      Effective start timestamp for when this component became valid for the\n      specified assembly context. Use with enddate to time-slice the BOM.\n      Typical usage: filter for a reporting window or current effectiveness.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: enddate\n    description: >\n      Effective end timestamp; null indicates the component relationship is\n      currently active/open-ended. Use to exclude retired components or to\n      analyze historical configurations.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: unitmeasurecode\n    description: >\n      Unit of measure for perassemblyqty. Fixed CHAR(3) with trailing spaces\n      (common values include 'EA ', 'OZ ', 'IN '). Join to\n      unit_measure.unitmeasurecode; consider TRIM() when joining across\n      CHAR/VARCHAR differences.\n    type: character\n    searchable: false\n    options: null\n  - name: bomlevel\n    description: >\n      Hierarchical depth of the component relative to the assembly (0 =\n      top-level assembly; 1+ = deeper subcomponents). Useful for roll-ups or\n      exploding the BOM by level.\n    type: smallint\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp of last update to this BOM line (often matches startdate for new\n      rows). Helpful for change detection and audit.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: billofmaterialsid\n    description: >\n      Surrogate primary key for this BOM line. Use for row-level identification;\n      aggregate only as counts (e.g., COUNT or COUNT DISTINCT), not as a sum.\n    type: integer\n  - name: productassemblyid\n    description: >\n      Product ID of the parent assembly using the component. Nullable in some\n      cases. Join to product.productid to pull assembly attributes.\n    type: integer\n  - name: componentid\n    description: >\n      Product ID of the component item. Join to product.productid to pull\n      component attributes.\n    type: integer\n  - name: perassemblyqty\n    description: >\n      Quantity of the component required per assembly, expressed in\n      unitmeasurecode. Common values are 1, 2, 4, and 8; larger values may occur\n      for bulk materials.\n    type: numeric\nmetrics: []\nfilters:\n  - name: current_active\n    expr: (startdate <= now() AND (enddate IS NULL OR enddate > now()))\n    description: Retain BOM rows that are currently effective.\n    args: []\n  - name: ended\n    expr: enddate IS NOT NULL AND enddate <= now()\n    description: Rows with a finite enddate (no longer effective).\n    args: []\n  - name: has_parent_assembly\n    expr: productassemblyid IS NOT NULL\n    description: Rows where the component belongs to a specific parent assembly.\n    args: []\n  - name: top_level\n    expr: bomlevel = 0\n    description: Top-level assembly rows/components in the hierarchy.\n    args: []\nrelationships:\n  - name: product_component\n    source_col: componentid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Component product for this BOM line; many BOM rows map to a single\n      component in the product model.\n  - name: product_assembly\n    source_col: productassemblyid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Parent assembly product that uses the component. Nullable; when present,\n      many BOM rows map to one assembly product in the product model.\n  - name: unit_measure\n    source_col: unitmeasurecode\n    ref_col: unitmeasurecode\n    type: left\n    cardinality: many-to-one\n    description: >-\n      Unit of measure referenced by unitmeasurecode (CHAR(3) with trailing\n      spaces).\nclarifications:\n  - >-\n    Confirm exact semantics of bomlevel (is 0 always the top-level assembly in\n    this dataset?).\n  - >-\n    Do NULL productassemblyid rows represent standalone components/templates vs.\n    valid BOM entries without a parent?\n  - >-\n    Confirm timezone expectations for shifted dates (shift_date macro) and\n    whether comparisons should use UTC.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "c3024fb7-7279-4708-8603-9648cb44be7b",
    "name": "contact_type",
    "databaseName": "postgres",
    "whenToUse": "Strategic model for relationship categorization and communication channel management. Enables systematic organization of business relationships by purpose and function. Valuable for developing targeted communication strategies, analyzing relationship portfolio composition, and optimizing contact management processes. Supports marketing, sales, and customer service teams in segmenting contacts appropriately, tailoring outreach based on relationship type, and ensuring proper stakeholder management. Essential for implementing structured relationship development programs and measuring engagement effectiveness across different contact categories.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.contact_type",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082636+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "contact_type",
    "ymlFile": "name: contact_type\ndescription: >\n  Reference table of standardized contact roles used to categorize relationships\n  between people and business entities (e.g., Owner, Purchasing Manager, Sales\n  Agent). Use this model to label, group, and filter contacts by role. Join to\n  business_entity_contact on contacttypeid to enrich contact relationships with\n  human-readable role names. The set of roles is small and stable; timestamps\n  are normalized to UTC and may be uniform per load.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable role label for the contact type. This is a closed set of\n      standard values, suitable for filters and grouping. Not free-text. Values\n      are case-sensitive and should be treated as enumerated options.\n    type: character varying\n    searchable: false\n    options:\n      - Accounting Manager\n      - Assistant Sales Agent\n      - Assistant Sales Representative\n      - Coordinator Foreign Markets\n      - Export Administrator\n      - International Marketing Manager\n      - Marketing Assistant\n      - Marketing Manager\n      - Marketing Representative\n      - Order Administrator\n      - Owner\n      - Owner/Marketing Assistant\n      - Product Manager\n      - Purchasing Agent\n      - Purchasing Manager\n      - Regional Account Representative\n      - Sales Agent\n      - Sales Associate\n      - Sales Manager\n      - Sales Representative\n  - name: modifieddate\n    description: >\n      Timestamp of the last update to this contact type record, normalized to\n      UTC. In this dataset it is often uniform across rows within a load and is\n      typically not suitable for temporal change analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: contacttypeid\n    description: >\n      Surrogate identifier and primary key for the contact type. Use as the join\n      key to business_entity_contact.contacttypeid. Aggregate with count or\n      count distinct when needed; not a business metric by itself.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: business_entity_contact\n    source_col: contacttypeid\n    ref_col: contacttypeid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Maps contacts to business entities with an associated contact role. Join\n      to add the role name to each mapping. One contact_type can relate to many\n      business_entity_contact rows.\nclarifications:\n  - >-\n    Is modifieddate meaningful at the row level, or is it batch-level and\n    uniform per load? Should analysts avoid using it for time-based analysis?\n  - >-\n    Are the 20 contact type names considered canonical and stable, or can the\n    set/labels change over time?\n  - >-\n    Is the join coverage with business_entity_contact on contacttypeid expected\n    to be 100% in production?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "d38beaae-95d9-4d2f-9d9c-053b45b48931",
    "name": "shift",
    "databaseName": "postgres",
    "whenToUse": "Generated model for shift",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.shift",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08278+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "shift",
    "ymlFile": "name: shift\ndescription: >\n  Dimension table enumerating the standard work shifts used for scheduling and\n  reporting (Day, Evening, Night). Includes a unique shift identifier, display\n  name, and start/end times as time-of-day values. Commonly used to label or\n  aggregate employee assignments, productivity, and operations by shift, or to\n  filter activity to a specific shift. Note: start/end are times without\n  timezone; the modified timestamp reflects last source update and may be\n  standardized in this environment.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable name of the shift. Useful for grouping or filtering\n      analyses by shift. Typical values are the three standard schedules.\n    type: character varying\n    searchable: true\n    options:\n      - Day\n      - Evening\n      - Night\n  - name: starttime\n    description: >\n      Time-of-day the shift begins (no timezone). Typical values: 07:00:00,\n      15:00:00, 23:00:00. Usage notes: the Night shift (23:00–07:00) crosses\n      midnight; treat as an overnight window when computing durations.\n    type: time without time zone\n    searchable: false\n    options: null\n  - name: endtime\n    description: >\n      Time-of-day the shift ends (no timezone). Typical values: 07:00:00,\n      15:00:00, 23:00:00. Usage notes: for overnight shifts, endtime occurs on\n      the following calendar day relative to starttime.\n    type: time without time zone\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp of the last update for the shift record from the source system.\n      In this environment, values may be aligned to a constant reference date\n      for consistency; treat as metadata rather than a business event timestamp.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: shiftid\n    description: >\n      Unique identifier for the shift. Typical mapping observed: 1 = Day, 2 =\n      Evening, 3 = Night. Use as the join key to related assignment/history\n      tables.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: employee_department_history\n    source_col: shiftid\n    ref_col: shiftid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Link to employee department assignment history to attribute the assigned\n      shift. Join on shiftid. Expected coverage is near 100% with values in\n      {1,2,3}; use to enrich assignments with shift names and hours.\nclarifications:\n  - >-\n    Confirm timezone for starttime and endtime; are values stored in local time\n    or UTC?\n  - >-\n    Validate mapping between shiftid and name (1=Day, 2=Evening, 3=Night) and\n    whether any additional shifts can appear.\n  - >-\n    Confirm relationship coverage with employee_department_history on shiftid ≥\n    99%.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "5eea6701-ba66-47e2-9c2d-305887b7ed6f",
    "name": "special_offer_product",
    "databaseName": "postgres",
    "whenToUse": "Generated model for special_offer_product",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.special_offer_product",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082126+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "special_offer_product",
    "ymlFile": "name: special_offer_product\ndescription: >\n  Junction table mapping promotions to products. Each row links a special offer\n  to a product, enabling many-to-many relationships between offers and catalog\n  items. Typical usage: join to special_offer for discount details (type,\n  category, date window, thresholds) and to product for product attributes.\n  Common analyses include identifying which products are on promotion, measuring\n  promotional coverage across the catalog, and attributing sales or margin\n  impacts to specific offers. Note: modifieddate is time-shifted by a macro for\n  demo freshness and may appear in discrete update batches; treat it primarily\n  as an audit field unless performing recency-based diagnostics.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: rowguid\n    description: >\n      UUID v4 technical identifier for this mapping row. Useful for lineage,\n      deduplication, and change tracking; not meaningful for business analysis.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Last update timestamp for the mapping row. Dates are shifted via the\n      project macro to align with a consistent reference \"today\" for demo\n      freshness, which results in a small set of discrete timestamps. Use for\n      audit/troubleshooting and careful recency filters.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: specialofferid\n    description: >\n      Foreign key to special_offer. Identifies the promotion applied to the\n      product. Use as a join key; do not aggregate as a numeric measure.\n    type: integer\n  - name: productid\n    description: >\n      Foreign key to product. Identifies the product receiving the offer. Use as\n      a join key; do not aggregate as a numeric measure.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each mapping to the corresponding product to bring in product\n      attributes (name, category, pricing). One row in this model maps to one\n      product; a product may appear in many rows (different offers or times).\n  - name: special_offer\n    source_col: specialofferid\n    ref_col: specialofferid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each mapping to the promotion definition (discount percentage/type,\n      qualifying quantities, active date window). One row in this model maps to\n      one offer; an offer typically spans many products.\nclarifications:\n  - >-\n    Confirm that (specialofferid, productid) is unique at this layer (no\n    duplicate mappings).\n  - >-\n    Is join coverage to product and special_offer expected to be ~100%, or are\n    exceptions possible?\n  - >-\n    Should modifieddate be considered strictly an audit field, or are there use\n    cases to analyze mapping changes over time?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "a4d9de83-df67-41fd-b117-1f210612d778",
    "name": "product_total_revenue",
    "databaseName": "postgres",
    "whenToUse": "Metric model that calculates the total revenue for each product with time dimensions",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_total_revenue",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081615+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_total_revenue",
    "ymlFile": "name: product_total_revenue\ndescription: >\n  Total revenue by product at quarterly granularity. Use this model to trend and\n  compare product revenue across calendar years and quarters, rank top products,\n  and analyze seasonality. Revenue is computed from order line items and time\n  context comes from order dates. Notes: revenue excludes taxes,\n  freight/shipping, and does not adjust for returns/cancellations unless those\n  are reflected in the underlying sales tables.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Product identifier; primary join key to the product model. Use to enrich\n      with product attributes (category, model, pricing, etc.). Many metric rows\n      per product due to time breakdown.\n    type: integer\n    searchable: false\n  - name: product_name\n    description: >\n      Human-readable product name from the product entity. Helpful for display\n      and ad-hoc search; for authoritative attributes, prefer joining to the\n      product model.\n    type: character varying\n    searchable: true\n  - name: year\n    description: |\n      Calendar year extracted from sales_order_header.orderdate.\n    type: numeric\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: |\n      Calendar quarter (1–4) extracted from sales_order_header.orderdate.\n    type: numeric\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_producttotalrevenue\n    description: >\n      Total revenue for the given product and time period. Calculation:\n      SUM(sod.unitPrice * sod.orderQty * (1 - sod.unitPriceDiscount)). Units\n      follow the source currency of sales_order_detail (typically USD). Excludes\n      tax, freight/shipping, and any post-order returns/cancellations.\n    type: numeric\nmetrics:\n  - name: total_revenue\n    expr: SUM(metric_producttotalrevenue)\n    description: Aggregated total revenue across the selected filters and groupings.\n    args: []\nfilters:\n  - name: current_year\n    expr: year = EXTRACT(YEAR FROM CURRENT_DATE)\n    description: Restrict to the current calendar year.\n    args: []\n  - name: last_two_years\n    expr: year >= EXTRACT(YEAR FROM CURRENT_DATE) - 1\n    description: Restrict to the current and previous calendar year.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Join to the product entity to pull descriptive attributes. Expect many\n      metric rows per product across quarters and years; this is a many-to-one\n      relationship from this model to product on productid.\nclarifications:\n  - >-\n    Confirm currency for unitPrice and whether any multi-currency conversion is\n    applied (expected: USD).\n  - >-\n    Does revenue exclude returns/cancellations entirely, or are such adjustments\n    reflected in sales tables?\n  - Confirm timezone assumptions for orderdate when deriving year/quarter.\n  - Validate relationship coverage with product on productid ≥ 99%.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "c2408bc4-d069-4d74-b71c-07b688cbcb28",
    "name": "product_model",
    "databaseName": "postgres",
    "whenToUse": "This model supports product template management, providing a framework for standardized product attributes and product line analysis. It enables businesses to understand product family relationships, maintain consistent product specifications across related items, facilitate new product development based on existing templates, and analyze performance patterns across product model groups to inform product strategy and lifecycle management decisions.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_model",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081774+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_model",
    "ymlFile": "name: product_model\ndescription: >\n  Reference list of product model families (e.g., Road-150, Mountain-500) used\n  to group individual products. Useful for model-level analysis and joining to\n  products and auxiliary mapping tables. Includes sparse, semi-structured XML\n  fields for catalog marketing content and manufacturing/assembly instructions.\n  Typical usage: join to product on productmodelid to analyze products by model,\n  identify which models have enriched catalog descriptions or instructions, and\n  filter by last modification timestamp for freshness audits. Note: XML fields\n  are not parsed at this layer.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable product model name (model family label). Common patterns\n      include bike families such as Road-150, Mountain-500, Touring-2000. Usage\n      notes: Unique per row in this dataset and suitable for display and search.\n      Prefer productmodelid as the stable join key.\n    type: character varying\n    searchable: true\n    options: null\n  - name: catalogdescription\n    description: >\n      Marketing catalog description in XML format. When present, typically\n      begins with ProductDescription and may include Summary, Manufacturer,\n      Features, Picture, and Specifications sections with mixed XML/HTML\n      namespaces. Usage notes: Largely null across models; not parsed in this\n      model. Treat as long text/XML for downstream parsing or display use cases.\n    type: xml\n    searchable: false\n    options: null\n  - name: instructions\n    description: >\n      Manufacturing/assembly instructions in XML format. Root element contains\n      one or more Location nodes with step-by-step instructions and work center\n      metadata. Usage notes: Mostly null and not parsed here; treat as long\n      text/XML for downstream processing when needed.\n    type: xml\n    searchable: false\n    options: null\n  - name: rowguid\n    description: >\n      System-generated UUID (v4) from the source system. Intended for\n      replication and technical tracking rather than analytics. Usage notes:\n      Unique per row; avoid aggregations; rarely needed in business queries.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Last modified timestamp from the source record. Used for audit/freshness\n      checks and recency filtering rather than time-series trends. Usage notes:\n      Values are normalized via shift_date in staging; treat as UTC and note\n      clustering at a few snapshot dates.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: productmodelid\n    description: >\n      Primary key for product_model. Use as the join key to related models\n      (product, product_model_illustration, and\n      product_model_product_description_culture). Do not sum; for counts, use\n      COUNT(DISTINCT productmodelid).\n    type: integer\nmetrics: []\nfilters:\n  - name: has_catalog_description\n    expr: catalogdescription IS NOT NULL\n    description: Models with a populated catalogdescription XML\n    args: []\n  - name: has_instructions\n    expr: instructions IS NOT NULL\n    description: Models with a populated instructions XML\n    args: []\nrelationships:\n  - name: product\n    source_col: productmodelid\n    ref_col: productmodelid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Products associated to this model family. One product model can relate to\n      zero or many products. Use to analyze products by model.\n  - name: product_model_illustration\n    source_col: productmodelid\n    ref_col: productmodelid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Illustration mappings for each product model. One product model may have\n      many associated illustration links; coverage may be partial.\n  - name: product_model_product_description_culture\n    source_col: productmodelid\n    ref_col: productmodelid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Description–culture mappings for each product model. One product model may\n      have multiple product descriptions across languages/cultures.\nclarifications:\n  - >-\n    Are catalogdescription and instructions intended to be parsed downstream, or\n    should we expose parsed fields in a separate model?\n  - >-\n    Is modifiedDate normalized to UTC after shift_date, and is it safe to use\n    for temporal analyses (or just for audit/freshness)?\n  - >-\n    Is name guaranteed unique and stable over time, or can it be updated for the\n    same productModelID?\n  - >-\n    What percentage of products have a non-null productModelID when joining to\n    product (expected coverage)?\n  - Is rowguid meaningful for analysis or strictly a replication artifact?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "dfc603b2-6a9d-407a-bb78-f88dca0f36be",
    "name": "product_quarterly_sales",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_quarterly_sales",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_quarterly_sales",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081575+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_quarterly_sales",
    "ymlFile": "name: product_quarterly_sales\ndescription: >\n  Calculates the total sales revenue for each product by quarter. This metric\n  tracks product  performance over time by summing the net sales value (unit\n  price × quantity × (1 - discount))  for each product within quarterly periods.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: product_name\n    description: Name of the product for which quarterly sales are being calculated\n    type: character varying\n    searchable: true\n    options: null\nmeasures:\n  - name: productid\n    description: Unique identifier for the product\n    type: integer\n  - name: year\n    description: Year extracted from the order date for quarterly grouping\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) for quarterly sales aggregation\n    type: numeric\n  - name: metric_productquarterlysales\n    description: >-\n      Total sales revenue for the product in the quarter, calculated as SUM(unit\n      price × quantity × (1 - discount))\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "12a0488b-474f-4d7b-911d-d1ab3707b091",
    "name": "product_total_cost",
    "databaseName": "postgres",
    "whenToUse": "Metric model that calculates the total cost for each product with time dimensions",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_total_cost",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081253+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_total_cost",
    "ymlFile": "name: product_total_cost\ndescription: >\n  Total product cost aggregated by product and calendar quarter/year. Useful for\n  cost analysis, category rollups, and profitability work when combined with\n  revenue metrics. The metric is computed from sales order lines and current\n  product standard cost, with time context derived from order dates.\ndimensions:\n  - name: productid\n    description: >\n      Adventure Works product identifier. Use to join to the product model and\n      other product-grain models. One row per product per year/quarter;\n      duplicates across time are expected by design.\n    type: integer\n    searchable: false\n  - name: product_name\n    description: >\n      Human-friendly product name from Product.name. Helpful for search and\n      presentation. Note: names can change; values reflect the Product.name\n      present at model build time.\n    type: string\n    searchable: true\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderDate that provides the\n      time context for the aggregation. Commonly used for trending and YoY\n      comparisons.\n    type: integer\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: |\n      Calendar quarter (1–4) extracted from SalesOrderHeader.orderDate.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_producttotalcost\n    description: >\n      Total product cost for the period. Calculation: SUM(Product.standardCost *\n      SalesOrderDetail.orderQty). Monetary units match the source pricing\n      currency. Note: uses the current/loaded Product.standardCost rather than\n      historical cost; no explicit exclusions for returns or cancellations are\n      applied in this model.\n    type: number\nmetrics:\n  - name: product_total_cost\n    expr: SUM(metric_producttotalcost)\n    description: |\n      Sum of metric_producttotalcost over the selected slice.\n    args: []\nfilters:\n  - name: recent_years\n    expr: year >= 2023\n    description: |\n      Restrict to the most recent two years commonly used for performance views.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Enrich with product attributes (e.g., category, filters). Each row here\n      maps to exactly one Product; a product has many rows over time\n      (year/quarter).\nclarifications:\n  - >-\n    Should canceled or returned order lines be excluded from the cost\n    calculation?\n  - >-\n    Should historical cost (e.g., product_cost_history) be used instead of\n    current Product.standardCost?\n  - Confirm relationship coverage with product ≥ 99% on productid = productid.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "105e6408-5735-4756-8f3d-b8443dba698a",
    "name": "product_subcategory",
    "databaseName": "postgres",
    "whenToUse": "This model enables effective product hierarchy management, category performance analysis, and product organization insights. It helps answer critical business questions about subcategory contribution to overall category performance, subcategory growth trends, cross-category product relationships, and hierarchical product classification effectiveness. The model is essential for merchandising strategy, product assortment planning, category management optimization, and identifying opportunities for new product development within established subcategories.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_subcategory",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081822+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_subcategory",
    "ymlFile": "name: product_subcategory\ndescription: >\n  Reference dimension for product subcategories within the Adventure Works\n  catalog. Use it to label and group products and sales at the subcategory\n  level, and to roll up to broader product categories. Typical usage: join from\n  product on productSubcategoryID; optionally chain to product_category via\n  productCategoryID for category-level analyses. Names are human-friendly (e.g.,\n  Mountain Bikes, Road Bikes, Cranksets) and suitable for filters and display.\n  The rowguid is a system UUID for replication/lineage and is rarely needed in\n  analytics. The modifiedDate reflects the source-modified timestamp for this\n  record set.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable subcategory label used for grouping, filtering, and display\n      (e.g., Mountain Bikes, Road Bikes, Cranksets). Generally stable but may be\n      renamed; prefer the numeric key for joins. Suitable for search and UI\n      filters.\n    type: character varying\n    searchable: true\n  - name: rowguid\n    description: >\n      System-generated UUID (v4) used for replication/lineage in the source\n      system. Unique per row; seldom used for analytics. Prefer\n      productSubcategoryID for joins and grouping.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: >\n      Source last-modified timestamp. In current loads this value is uniform\n      across rows, indicating snapshot/update time. Useful for auditing data\n      freshness; avoid using it for record-level change detection.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: productsubcategoryid\n    description: >\n      Integer surrogate key for the subcategory. Use for joins to product and\n      for grouping or count distincts. Not an additive metric.\n    type: integer\n  - name: productcategoryid\n    description: >\n      Foreign key linking this subcategory to its parent product_category. Use\n      to roll up subcategories to categories via joins.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_category\n    source_col: productCategoryID\n    ref_col: productCategoryID\n    type: left\n    cardinality: many-to-one\n    description: >\n      Each subcategory belongs to exactly one product category. Join on\n      productCategoryID to access category-level labels and aggregates.\n  - name: product\n    source_col: productSubcategoryID\n    ref_col: productSubcategoryID\n    type: left\n    cardinality: one-to-many\n    description: >\n      Products are assigned to a subcategory. Join on productSubcategoryID to\n      analyze product- level facts by subcategory.\nclarifications:\n  - >-\n    Is modifiedDate expected to be uniform across all rows (snapshot time), or\n    does it reflect record-level updates?\n  - >-\n    Are subcategory names guaranteed to be unique and stable over time, or can\n    they change?\n  - For deduplication, should analysts prefer productSubcategoryID over rowguid?\n  - >-\n    Confirm that all products have a valid productSubcategoryID (expected 100%\n    coverage when joining to product).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "04a165de-16de-4e43-9d57-205e498a0049",
    "name": "scrap_reason",
    "databaseName": "postgres",
    "whenToUse": "This model helps with quality control analysis, defect categorization, and waste reduction initiatives. It enables manufacturing teams to systematically track and analyze the reasons for scrapped materials and products, providing valuable insights for continuous improvement. The data helps answer critical business questions about the most common causes of product defects, trends in quality issues over time, and opportunities for process improvements to minimize waste and reduce manufacturing costs.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.scrap_reason",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08288+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "scrap_reason",
    "ymlFile": "name: scrap_reason\ndescription: >\n  Reference dimension listing the controlled set of reasons why a manufacturing\n  work order was scrapped. Useful for attributing scrapped quantities and\n  analyzing defect and process issues by category (e.g., drill size,\n  paint/primer failures, handling damage). Small, relatively static list\n  maintained in Production.ScrapReason. Upstream staging applies date shifting\n  to standardize modified timestamps.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable label describing the scrap reason. Acts like a controlled\n      taxonomy for defect categorization. Use this to group/segment scrapped\n      work orders by cause. Usage notes: Low-cardinality list; safe to use in\n      breakdowns and filters.\n    type: character varying\n    searchable: true\n    options:\n      - Primer process failed\n      - Thermoform temperature too high\n      - Handling damage\n      - Color incorrect\n      - Seat assembly not as ordered\n      - Drill pattern incorrect\n      - Thermoform temperature too low\n      - Drill size too small\n      - Trim length too long\n      - Drill size too large\n      - Brake assembly not as ordered\n      - Stress test failed\n      - Wheel misaligned\n      - Gouge in metal\n      - Paint process failed\n      - Trim length too short\n  - name: modifieddate\n    description: >\n      Last update timestamp for the scrap reason record. Upstream staging uses\n      shift_date to normalize timezone/consistency. Typically uniform across\n      values and best used for audit context rather than event-time analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: scrapreasonid\n    description: >\n      Integer identifier and primary key for the scrap reason. Use to join to\n      work_order on scrapreasonid. Intended as an identifier; aggregation should\n      typically be counts (e.g., count distinct reasons) rather than sums.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: work_order\n    source_col: scrapreasonid\n    ref_col: scrapreasonid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Work orders may reference this scrap reason to explain scrapped\n      quantities. Join on scrapreasonid. One scrap_reason maps to many\n      work_orders; coverage is <100% because many work orders have NULL\n      scrapreasonid.\nclarifications:\n  - >-\n    Is the scrap reason taxonomy centrally governed, and how often do values\n    change?\n  - >-\n    For analyses, should NULL work_order.scrapreasonid be treated as 'Unknown'\n    or excluded?\n  - >-\n    Confirm that modifieddate is a record-metadata timestamp and fully\n    standardized by shift_date.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "6cebe628-6ca9-43f7-8730-0868e1dc7da2",
    "name": "sales_order_header",
    "databaseName": "postgres",
    "whenToUse": "Comprehensive sales order model supporting complete order lifecycle analysis, sales pipeline management, and customer purchase behavior insights. Enables revenue forecasting, order fulfillment tracking, payment analysis, and sales territory performance evaluation. Critical for understanding customer buying patterns, order complexity, and sales channel effectiveness.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_order_header",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082296+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_order_header",
    "ymlFile": "name: sales_order_header\ndescription: >\n  Order-level fact table for customer purchases. Each row is a single sales\n  order header with core identifiers, dates, monetary amounts, channel flags,\n  and four derived behavioral filters that capture purchase context,\n  consultation level, decision factors, and customization. Use this model to\n  analyze order volume, value, and mix, and to join to order lines, customers,\n  territories, sales staff, and reasons. Note: dates are timezone-naive and\n  shifted by the pipeline's date shift macro; monetary totals do not include\n  returns/cancellations and total due is not explicitly included in this model\n  (compute as subtotal + taxamt + freight when needed).\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: revisionnumber\n    description: >\n      Revision version for the order header as recorded by the source system.\n      Mostly 8 with occasional 9; not typically used for analysis except\n      auditing.\n    type: smallint\n    searchable: false\n    options:\n      - '8'\n      - '9'\n  - name: orderdate\n    description: >\n      Timestamp when the order was placed. Useful for trending and cohorting.\n      Time component present; timezone-naive due to upstream processing.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: duedate\n    description: >\n      Expected delivery/due date for the order. Use for SLA and cycle-time\n      analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: shipdate\n    description: >\n      Date the order was shipped. Combine with orderdate/duedate for lead-time\n      and fulfillment analysis. In this dataset, status indicates shipped\n      orders.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: status\n    description: >\n      Numeric code representing the order status. In AdventureWorks, common\n      codes are 1 In Process, 2 Approved, 3 Backordered, 4 Rejected, 5 Shipped,\n      6 Cancelled. This dataset contains status 5 (Shipped).\n    type: smallint\n    searchable: false\n    options:\n      - '5'\n  - name: onlineorderflag\n    description: >\n      True when the order was placed online (B2C web channel); false typically\n      indicates assisted or B2B orders.\n    type: boolean\n    searchable: false\n    options:\n      - 'true'\n      - 'false'\n  - name: purchaseordernumber\n    description: >\n      Customer-provided purchase order identifier (e.g., \"PO12345...\"). Often\n      null for online/B2C orders; populated for B2B/assisted orders.\n    type: character varying\n    searchable: false\n    options: null\n  - name: accountnumber\n    description: >\n      Customer account number associated to the order, formatted like\n      10-4030-0xxxxx or 10-4020-000xxx. Useful for reconciliation; prefer\n      customerid for joining.\n    type: character varying\n    searchable: false\n    options: null\n  - name: creditcardapprovalcode\n    description: >\n      Approval/authorization code from the payment processor (alphanumeric, may\n      embed card type hints). Transactional reference; avoid indexing or\n      free-text search.\n    type: character varying\n    searchable: false\n    options: null\n  - name: rowguid\n    description: Globally unique identifier for the record (UUID) from the source system.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: Timestamp when the record was last updated in the source system.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: filter_purchase_context\n    description: >\n      Derived purchase context based on customer history and the products in the\n      order. Useful for segmentation and campaign analysis.\n    type: text\n    searchable: false\n    options:\n      - First Bike\n      - Upgrade\n      - Additional Bike\n      - Maintenance & Upgrade\n      - Accessory Purchase\n      - Replacement Parts\n  - name: filter_consultation_level\n    description: >\n      Derived assistance level during the purchase based on salesperson\n      involvement and sales reasons. Helpful for channel/service-level analysis.\n    type: text\n    searchable: false\n    options:\n      - Self-service\n      - Basic Assistance\n      - Complete Consultation\n      - Standard Support\n  - name: filter_decision_factor\n    description: >\n      Primary factor influencing the purchase decision inferred from reasons,\n      price effects, and product characteristics.\n    type: text\n    searchable: false\n    options:\n      - Price-driven\n      - Technology-driven\n      - Brand-driven\n      - Fit-driven\n      - Value-driven\n  - name: filter_customization_level\n    description: >\n      Degree of product customization inferred from item mix and counts in the\n      order.\n    type: text\n    searchable: false\n    options:\n      - Stock\n      - Minor Adjustments\n      - Significant Customization\n      - Custom Build\n      - Standard Options\nmeasures:\n  - name: salesorderid\n    description: Unique identifier for the sales order header. Use for counting orders.\n    type: integer\n  - name: customerid\n    description: Foreign key to customer; links orders to individuals or stores.\n    type: integer\n  - name: salespersonid\n    description: Foreign key to sales_person; nullable for online/self-service orders.\n    type: integer\n  - name: territoryid\n    description: Foreign key to sales_territory; region associated to the order.\n    type: integer\n  - name: billtoaddressid\n    description: Foreign key to address used for billing.\n    type: integer\n  - name: shiptoaddressid\n    description: Foreign key to address used for shipping.\n    type: integer\n  - name: shipmethodid\n    description: Identifier for shipping method used. No dedicated model in this repo.\n    type: integer\n  - name: creditcardid\n    description: >-\n      Foreign key to credit_card used for payment; may be null for non-card\n      payments.\n    type: integer\n  - name: currencyrateid\n    description: >-\n      Foreign key to currency_rate used when non-base currency applies; often\n      null.\n    type: integer\n  - name: subtotal\n    description: >-\n      Merchandise total before tax and freight. Monetary amount; add taxamt and\n      freight for total order value.\n    type: numeric\n  - name: taxamt\n    description: Tax amount applied to the order. Monetary amount.\n    type: numeric\n  - name: freight\n    description: Shipping charges for the order. Monetary amount.\n    type: numeric\nmetrics: []\nfilters:\n  - name: online_orders\n    expr: onlineorderflag = true\n    description: Orders placed through the online channel.\n    args: []\n  - name: b2b_orders\n    expr: purchaseordernumber IS NOT NULL\n    description: Orders with a customer PO number present (typically assisted/B2B).\n    args: []\n  - name: shipped_last_30d\n    expr: shipdate >= CURRENT_DATE - INTERVAL '30 days'\n    description: Orders shipped in the last 30 days.\n    args: []\n  - name: high_value_orders\n    expr: (subtotal + taxamt + freight) > 1000\n    description: Orders with total value over 1000 in header currency.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    cardinality: many-to-one\n    description: >-\n      Orders placed by a customer. Join on customerid; many orders to one\n      customer.\n  - name: sales_person\n    source_col: salespersonid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >-\n      Salesperson associated to assisted orders. Nullable; many orders to one\n      salesperson.\n  - name: sales_territory\n    source_col: territoryid\n    ref_col: territoryid\n    cardinality: many-to-one\n    description: >-\n      Territory/region associated with the order; many orders map to one\n      territory.\n  - name: address\n    source_col: billtoaddressid\n    ref_col: addressid\n    cardinality: many-to-one\n    description: Billing address for the order; many orders to one address.\n  - name: address\n    source_col: shiptoaddressid\n    ref_col: addressid\n    cardinality: many-to-one\n    description: Shipping address for the order; many orders to one address.\n  - name: credit_card\n    source_col: creditcardid\n    ref_col: creditcardid\n    type: left\n    cardinality: many-to-one\n    description: >-\n      Credit card used for the transaction when applicable; many orders to one\n      card.\n  - name: currency_rate\n    source_col: currencyrateid\n    ref_col: currencyrateid\n    type: left\n    cardinality: many-to-one\n    description: >-\n      Currency rate applied when non-base currency is used; coverage < 100%\n      (nullable).\n  - name: sales_order_detail\n    source_col: salesorderid\n    ref_col: salesorderid\n    cardinality: one-to-many\n    description: Order line items; one order header to many details.\n  - name: sales_order_header_sales_reason\n    source_col: salesorderid\n    ref_col: salesorderid\n    cardinality: one-to-many\n    description: Mapping of order headers to sales reasons; one order to many mapping rows.\nclarifications:\n  - >-\n    Confirm whether monetary amounts (subtotal, taxamt, freight) are all in a\n    single base currency or may vary by currencyrateid.\n  - >-\n    Status appears to be always 5 (Shipped) in this dataset. Is this by design\n    or a data filter? Should other statuses be included?\n  - >-\n    Is creditcardapprovalcode considered sensitive? If so, confirm handling and\n    whether to exclude from search indexing.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "f1061f87-31c8-4ae8-abd7-096bc7701e6e",
    "name": "employee",
    "databaseName": "postgres",
    "whenToUse": "Contains comprehensive employee information including demographics, job details, and employment status. Valuable for workforce planning, HR analytics, compensation analysis, diversity reporting, and organizational development initiatives.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.employee",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082722+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "employee",
    "ymlFile": "name: employee\ndescription: >\n  Employee records with core HR attributes for each Adventure Works staff\n  member. Use this model when you need employment facts such as job title, hire\n  date, salaried/hourly status, and leave balances. Typical joins are via\n  businessentityid to enrich with person details or to analyze department and\n  pay histories. For active headcount analyses, filter currentflag = true. Dates\n  are stored without timezone semantics at this layer.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: nationalidnumber\n    description: >\n      HR national identifier assigned to the employee (system-specific). Unique\n      per employee. Usage notes: Treated as sensitive identifier; avoid using in\n      reports or joins unless explicitly required for operational workflows.\n    type: character varying\n    searchable: false\n    options: null\n  - name: loginid\n    description: >\n      Domain-qualified network login used for authentication (e.g.,\n      \"adventure-works\\\\jane0\"). Unique per employee; suitable for audit-style\n      lookups. Not recommended as a durable join key to business facts.\n    type: character varying\n    searchable: false\n    options: null\n  - name: jobtitle\n    description: >\n      Employee job title from HR (free-text). Common patterns include production\n      roles such as \"Production Technician - WC10/20/30/40/50/60\" and\n      sales/administrative titles. Useful for workforce segmentation and\n      slicing.\n    type: character varying\n    searchable: true\n    options: null\n  - name: birthdate\n    description: >\n      Date of birth for the employee (date). Usage notes: Apply privacy\n      controls; typical analytic usage is to derive age bands or cohorting\n      rather than exposing raw dates.\n    type: date\n    searchable: false\n    options: null\n  - name: maritalstatus\n    description: |\n      Marital status code. \"M\" = Married; \"S\" = Single.\n    type: character\n    searchable: false\n    options:\n      - M\n      - S\n  - name: gender\n    description: |\n      Gender code from HR. \"M\" = Male; \"F\" = Female.\n    type: character\n    searchable: false\n    options:\n      - M\n      - F\n  - name: hiredate\n    description: >\n      Employee hire/start date (date). Commonly used for tenure calculations and\n      monthly headcount by cohort analyses.\n    type: date\n    searchable: false\n    options: null\n  - name: salariedflag\n    description: |\n      Indicates salaried (true) versus hourly (false) employees.\n    type: boolean\n    searchable: false\n    options: null\n  - name: vacationhours\n    description: >\n      Current available vacation hours (smallint). Useful for leave balance\n      summaries at a point in time.\n    type: smallint\n    searchable: false\n    options: null\n  - name: sickleavehours\n    description: |\n      Current available sick leave hours (smallint).\n    type: smallint\n    searchable: false\n    options: null\n  - name: currentflag\n    description: >\n      True if the employee is currently active; false indicates former\n      employees.\n    type: boolean\n    searchable: false\n    options: null\n  - name: rowguid\n    description: >\n      System-generated UUID for replication/sync. Not meaningful for analysis;\n      avoid as a join key.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: |\n      Timestamp of the last modification in the source system.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: businessentityid\n    description: >\n      Surrogate key for the employee and the primary join key to related models\n      (person, business_entity, pay history, department history, etc.). Unique\n      per employee.\n    type: integer\nmetrics: []\nfilters:\n  - name: current_employees\n    expr: currentflag = true\n    description: Filter to only active employees for current headcount.\n    args: []\n  - name: salaried_only\n    expr: salariedflag = true\n    description: Filter to salaried employees.\n    args: []\n  - name: hourly_only\n    expr: salariedflag = false\n    description: Filter to hourly employees.\n    args: []\nrelationships:\n  - name: business_entity\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Every employee is backed by a business entity record. Join to access\n      entity-level metadata and to relate employees to other entity-linked\n      facts.\n  - name: person\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Enrich employees with personal attributes (first/last name, contact\n      preferences). Expected one person per employee.\n  - name: employee_department_history\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Historical department assignments per employee. Use for org movement and\n      departmental tenure analysis.\n  - name: employee_pay_history\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Pay rate change history per employee. Use to understand compensation\n      changes over time.\n  - name: sales_person\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Sales-specific details for employees who serve as salespeople. Coverage is\n      a subset of employees.\n  - name: job_candidate\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Candidate records associated with an employee (when applicable). Not all\n      employees have related candidate entries.\nclarifications:\n  - >-\n    Does maritalstatus ever include codes beyond \"M\" and \"S\" (e.g., divorced,\n    widowed)? If so, enumerate.\n  - >-\n    Confirm whether gender is strictly \"M\"/\"F\" or if additional codes are\n    possible.\n  - >-\n    Confirm the intended semantics of currentflag (active employment vs.\n    record-level validity) and expected coverage.\n  - >-\n    Are job title changes tracked elsewhere historically, or is jobtitle\n    current-state only in this model?\n  - >-\n    Any restrictions on the analytic use of nationalidnumber (treat as\n    sensitive/PII)?\n  - >-\n    Estimate relationship coverage to sales_person (what percentage of employees\n    have a corresponding row?).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "3cb529b4-c554-4289-a9d3-405c9c223eb8",
    "name": "customer_first_purchase_date",
    "databaseName": "postgres",
    "whenToUse": "Generated model for customer_first_purchase_date",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_first_purchase_date",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081183+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_first_purchase_date",
    "ymlFile": "name: customer_first_purchase_date\ndescription: >\n  Identifies the first recorded purchase date for each purchasing customer. Use\n  this model for cohorting (e.g., by first purchase month/quarter), lifecycle\n  analysis (time since first purchase), and as a joinable attribute at customer\n  grain. Notes: Only includes customers who have at least one order (inner-join\n  to sales_order_header). Customers with no orders are not present. Timestamps\n  are stored without timezone; treat consistently with\n  sales_order_header.orderdate.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: metric_first_purchase_date\n    description: >\n      Earliest order date observed for the customer based on\n      sales_order_header.orderdate (MIN over all of the customer's orders).\n      Useful for cohort segmentation and computing customer tenure. Non-null by\n      construction for all rows in this model. Time stored as timestamp without\n      timezone; align with project-wide timezone conventions when comparing to\n      other time fields.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: customerid\n    description: >\n      Surrogate key of the customer. Primary join key to customer and\n      order-derived models on customerid. One row per purchasing customer in\n      this model (unique).\n    type: integer\nmetrics: []\nfilters:\n  - name: first_purchase_last_12_months\n    expr: metric_first_purchase_date >= CURRENT_DATE - INTERVAL '12 months'\n    description: Customers whose first purchase occurred within the last 12 months.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    cardinality: one-to-one\n    description: >\n      Customer entity providing profile and segmentation attributes. Join on\n      customerid. Cardinality is effectively one-to-one at this layer (one row\n      per purchasing customer here joins to one row in customer).\n  - name: sales_order_header\n    source_col: customerid\n    ref_col: customerid\n    cardinality: one-to-many\n    description: >\n      Order headers placed by the customer. Join on customerid to provide\n      order-level context if needed. Cardinality is one-to-many from this model\n      to order headers.\nclarifications:\n  - >-\n    Confirm whether canceled/voided orders are excluded from the first purchase\n    calculation.\n  - >-\n    Is there any exclusion of internal/test customers before computing first\n    purchase?\n  - >-\n    Timezone: order dates are stored without timezone; should they be treated as\n    UTC or a business-local timezone for cohorting?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "59079b2f-5578-40c3-b1d3-7e5fb852af8a",
    "name": "customer_lifetime_value",
    "databaseName": "postgres",
    "whenToUse": "A strategic metric that estimates the total revenue a business can expect from a customer throughout their relationship. This metric is essential for customer acquisition strategy (determining maximum viable CAC), segmentation for retention efforts,  personalizing marketing investment, and identifying your most valuable customers. Use it to inform long-term business planning, prioritize customer service resources, and make data-driven decisions about customer relationship management.\\n",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_lifetime_value",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.0811+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_lifetime_value",
    "ymlFile": "name: customer_lifetime_value\ndescription: >\n  Cumulative customer lifetime value by customer and time period. Each row\n  represents a customer’s cumulative revenue (to date) at the end of a given\n  year and quarter. Useful for retention analysis, segmentation by value,\n  cohorting, and tracking how customer value evolves over time. Derived from\n  sales order line totals; includes discounts and excludes tax and freight. Time\n  context comes from order dates.\ndimensions:\n  - name: customerid\n    description: >\n      Internal AdventureWorks customer identifier. Use as the primary join key\n      to the customer model. One row per customer per year–quarter; customer IDs\n      repeat across time periods by design.\n    type: integer\n    searchable: false\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderDate. Typical use:\n      year-over-year comparisons and time slicing.\n    type: integer\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: >\n      Calendar quarter (1–4) extracted from SalesOrderHeader.orderDate. Use\n      alongside year for quarterly analysis and cumulative trending.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_clv\n    description: >\n      Cumulative customer lifetime value to the end of the specified\n      year–quarter. Calculation: running SUM(period_sales) per customer ordered\n      by (year, quarter), where period_sales = SUM(sales_order_detail.lineTotal)\n      grouped by customer, year, quarter. Notes: lineTotal reflects unitPrice ×\n      orderQty × (1 − unitPriceDiscount); discounts included; tax and freight\n      excluded.\n    type: decimal\nmetrics: []\nfilters:\n  - name: positive_clv\n    expr: metric_clv > 0\n    description: |\n      Restrict to customers/periods with a strictly positive cumulative value.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Relates each CLV record to the base customer entity. Join to enrich CLV\n      with customer attributes and segments.\n  - name: sales_order_header\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Orders contributing to CLV. For drill-through, join on customerid; to\n      align to the same period, filter SalesOrderHeader on EXTRACT(YEAR FROM\n      orderDate) = year and EXTRACT(QUARTER FROM orderDate) = quarter.\n  - name: sales_order_detail\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Line items whose lineTotal aggregates into CLV via SalesOrderHeader.\n      Typically reached through SalesOrderHeader joins.\nclarifications:\n  - >-\n    Should metric_clv be net of returns/cancellations (if present), or are such\n    adjustments not modeled?\n  - >-\n    Confirm currency handling for metric_clv (single currency vs. mixed) and\n    whether any FX normalization is expected.\n  - >-\n    For reporting CLV by customer, should analysts default to the latest\n    available year–quarter per customer (e.g., use MAX period)?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "6c2a6665-9889-47fc-bbe6-e8ab27dd8b1f",
    "name": "culture",
    "databaseName": "postgres",
    "whenToUse": "This model supports internationalization efforts, localization strategies, and market-specific product adaptations. It provides foundational data for tailoring product descriptions, documentation, and marketing materials to different cultural and linguistic markets. The model helps answer key business questions about regional market readiness, translation requirements for global product launches, and the effectiveness of localized content across different markets, enabling better decision-making for international business expansion.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.culture",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083017+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "culture",
    "ymlFile": "name: culture\ndescription: >\n  Language and locale lookup used to contextualize product content and other\n  documents. Typical use is to join with localization/junction tables to filter\n  or enrich data by language. Values cover a small, fixed set of cultures\n  including an invariant/neutral culture. Upstream source is Production.Culture\n  via staging; cultureid is a padded CHAR(6) and may include hyphenated locale\n  codes.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: cultureid\n    description: >\n      Six-character culture/language code used to localize product content.\n      Typical values align to ISO language codes; observed values include\n      two-letter codes with right padding and 'zh-cht' for Traditional Chinese.\n      A blank code ('      ') corresponds to \"Invariant Language (Invariant\n      Country)\". Usage notes: Values are CHAR(6) and often right-padded with\n      spaces; preserve padding for exact joins to downstream models; trim for\n      display.\n    type: character\n    searchable: false\n    options:\n      - '      '\n      - 'ar    '\n      - 'en    '\n      - 'es    '\n      - 'fr    '\n      - 'he    '\n      - 'th    '\n      - zh-cht\n  - name: name\n    description: >\n      Human-readable culture name corresponding to cultureid. Low-cardinality\n      lookup matching the culture code. Common values include English, Spanish,\n      French, Thai, Arabic, Hebrew, Chinese, and \"Invariant Language (Invariant\n      Country)\".\n    type: character varying\n    searchable: false\n    options:\n      - Arabic\n      - Chinese\n      - English\n      - French\n      - Hebrew\n      - Spanish\n      - Thai\n      - Invariant Language (Invariant Country)\n  - name: modifieddate\n    description: >\n      Timestamp of the last update to the culture record (UTC). Observed to be\n      uniform across all rows in the current dataset. Useful for data freshness\n      checks rather than analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures: []\nmetrics: []\nfilters:\n  - name: exclude_invariant_culture\n    expr: cultureid <> '      '\n    description: Exclude the invariant/blank culture rows when analyzing localized content.\n    args: []\nrelationships:\n  - name: product_model_product_description_culture\n    source_col: cultureid\n    ref_col: cultureid\n    type: left\n    cardinality: one-to-many\n    description: >\n      One culture maps to many product model–description localization rows; join\n      to filter or enrich product content by language/locale.\nclarifications:\n  - >-\n    Confirm that a six-space cultureid represents 'Invariant Language (Invariant\n    Country)' and whether it should generally be excluded in analyses.\n  - >-\n    Are joins on cultureid expected to use padded CHAR(6) values, or should both\n    sides be trimmed/canonicalized?\n  - >-\n    Is 'zh-cht' the only hyphenated culture code, or should we expect additional\n    locale variants?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "a54646d3-4c27-4274-8d9f-8c545dcac763",
    "name": "order_fulfillment_rate",
    "databaseName": "postgres",
    "whenToUse": "Generated model for order_fulfillment_rate",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.order_fulfillment_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081476+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "order_fulfillment_rate",
    "ymlFile": "name: order_fulfillment_rate\ndescription: >\n  Percentage of orders shipped on or before their due date. This is an aggregate\n  KPI computed from sales_order_header with no direct join key. Use it as a\n  standalone performance metric or alongside other KPIs; avoid joining it to\n  row-level models. Useful for tracking operational efficiency and SLA\n  adherence.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: metric_orderfulfillmentrate\n    description: >\n      Order fulfillment rate as a percentage. Calculated as: COUNT(CASE WHEN\n      shipDate <= dueDate THEN salesOrderID END) / NULLIF(COUNT(salesOrderID),\n      0) * 100. Units: percent. Null handling: rows with NULL shipDate or NULL\n      dueDate are excluded from the numerator; all non-null salesOrderID rows\n      are counted in the denominator. Equality (shipDate = dueDate) counts as on\n      time.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications:\n  - >-\n    Should orders with NULL shipDate or NULL dueDate be excluded from both\n    numerator and denominator rather than just the numerator?\n  - >-\n    Confirm that shipDate = dueDate is considered on time (current logic counts\n    it as on time).\n  - Should canceled or returned orders be excluded from the denominator?\n  - >-\n    Is there a need for time-grained variants (e.g., monthly order fulfillment\n    rate), or is this intended as an all-time snapshot?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "1333dfd8-4466-4a67-b9fc-6350bf97398a",
    "name": "illustration",
    "databaseName": "postgres",
    "whenToUse": "This model helps with product documentation, technical diagrams management, and visual asset organization. It centralizes storage and access to product illustrations, technical drawings, and assembly diagrams, making them available across product development, manufacturing, and customer support teams. The data helps answer business questions about illustration usage across product models, diagram version control, and visual asset requirements for new product documentation, facilitating consistent visual communication throughout the product lifecycle.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.illustration",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083068+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "illustration",
    "ymlFile": "name: illustration\ndescription: >\n  Product illustrations and diagrams used across product catalogs and models.\n  Contains one row per illustration with a large vector markup payload and the\n  last update timestamp. Use when you need the raw diagram content or to\n  understand where an illustration is referenced via bridge tables. Usage notes:\n  the `diagram` field is a large XML/XAML-like blob (e.g., tags such as\n  <Viewbox>, <Canvas>, <Path>) and can be heavy to materialize; avoid selecting\n  it in wide queries unless necessary. The timestamp is derived in staging using\n  a date-shift macro.\ndimensions:\n  - name: illustrationid\n    description: >\n      Unique identifier for the illustration. Join key to downstream bridge\n      tables that relate illustrations to product models. Typically stable and\n      unique per row.\n    type: integer\n    searchable: false\n  - name: diagram\n    description: >\n      Vector illustration markup (XML/XAML-like) representing the product\n      diagram. Usage notes: very long, high-cardinality text; includes nested\n      vector drawing elements and attributes. Consider deriving lighter-weight\n      features (e.g., size, presence of specific tags) upstream if you need to\n      filter by content. Not indexed for free-text search.\n    type: text\n    searchable: false\n  - name: modifieddate\n    description: >\n      Last modified timestamp for the illustration record, produced in staging\n      via `shift_date('modifieddate')`. Use for freshness filters and recency\n      analysis.\n    type: timestamp\n    searchable: false\nmeasures: []\nmetrics: []\nfilters:\n  - name: has_diagram\n    expr: diagram IS NOT NULL\n    description: Keep only rows with non-null diagram payloads.\n    args: []\n  - name: updated_last_365d\n    expr: modifieddate >= CURRENT_DATE - INTERVAL '365 day'\n    description: Filter to illustrations updated in the last 365 days.\n    args: []\nrelationships:\n  - name: product_model_illustration\n    source_col: illustrationid\n    ref_col: illustrationid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Bridge of product models to illustrations. Join on `illustrationid` to see\n      all product models that reference a given illustration, or traverse to\n      `product_model` for model-level context.\nclarifications:\n  - >-\n    Confirm whether `modifieddate` values should be interpreted as UTC after\n    `shift_date`, and if any timezone normalization is applied.\n  - Is `illustrationid` globally unique and immutable across loads?\n  - >-\n    What is the expected maximum size of `diagram`, and are there constraints\n    for downstream export/BI tools?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "8081c4a0-0b7a-4637-a2b5-9113decbf0a7",
    "name": "employee_productivity",
    "databaseName": "postgres",
    "whenToUse": "A comprehensive performance metric that quantifies employee output and contribution to business objectives. This model supports data-driven workforce management by providing insights into individual and team performance patterns, helping optimize resource allocation based on productivity metrics, and identifying opportunities for operational efficiency improvements. Use this data to recognize top performers, tailor training programs to address skill gaps, inform promotion and compensation decisions, and implement targeted productivity improvement initiatives across different departments or locations.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.employee_productivity",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081319+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "employee_productivity",
    "ymlFile": "name: employee_productivity\ndescription: >\n  Per-employee sales productivity summary. One row per salesperson, derived from\n  Sales Order Header joined via person/employee. Use to compare average order\n  value and total sales volume across sales staff. Values reflect\n  SalesOrderHeader SubTotal (line amounts after discounts) aggregated across all\n  orders attributed to each salesperson. Typical usage: rank employees by\n  productivity, identify outliers (high average order size vs. high order\n  volume), or join to employee and person models for HR and identity context.\n  Note this model is not time- sliced; apply time filters via related order data\n  if you need period-specific comparisons.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: businessentityid\n    description: >\n      Employee identifier and join key. Matches employee.businessentityid and\n      person.businessentityid; one row per salesperson in this model.\n    type: integer\n    searchable: false\n    options: null\n  - name: employee_name\n    description: >\n      Full name for display, built as firstName + ' ' + lastName from person.\n      Contains Unicode characters/diacritics (e.g., José). Not recommended as a\n      join key; use businessentityid instead.\n    type: text\n    searchable: false\n    options: null\nmeasures:\n  - name: total_sales_amount\n    description: >\n      Sum of SalesOrderHeader.subtotal for all orders attributed to the\n      salesperson. Includes line-level discounts; excludes tax (taxamt) and\n      freight. Currency follows the underlying order currency.\n    type: numeric\n  - name: number_of_orders\n    description: |\n      Count of SalesOrderHeader.salesorderid attributed to the salesperson.\n    type: bigint\n  - name: metric_employeeproductivity\n    description: >\n      Average order subtotal per employee: total_sales_amount /\n      NULLIF(number_of_orders, 0). Useful to compare average deal size across\n      sales staff.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: employee\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-one\n    description: >\n      HR master record for each employee (job title, tenure, etc.). One-to-one\n      on businessentityid.\n  - name: person\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Person entity for names and contact metadata. One-to-one on\n      businessentityid.\n  - name: sales_order_header\n    source_col: businessentityid\n    ref_col: salespersonid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Underlying orders attributed to each salesperson. One employee to many\n      orders via salespersonid.\nclarifications:\n  - >-\n    Confirm currency handling for subtotal values; are amounts standardized to a\n    single reporting currency?\n  - >-\n    Confirm that SubTotal includes line-level discounts and excludes tax and\n    freight.\n  - >-\n    Are canceled/returned orders excluded from this aggregation? Sample\n    SalesOrderHeader shows status = 5 (shipped); please confirm broader\n    behavior.\n  - >-\n    This model aggregates across all time. Do we want standard time-sliced\n    variants (e.g., monthly/quarterly) or recommended filters when comparing\n    productivity over time?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "1a0a3e9f-81d8-4e52-9148-068f8ef906bf",
    "name": "country_region_currency",
    "databaseName": "postgres",
    "whenToUse": "Generated model for country_region_currency",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.country_region_currency",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083152+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "country_region_currency",
    "ymlFile": "name: country_region_currency\ndescription: >\n  Maps each country/region code to the three-letter currency code used in that\n  country/region. Useful for determining a region's default or historical\n  currency and for joining to country and currency reference models. Includes\n  legacy/historical currencies (e.g., FRF, ESP) for countries that adopted the\n  euro, so a given country can appear with multiple currencies across time.\n  Built from the Sales schema's countryregioncurrency reference table via\n  staging.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: countryregioncode\n    description: >\n      Two-letter country/region code (generally ISO 3166-1 alpha-2) identifying\n      the country/region. Usage notes: Non-null uppercase codes such as US, DE,\n      FR. Join to the country_region model on countryregioncode when you need\n      the country/region name or other attributes.\n    type: character varying\n    searchable: false\n    options: null\n  - name: currencycode\n    description: >\n      Three-letter ISO 4217 currency code representing the currency used by the\n      country/region. Includes legacy/defunct codes for historical contexts\n      (e.g., FRF, ESP, GRD, BEF) in addition to current codes such as EUR and\n      USD. Join to the currency model on currencycode for currency names and\n      related attributes.\n    type: character\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp of the last modification in the source reference table.\n      Primarily for lineage/auditing rather than analysis. In non-production\n      environments this value may be uniformly date-shifted by the staging\n      pipeline for consistency.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: country_region\n    source_col: countryregioncode\n    ref_col: country_region.countryregioncode\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each mapping to its country/region reference record for names and\n      attributes. Join on countryregioncode; expected cardinality is many-to-one\n      from this model to country_region.\n  - name: currency\n    source_col: currencycode\n    ref_col: currency.currencycode\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each mapping to its currency reference record. Join on currencycode;\n      expected cardinality is many-to-one from this model to currency.\nclarifications:\n  - >-\n    Confirm that countryregioncode adheres to ISO 3166-1 alpha-2 without\n    exceptions (e.g., 'GB' vs 'UK').\n  - >-\n    Are legacy currencies retained purely for historical completeness, or should\n    consumers default to the latest currency per country?\n  - >-\n    Is modifieddate intended only for auditing, or does it drive any effective\n    dating logic elsewhere?\n  - >-\n    Expected join coverage: should joins to country_region and currency be ≥ 95%\n    on the specified keys?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "41e912b0-8748-4979-a357-018a6ffe7349",
    "name": "customer_lifetime_orders",
    "databaseName": "postgres",
    "whenToUse": "Generated model for customer_lifetime_orders",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_lifetime_orders",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08115+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_lifetime_orders",
    "ymlFile": "name: customer_lifetime_orders\ndescription: >\n  Counts the total number of distinct sales orders placed by each customer\n  across all available history. Use this model when you need a customer-level\n  order count for segmentation (e.g., single-order vs repeat customers),\n  retention analyses, or to join alongside other customer KPIs. One row per\n  customer; computed as COUNT(DISTINCT salesOrderID) joined from\n  sales_order_header.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: customerid\n    description: >\n      Unique customer identifier. Join key to customer and sales_order_header.\n      Used to combine this metric with customer attributes or with order-level\n      facts. Usage notes: Non-null and unique in this model (one row per\n      customer). Pattern hints: Sequential/integer-style IDs.\n    type: integer\n    searchable: false\n    options: null\nmeasures:\n  - name: metric_lifetime_orders\n    description: >\n      Distinct count of orders per customer (COUNT(DISTINCT salesOrderID)). Unit\n      is count of orders. Includes all orders present in sales_order_header\n      regardless of status; returns/cancellations are not netted out here.\n      Right-skewed distribution (majority have 1–2 orders; long tail up to ~28).\n    type: bigint\nmetrics: []\nfilters:\n  - name: repeat_customers\n    expr: metric_lifetime_orders > 1\n    description: Customers with more than one lifetime order.\n    args: []\n  - name: single_order_customers\n    expr: metric_lifetime_orders = 1\n    description: Customers with exactly one lifetime order.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    cardinality: one-to-one\n    description: >\n      Customer attributes and profiles. Join on customerid; one row in this\n      model per customer. Enables enriching this metric with demographic/segment\n      fields.\n  - name: sales_order_header\n    source_col: customerid\n    ref_col: customerid\n    cardinality: one-to-many\n    description: >\n      Underlying orders that contribute to this metric. Join on customerid; a\n      single customer here maps to many sales orders in sales_order_header.\nclarifications:\n  - >-\n    Should canceled/voided orders in sales_order_header be included in the\n    lifetime order count?\n  - >-\n    Confirm whether customers with zero orders should be represented (currently\n    excluded due to inner join).\n  - >-\n    Any data coverage boundaries to note (e.g., initial load date) that affect\n    'lifetime'?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "18e24dd7-b1d7-4f69-879f-080ede8b1c7a",
    "name": "number_of_orders",
    "databaseName": "postgres",
    "whenToUse": "Generated model for number_of_orders",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.number_of_orders",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08135+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "number_of_orders",
    "ymlFile": "name: number_of_orders\ndescription: >\n  Monthly order volume aggregated from sales orders. Each row represents a time\n  bucket defined by year, quarter, and month extracted from\n  sales_order_header.orderDate, with the associated count of distinct orders in\n  that period. Use this model for tracking order volume trends, seasonal\n  patterns, MoM/YoY comparisons, and for joining to a calendar to add labels\n  (e.g., month names). Derived directly from sales_order_header without status\n  filters; see clarifications if cancellation handling matters.\ndimensions:\n  - name: year\n    description: >\n      Four-digit Gregorian calendar year extracted from\n      sales_order_header.orderDate. Usage notes: pairs with month/quarter for\n      time-series analysis and with date_dimension for month/quarter names.\n      Values typically span multiple years.\n    type: integer\n    searchable: false\n  - name: quarter\n    description: >\n      Calendar quarter (1–4) extracted from sales_order_header.orderDate. Usage\n      notes: useful for QoQ trend analysis and seasonal rollups.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n  - name: month\n    description: >\n      Calendar month number (1–12) extracted from sales_order_header.orderDate.\n      Usage notes: join to date_dimension for month names; combine with year for\n      unique month buckets. Not zero-padded.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n      - 5\n      - 6\n      - 7\n      - 8\n      - 9\n      - 10\n      - 11\n      - 12\nmeasures:\n  - name: metric_numberoforders\n    description: >\n      Count of distinct sales orders in the time bucket (orders). Computed as\n      COUNT(DISTINCT salesOrderID) over sales_order_header grouped by\n      year/quarter/month. Notes: includes all orders present in\n      sales_order_header with no explicit status filtering; confirm whether\n      canceled/invalid orders should be excluded.\n    type: integer\nmetrics:\n  - name: orders\n    expr: SUM(metric_numberoforders)\n    description: |\n      Total orders over the selected time frame.\n    args: []\nfilters:\n  - name: exclude_future_periods\n    expr: >\n      (year < EXTRACT(YEAR FROM CURRENT_DATE)) OR (year = EXTRACT(YEAR FROM\n      CURRENT_DATE) AND month <= EXTRACT(MONTH FROM CURRENT_DATE))\n    description: >\n      Excludes periods beyond the current calendar month to avoid partial/future\n      months in dashboards.\n    args: []\n  - name: last_12_months\n    expr: >\n      date_trunc('month', make_date(year, month, 1)) >= date_trunc('month',\n      CURRENT_DATE) - INTERVAL '12 months'\n    description: >\n      Keeps only the trailing 12 complete months relative to today. Useful for\n      rolling MoM trend analyses.\n    args: []\nrelationships:\n  - name: sales_order_header\n    source_col: year\n    ref_col: orderDate\n    type: left\n    cardinality: one-to-many\n    description: >\n      Source of the aggregation. Join on extracted time parts to analyze\n      underlying orders contributing to each bucket (e.g., for drill-through).\n      Example join keys: year = EXTRACT(YEAR FROM orderDate) and month =\n      EXTRACT(MONTH FROM orderDate).\n  - name: date_dimension\n    source_col: year\n    ref_col: year\n    type: left\n    cardinality: many-to-one\n    description: >\n      Calendar attributes and labels. Join on year and month to add names (e.g.,\n      monthname), quarter labels, and to fill gaps when building continuous time\n      series.\nclarifications:\n  - >-\n    Should canceled or invalid orders be excluded from the metric? If so, which\n    statuses?\n  - >-\n    Confirm the timezone of orderDate and whether extraction should apply a\n    specific timezone.\n  - >-\n    Do we need a date-spine-based variant to include zero-order months for\n    complete time series?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "9ef5d8a7-6df4-4a6b-9df9-9309e4f96283",
    "name": "customer_retention_rate",
    "databaseName": "postgres",
    "whenToUse": "A critical business health indicator that measures the company's ability to maintain customer relationships over time. This metric helps evaluate the effectiveness of customer satisfaction initiatives, assess product stickiness across different segments, and measure the impact of retention programs. Use this data to identify at-risk customer segments, quantify the success of loyalty programs, guide product improvement decisions, and develop targeted retention strategies that reduce churn and maximize customer lifetime value.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_retention_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081739+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_retention_rate",
    "ymlFile": "name: customer_retention_rate\ndescription: >\n  Percentage of customers who return to purchase again. This model provides an\n  all-time aggregate retention rate computed from sales_order_header: number of\n  customers with more than one order divided by total distinct customers,\n  expressed as a percentage. Use it to track overall customer retention health.\n  There are no time grain or customer keys in this model; it is a single\n  aggregated metric. If you need cohort or time-sliced analysis, consider\n  building a time-grained variant.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: metric_retentionrate\n    description: >\n      Overall customer retention rate as a percentage. Computed as:\n      count(distinct customers with >1 order) / count(distinct customers) * 100.\n      Unit: percent. Derived from sales_order_header without filtering for order\n      status. Aggregation: value is already aggregated at model level\n      (single-row).\n    type: double precision\nmetrics: []\nfilters: []\nrelationships: []\nclarifications:\n  - >-\n    Does this metric include canceled or invalid orders from sales_order_header,\n    or should those be excluded?\n  - >-\n    Should retention be calculated over a specific window (e.g., 30/90 days,\n    monthly cohorts) rather than all-time?\n  - >-\n    If time-sliced reporting is required, should this model include a date grain\n    (e.g., year/month) to support trending?\n  - >-\n    Confirm that 'customer' is defined as distinct\n    sales_order_header.customerID. Are guest or anonymous orders possible in\n    this dataset?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "8918407e-8bf1-4c0e-9c0e-50099d5a9ff3",
    "name": "customer_period_clv",
    "databaseName": "postgres",
    "whenToUse": "Generated model for customer_period_clv",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_period_clv",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081513+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_period_clv",
    "ymlFile": "name: customer_period_clv\ndescription: >\n  Customer period CLV provides the revenue contributed by each customer within a\n  specific time period, aggregated at year and quarter. Use this to analyze\n  customer value trends over time, compare cohorts, and segment by customer\n  attributes. Values are derived from SalesOrderDetail.lineTotal summed per\n  customer and period using the order date from SalesOrderHeader; amounts\n  reflect line-level net values after discounts and exclude taxes and freight.\n  Typical usage includes filtering by year/quarter and joining to the customer\n  model for segmentation.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: customerid\n    description: >\n      Customer identifier. Sequential integer key from the sales domain. Join to\n      the customer model to access attributes and segments. One row per customer\n      per year-quarter in this model.\n    type: integer\n    searchable: false\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderDate for the associated\n      orders. Useful for time trend analysis and cohorting.\n    type: integer\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: >\n      Calendar quarter (1–4) extracted from SalesOrderHeader.orderDate for the\n      associated orders. Combine with year for period analysis.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_period_clv\n    description: >\n      Sum of SalesOrderDetail.lineTotal for all order lines belonging to a\n      customer within the given year and quarter. Represents net line amounts\n      after discounts (based on UnitPrice and UnitPriceDiscount); excludes taxes\n      and freight.\n    type: numeric\nmetrics: []\nfilters:\n  - name: positive_period_clv\n    expr: metric_period_clv > 0\n    description: Keep only customer-period records with positive revenue.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Relates each customer-period record to the base customer entity for\n      segmentation. Expect many customer_period_clv rows per customer (across\n      periods).\n  - name: sales_order_header\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Connects to order headers by customer for drill-through and enrichment\n      (e.g., order channel, territory). Multiple orders per customer and period\n      are possible.\nclarifications:\n  - >-\n    Confirm whether amounts are single-currency or multi-currency and whether\n    any normalization is applied.\n  - >-\n    Do returns/cancellations adjust SalesOrderDetail.lineTotal, or should they\n    be excluded separately?\n  - >-\n    Validate join coverage between customer_period_clv.customerid and\n    customer.customerid (expected ~100%).\n  - >-\n    Is a relationship to date_dimension desired, and if so, should a date key be\n    added to support it?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "923881ca-ff34-4e97-bf9c-4b3c5e4beb46",
    "name": "customer_all_time_clv",
    "databaseName": "postgres",
    "whenToUse": "Metric model that calculates the total revenue generated by each customer over their entire history",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_all_time_clv",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081711+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_all_time_clv",
    "ymlFile": "name: customer_all_time_clv\ndescription: >\n  All-time customer lifetime value per customer. Sums all SalesOrderDetail line\n  totals across a customer's entire order history to quantify total revenue\n  attributable to that customer. Useful for value-based segmentation,\n  top-customer ranking, and cohort analyses when a single cumulative CLV is\n  sufficient. Notes: includes line-level discounts; excludes taxes and freight\n  (those live in SalesOrderHeader). No time breakdowns are included. Pattern\n  highlights: one row per customer; values are right‑skewed with a long tail and\n  some very large outliers (likely store/wholesale accounts).\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: customerid\n    description: >\n      Primary identifier for the customer. One row per customer in this model;\n      join to the Customer model on customerid to enrich with customer\n      attributes and filters. Typically a sequential integer in this dataset.\n    type: integer\n  - name: metric_clv_all_time\n    description: >\n      All-time customer lifetime value. Calculated as\n      SUM(SalesOrderDetail.lineTotal) across all orders for the customer.\n      Includes line-level discounts; excludes taxes and freight. Monetary units\n      are in the source system's currency (commonly USD in AdventureWorks).\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    cardinality: one-to-one\n    description: >\n      Join to enrich CLV with customer attributes and filters. One-to-one at\n      this layer (this model has one row per customer). Join on customerid;\n      expected coverage ~100%.\nclarifications:\n  - >-\n    Confirm currency for lineTotal/CLV (assumed USD); any multi-currency\n    conversions applied?\n  - >-\n    Does metric_clv_all_time exclude taxes and freight as intended\n    (lineTotal-only)?\n  - >-\n    Are cancellations/returns present in source and, if so, how are they\n    reflected in lineTotal?\n  - >-\n    Validate one row per customer and ~100% join coverage to customer on\n    customerid.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "fb648c2c-26f4-4c2b-bc29-34032bb17a3d",
    "name": "employee_department_history",
    "databaseName": "postgres",
    "whenToUse": "Powerful model for tracking organizational evolution and workforce movement. Supports detailed analysis of departmental transfers, career progression paths, and organizational restructuring. Valuable for monitoring internal mobility rates, department growth patterns, and talent distribution across the organization. Enables HR teams to identify career development opportunities, optimize talent allocation, and evaluate the impact of organizational changes. Essential for workforce planning, succession management, and understanding historical department staffing trends over time.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.employee_department_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082704+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "employee_department_history",
    "ymlFile": "name: employee_department_history\ndescription: >\n  Historical record of employee department assignments and shift schedules. Each\n  row represents a single assignment period for an employee, defined by\n  startdate and enddate (null enddate indicates the current assignment). Use\n  this model for tenure analysis, transfers, headcount by department/shift, and\n  point-in-time reporting. Note: date fields are adjusted to a consistent\n  reference \"today\" within this project to facilitate relative-time analyses.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: departmentid\n    description: >\n      Department identifier for the employee's assignment during this period.\n      Join to department on departmentid for the human-readable department name.\n      Low-cardinality enum; expected values range from 1 to 16.\n    type: smallint\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n      - 5\n      - 6\n      - 7\n      - 8\n      - 9\n      - 10\n      - 11\n      - 12\n      - 13\n      - 14\n      - 15\n      - 16\n  - name: shiftid\n    description: >\n      Shift identifier for the employee during this assignment period. Join to\n      shift on shiftid to access the shift name and start/end times. Enum values\n      are 1, 2, and 3.\n    type: smallint\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n  - name: startdate\n    description: >\n      Date the assignment period begins for the employee. Use with enddate to\n      construct effective-dated logic (e.g., active on a given day). When\n      slicing by a specific date, include rows where startdate <= date and\n      (enddate is null or enddate > date).\n    type: date\n    searchable: false\n    options: null\n  - name: enddate\n    description: >\n      Date the assignment period ends for the employee. Null indicates the\n      assignment is currently active. Non-null values close a prior assignment\n      period.\n    type: date\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp the record was last updated in the source system; not an\n      effective-dating field.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: businessentityid\n    description: >\n      Employee identifier (BusinessEntityID). Use to join to employee (and\n      business_entity) models. Not unique in this table because employees may\n      have multiple assignment periods. Typical aggregations include counts or\n      count distinct for headcount.\n    type: integer\nmetrics: []\nfilters:\n  - name: current_assignments\n    expr: enddate IS NULL\n    description: Rows representing currently active assignments.\n    args: []\n  - name: historical_assignments\n    expr: enddate IS NOT NULL\n    description: Rows representing closed/ended assignment periods.\n    args: []\nrelationships:\n  - name: employee\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Each assignment period belongs to exactly one employee. Join on\n      businessentityid; many history rows per employee.\n  - name: department\n    source_col: departmentid\n    ref_col: departmentid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Department for the assignment period. Join on departmentid; many history\n      rows can map to a single department.\n  - name: shift\n    source_col: shiftid\n    ref_col: shiftid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Work shift for the assignment period. Join on shiftid to retrieve shift\n      name and hours.\nclarifications:\n  - Confirm that assignment periods are non-overlapping per businessentityid.\n  - Are concurrent shifts possible for a single employee and date range?\n  - >-\n    Validate join coverage to employee/business_entity on businessentityid is ≥\n    95–100%.\n  - >-\n    Is enddate always null for current assignments, or can future-dated enddates\n    appear?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "25b7638c-5b33-4d10-a27e-8b292d2a85b7",
    "name": "combined_basket_value",
    "databaseName": "postgres",
    "whenToUse": "Metric model that measures the average revenue when products from two categories are purchased together",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.combined_basket_value",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081235+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "combined_basket_value",
    "ymlFile": "name: combined_basket_value\ndescription: >\n  CombinedBasketValue shows the average revenue per order when products from two\n  distinct product categories are purchased together in the same sales order.\n  Each row represents an undirected category pair (alphabetically ordered to\n  avoid duplicates), along with the number of orders containing both categories\n  and the average combined revenue of those orders. Revenue is computed from\n  sales order line totals (net of line-level discounts); taxes and freight are\n  not included.\n\n  Typical usage: identify complementary categories frequently bought together\n  and their revenue impact; rank top pairs by combined revenue to inform\n  cross-sell strategies, merchandising, and promotional bundles. Join\n  category_1/category_2 to product_category by name for category-level\n  attributes.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: category_1\n    description: >\n      First category name in the pair. Pairs are alphabetically ordered\n      (category_1 < category_2), so this does not imply directionality. Values\n      align with product_category.name.\n    type: character varying\n    searchable: false\n    options:\n      - Accessories\n      - Bikes\n      - Clothing\n      - Components\n  - name: category_2\n    description: >\n      Second category name in the pair. Pairs are alphabetically ordered\n      (category_1 < category_2), so this does not imply directionality. Values\n      align with product_category.name.\n    type: character varying\n    searchable: false\n    options:\n      - Accessories\n      - Bikes\n      - Clothing\n      - Components\nmeasures:\n  - name: orders_with_both\n    description: >\n      Count of distinct sales orders that contain at least one item from both\n      categories in the pair. Unit: orders. Derived as COUNT(DISTINCT\n      salesOrderID) over joined line items for the two categories.\n    type: bigint\n  - name: metric_combinedbasketvalue\n    description: >\n      Average combined revenue per order for the category pair. Calculated as\n      SUM(line totals from both categories) divided by orders_with_both. Based\n      on sales_order_detail.lineTotal, which incorporates UnitPriceDiscount;\n      excludes header-level taxes and freight.\n    type: numeric\n  - name: value_rank\n    description: >\n      Rank of the category pair by total combined revenue (descending). Lower is\n      better (1 = highest combined revenue). Note: Ranking uses total combined\n      revenue, not the average value.\n    type: bigint\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_category\n    source_col: category_1\n    ref_col: name\n    type: left\n    cardinality: many-to-one\n    description: >\n      Category lookup for category_1. Use to enrich with category-level\n      attributes. Many pairs map to one category row.\n  - name: product_category\n    source_col: category_2\n    ref_col: name\n    type: left\n    cardinality: many-to-one\n    description: >\n      Category lookup for category_2. Use to enrich with category-level\n      attributes. Many pairs map to one category row.\nclarifications:\n  - >-\n    Confirm reporting currency (assumed store currency; typically USD in\n    AdventureWorks).\n  - Intentional to exclude taxes and freight from revenue (lineTotal only)?\n  - >-\n    Should directionality ever be considered (e.g., category A leading to B), or\n    remain undirected as implemented?\n  - >-\n    Is there a desired timeframe segmentation (e.g., by month/quarter), or is\n    this intended to be all-time?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "788a7967-137a-4f81-9072-38f49e1db2ad",
    "name": "sales_growth_rate",
    "databaseName": "postgres",
    "whenToUse": null,
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_growth_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-09-19 19:50:55.389844+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_growth_rate",
    "ymlFile": "name: sales_growth_rate\ndescription: >\n  Comprehensive sales growth rate analysis providing year-over-year (YoY),\n  quarter-over-quarter  (QoQ), and month-over-month (MoM) growth calculations.\n  This metric enables multi-dimensional  trend analysis of sales performance\n  across different time horizons.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date for time-based growth calculations\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: sales_amount\n    description: >-\n      Total sales amount for the current period used as baseline for growth rate\n      calculations\n    type: numeric\n  - name: metric_yoy_salesgrowthrate\n    description: >-\n      Year-over-year growth rate calculated as percentage change in sales\n      compared to the same period in the previous year\n    type: numeric\n  - name: metric_qoq_salesgrowthrate\n    description: >-\n      Quarter-over-quarter growth rate calculated as percentage change in sales\n      compared to the previous quarter\n    type: numeric\n  - name: metric_mom_salesgrowthrate\n    description: >-\n      Month-over-month growth rate calculated as percentage change in sales\n      compared to the previous month\n    type: numeric\n  - name: metric_salesgrowthrate\n    description: General sales growth rate metric providing overall growth trend analysis\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "de2569df-2477-47df-bb09-06eb3768a316",
    "name": "employee_pay_history",
    "databaseName": "postgres",
    "whenToUse": "Essential model for compensation analysis and payroll management. Enables detailed salary trend monitoring, compensation benchmarking, and budget forecasting. Valuable for identifying pay equity issues, analyzing compensation adjustments over time, and planning strategic payroll changes. Supports HR and finance teams in evaluating compensation competitiveness, managing pay scales, and ensuring compliance with compensation policies. Critical for data-driven decisions regarding employee retention strategies and labor cost optimization.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.employee_pay_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082841+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "employee_pay_history",
    "ymlFile": "name: employee_pay_history\ndescription: >\n  Historical record of employee pay rate changes sourced from\n  HumanResources.EmployeePayHistory. Use it to analyze compensation changes over\n  time, understand current vs prior rates, and join to employee attributes for\n  HR analytics. Typical usage patterns include selecting the latest rate per\n  employee for “current compensation” views and trending rate changes by date.\n  Pattern highlights: rateChangeDate clusters around late 2020–2023 with a\n  steady tail; modifiedDate is mostly the current ETL date due to pipeline\n  updates. Values are right‑skewed (many rates between roughly 9–25 with a long\n  tail to higher amounts). Dates in this project are shifted to keep the data\n  “current” for demos, so interpret recency windows accordingly.\ndimensions:\n  - name: businessentityid\n    description: >\n      Employee identifier; join key to the employee model. Multiple rows per\n      employee represent distinct pay changes over time.\n    type: integer\n    searchable: false\n  - name: ratechangedate\n    description: >\n      Timestamp when the employee’s pay rate became effective. Use this to order\n      changes and to select the latest rate per employee (e.g., for current\n      compensation). Pattern: concentrated around 2020–2023.\n    type: timestamp\n    searchable: false\n  - name: payfrequency\n    description: >\n      Code indicating the pay schedule. Common values are 1 and 2. In\n      AdventureWorks conventions these typically distinguish hourly vs salaried\n      schedules. Verify mapping in your environment.\n    type: smallint\n    searchable: false\n    options:\n      - value: 1\n        description: Hourly schedule (typical)\n      - value: 2\n        description: Salaried schedule (typical)\n  - name: modifieddate\n    description: >\n      Timestamp when this record was last updated in the source. Often reflects\n      the ETL update date rather than the original change time.\n    type: timestamp\n    searchable: false\nmeasures:\n  - name: rate\n    description: >\n      Pay rate amount. In AdventureWorks this is commonly the hourly rate for\n      hourly employees; salaried employees may also be represented with an\n      equivalent rate. Units are currency per hour. Expect a right‑skewed\n      distribution with a long tail.\n    type: numeric\nmetrics: []\nfilters:\n  - name: latest_rate_per_employee\n    expr: rateChangeDate = MAX(rateChangeDate) OVER (PARTITION BY businessEntityID)\n    description: >\n      Select only the most recent (current) rate row per employee based on\n      rateChangeDate.\n    args: []\nrelationships:\n  - name: employee\n    source_col: businessentityid\n    ref_col: businessentityid\n    cardinality: many-to-one\n    description: >\n      Links each pay history row to its employee. Many pay history rows map to\n      one employee.\nclarifications:\n  - >-\n    Confirm payfrequency code mapping: does 1 represent hourly and 2 represent\n    salaried in this environment?\n  - >-\n    For salaried employees, is rate stored as an hourly equivalent or another\n    unit?\n  - >-\n    Is modifiedDate expected to align with ETL load dates (mostly current)\n    rather than event-time?\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "447c1499-b445-4760-9ebb-ed7691a5530c",
    "name": "gross_profit_margin",
    "databaseName": "postgres",
    "whenToUse": "A key profitability metric that measures the percentage of revenue retained after accounting for cost of goods sold. This metric helps assess pricing strategy effectiveness, cost control efficiency, and overall product profitability. Use it to identify high-margin products for promotion, detect margin compression, and make data-driven pricing decisions.\\n",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.gross_profit_margin",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081217+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "gross_profit_margin",
    "ymlFile": "name: gross_profit_margin\ndescription: >\n  Product-level quarterly gross profit margin. Useful for tracking profitability\n  trends by product across time, comparing categories, and identifying outliers\n  where discounts or costs drive margins negative. Margin is based on net sales\n  (after line-level discounts) versus product standard cost and is grouped by\n  product and calendar quarter/year from order dates.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productid\n    description: >\n      Product identifier from the product catalog; joins to the product model.\n      Usage notes: Use this to relate margin results back to detailed product\n      attributes. One row per product per year-quarter in this model.\n    type: integer\n    searchable: false\n  - name: product_name\n    description: >\n      Human-readable product name sourced from product.name. Useful for\n      reporting, grouping, and search.\n    type: character varying\n    searchable: true\n  - name: year\n    description: >\n      Calendar year extracted from the sales order date. Current values include\n      2022–2025. When doing YoY analysis, consider filtering to complete years.\n    type: integer\n    searchable: false\n    options:\n      - 2022\n      - 2023\n      - 2024\n      - 2025\n  - name: quarter\n    description: |\n      Calendar quarter (1–4) extracted from the sales order date.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\nmeasures:\n  - name: metric_grossprofitmargin\n    description: >\n      Gross profit margin in percentage points for the product-year-quarter.\n      Formula: (SUM(unit_price × order_qty × (1 − unit_price_discount)) −\n      SUM(standard_cost × order_qty)) ÷ SUM(unit_price × order_qty × (1 −\n      unit_price_discount)) × 100. Includes line-level discounts via\n      unit_price_discount and uses product standard cost as the cost basis. Null\n      behavior: returns NULL when net revenue for the period equals 0. Typical\n      range observed: approximately -80 to +65, with negatives possible when\n      costs exceed discounted revenue.\n    type: number\nmetrics: []\nfilters:\n  - name: positive_margin\n    expr: metric_grossprofitmargin > 0\n    description: Select only product-quarters with margin above zero.\n    args: []\n  - name: non_null_margin\n    expr: metric_grossprofitmargin IS NOT NULL\n    description: Exclude rows where margin is NULL due to zero net revenue.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Relates margin results to the product dimension for attributes and\n      categorization. One margin row (per product per quarter) maps to exactly\n      one product row.\nclarifications:\n  - >-\n    Should this metric be interpreted strictly as percentage points (0–100\n    scale), or ever normalized to 0–1 in downstream tools?\n  - >-\n    Year 2025 appears partial in current data; for trend analyses, should we\n    recommend filtering to complete years/quarters?\n  - >-\n    Confirm that product standard cost is the intended cost basis for margin vs\n    an average or actual cost measure.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "6f7d2767-5dcd-4daa-86cd-246221bdf7d0",
    "name": "product_model_product_description_culture",
    "databaseName": "postgres",
    "whenToUse": "Generated model for product_model_product_description_culture",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_model_product_description_culture",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081974+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_model_product_description_culture",
    "ymlFile": "name: product_model_product_description_culture\ndescription: >\n  Junction table mapping product models to their localized product descriptions\n  across cultures/languages. Use this to retrieve the correct description for a\n  given product model and culture. Typical usage is to join to product_model and\n  product_description, filtered by a desired culture (e.g., \"en    \"). Note that\n  culture codes are stored as fixed-width CHAR values and may include\n  right-padding spaces.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productmodelid\n    description: >\n      Foreign key to product_model. Identifies which product model the\n      description belongs to. Multiple rows per model exist across different\n      cultures.\n    type: integer\n    searchable: false\n  - name: productdescriptionid\n    description: >\n      Foreign key to product_description. Identifies the specific description\n      record linked to the model and culture.\n    type: integer\n    searchable: false\n  - name: cultureid\n    description: >\n      Culture/language code for the description. Stored as CHAR and frequently\n      right-padded with spaces. Values observed: ar, en, fr, he, th, zh-cht.\n      When joining or filtering, be mindful of padding (TRIM as needed) unless\n      joining to the culture model which uses the same padded format.\n    type: character\n    searchable: false\n    options:\n      - 'ar    '\n      - 'en    '\n      - 'fr    '\n      - 'he    '\n      - 'th    '\n      - zh-cht\n  - name: modifieddate\n    description: >\n      Source last-modified timestamp for the link record. In current data all\n      rows share the same value; primarily useful for auditing/lineage rather\n      than analysis.\n    type: timestamp without time zone\n    searchable: false\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_model\n    source_col: productmodelid\n    ref_col: productmodelid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each description-in-culture to its product model. One row here\n      references exactly one product_model; many rows can reference the same\n      model across different cultures.\n  - name: product_description\n    source_col: productdescriptionid\n    ref_col: productdescriptionid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each row to the canonical product description record. One row here\n      references exactly one product_description; a given description may be\n      reused across multiple models/cultures depending on source rules.\n  - name: culture\n    source_col: cultureid\n    ref_col: cultureid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links to the culture lookup for name/metadata on each culture code. One\n      row here references exactly one culture; many rows may share the same\n      culture.\nclarifications:\n  - >-\n    Confirm whether cultureid is consistently padded across related models or if\n    TRIM is recommended in joins.\n  - >-\n    Is productdescriptionid expected to be unique per row in this table, or\n    should it be many-to-one with reuse across models/cultures?\n  - >-\n    Does modifieddate reflect source system last modified or an ETL load\n    timestamp in this environment?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "05879088-8021-4dd9-8da0-85b2cd1d3754",
    "name": "sales_tax_rate",
    "databaseName": "postgres",
    "whenToUse": "Sales tax rate model that helps with tax compliance, regional pricing strategies, and financial planning across diverse tax jurisdictions. This model provides visibility into varying tax rates by location, enabling accurate tax calculations for regulatory compliance, optimization of pricing strategies based on regional tax implications, and comprehensive financial planning that accounts for tax variations across different markets.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_tax_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082158+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_tax_rate",
    "ymlFile": "name: sales_tax_rate\ndescription: >\n  Lookup of sales/use/other tax rates by state/province and tax type. Use it to\n  reference the applicable tax rate for a given jurisdiction, analyze rate\n  levels across regions, or filter by tax category. The model is a thin select\n  from the source Sales.SalesTaxRate via staging, with date shifting applied to\n  modifieddate. Multiple tax types may exist per state/province; this is not a\n  transactional fact table.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: taxtype\n    description: >\n      Categorical code for the tax type/category within the jurisdiction. Values\n      observed are {1, 2, 3}. Usage notes: Multiple tax types can exist per\n      state/province. See clarifications for exact code meanings.\n    type: smallint\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n  - name: name\n    description: >\n      Human-readable label for the tax rate (e.g., \"Texas State Sales Tax\",\n      \"Canadian GST\", \"Germany Output Tax\"). Useful for display/labels; not\n      guaranteed to be unique.\n    type: character varying\n    searchable: true\n  - name: rowguid\n    description: >\n      UUID identifier for the row (technical lineage/audit key). Typically not\n      used in analysis.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: >\n      Source last-modified timestamp. Populated via staging date shifting; in\n      this dataset it is uniform and should not be interpreted as the effective\n      date of a tax rate.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: salestaxrateid\n    description: >\n      Primary key for the sales tax rate record. Use for uniqueness or\n      troubleshooting; not intended for aggregation.\n    type: integer\n  - name: stateprovinceid\n    description: >\n      Foreign key to state_province.stateprovinceid identifying the\n      jurisdiction. Multiple tax types can exist per state/province.\n    type: integer\n  - name: taxrate\n    description: >\n      Tax rate expressed in percentage points (e.g., 7 = 7%). Do not sum. For\n      calculations, convert to a fraction by dividing by 100.\n    type: numeric\nmetrics: []\nfilters:\n  - name: us_only\n    expr: state_province.countryregioncode = 'US'\n    description: >\n      Limit to tax rates where the related state/province is in the United\n      States.\n    args: []\nrelationships:\n  - name: state_province\n    source_col: stateprovinceid\n    ref_col: stateprovinceid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Each tax rate belongs to a specific state or province. Join to enrich with\n      geography attributes such as countryregioncode or state/province name.\n      Expect many-to-one coverage from sales_tax_rate to state_province.\nclarifications:\n  - >-\n    Confirm exact semantics of taxtype codes: what do 1, 2, and 3 represent in\n    this dataset?\n  - >-\n    Is taxrate always stored as percentage points (0–100), not as a fraction\n    (0–1)?\n  - >-\n    modifieddate is populated via date shifting in staging; should analysts\n    treat it as informational only?\n  - >-\n    Validate relationship coverage with state_province on stateprovinceid >=\n    95%.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "b30e9848-4831-407e-9856-2711079373f5",
    "name": "customer_last_purchase_date",
    "databaseName": "postgres",
    "whenToUse": "Generated model for customer_last_purchase_date",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer_last_purchase_date",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081502+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer_last_purchase_date",
    "ymlFile": "name: customer_last_purchase_date\ndescription: >\n  One row per customer capturing the most recent purchase date based on sales\n  order headers. Use this model to analyze customer recency (e.g., active vs.\n  lapsed), build cohorts, and create retention segments. It contains the\n  customer identifier and the timestamp of the last recorded order. Usage notes:\n  Customers without any orders are excluded (inner join to sales_order_header).\n  The date reflects the order header orderDate (not shipDate) and includes a\n  time component; values are stored without a timezone in the warehouse but\n  represent UTC timestamps.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: metric_last_purchase_date\n    description: >\n      Timestamp of the most recent order placed by the customer, derived as\n      MAX(orderDate) from sales_order_header. Represents when the order was\n      placed (header-level), not when it shipped. Includes a time component;\n      stored as a timestamp without time zone though values represent UTC.\n      Typical usage: recency filters (e.g., last 90 days/12 months), cohorting\n      by last purchase month (use date_trunc), and churn detection.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: customerid\n    description: >\n      Numeric identifier for the customer. Join key to customer and\n      sales_order_header. One row per customer that has at least one order in\n      sales_order_header (customers with no orders are not present).\n    type: integer\nmetrics: []\nfilters:\n  - name: recent_12_months\n    expr: metric_last_purchase_date >= (CURRENT_DATE - INTERVAL '12 months')\n    description: Customers whose last purchase date is within the last 12 months.\n    args: []\n  - name: recent_90_days\n    expr: metric_last_purchase_date >= (CURRENT_DATE - INTERVAL '90 days')\n    description: Customers whose last purchase date is within the last 90 days.\n    args: []\nrelationships:\n  - name: customer\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Customer attributes and segments. Join on customerid. This model has one\n      row per customer that has at least one order; when combined with the full\n      customer table, coverage will be less than 100% (customers without orders\n      are absent). Use this relationship to enrich with demographics/segments.\n  - name: sales_order_header\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Underlying sales headers from which the last purchase is derived. Join on\n      customerid to explore order history. One last-purchase record relates to\n      many sales orders for that customer.\nclarifications:\n  - >-\n    Confirm that orderDate semantics should be used (vs. shipDate or\n    invoiceDate) for 'last purchase'.\n  - >-\n    Confirm timestamps are intended to be interpreted in UTC and stored as\n    timestamp without time zone.\n  - >-\n    Coverage: This model excludes customers with no orders due to the inner\n    join; is that expected for downstream usage?\n  - >-\n    Do cancellation/return statuses in sales_order_header affect inclusion of\n    orders in 'last purchase'?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "3000431c-0061-4830-8a5c-6c0d4e695c92",
    "name": "sales_by_product_category",
    "databaseName": "postgres",
    "whenToUse": "Generated model for sales_by_product_category",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_by_product_category",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081337+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_by_product_category",
    "ymlFile": "name: sales_by_product_category\ndescription: >\n  Category-level sales revenue rollup. Each row represents a product category\n  and the total revenue contributed by all sales order lines whose products roll\n  up to that category (via product → product_subcategory → product_category).\n  Useful for ranking categories, tracking category mix, and creating\n  category-level dashboards. Values reflect the same units/currency as\n  sales_order_detail.lineTotal.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: productcategoryid\n    description: >\n      Integer identifier of the product category from product_category. Use as\n      the join key to enrich with category attributes or to group by category.\n      Stable across the AdventureWorks domain.\n    type: integer\n    searchable: false\n    options: null\n  - name: category_name\n    description: >\n      Human-readable product category name. Controlled set in AdventureWorks\n      typically includes Bikes, Components, Clothing, and Accessories. Helpful\n      for labels and grouping; no nulls observed in profiling.\n    type: character varying\n    searchable: true\n    options:\n      - Bikes\n      - Components\n      - Clothing\n      - Accessories\nmeasures:\n  - name: metric_salesbycategory\n    description: >\n      Total sales revenue for the category. Calculated as\n      SUM(sales_order_detail.lineTotal) over all order lines for products that\n      map to this category through product → product_subcategory →\n      product_category. In AdventureWorks, lineTotal equals OrderQty × UnitPrice\n      × (1 − UnitPriceDiscount); this measure inherits the same currency/units.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_category\n    source_col: productcategoryid\n    ref_col: productcategoryid\n    cardinality: many-to-one\n    description: >\n      Join to the product category dimension to access additional attributes\n      (e.g., modifieddate). Each row in this model maps to exactly one\n      product_category row on productcategoryid (complete coverage by\n      construction).\nclarifications:\n  - >-\n    Confirm the currency and whether sales_order_detail.lineTotal excludes tax\n    and freight in this warehouse.\n  - >-\n    Is the category list expected to remain the four standard AdventureWorks\n    categories, or can new categories appear over time?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "65875b4d-0d1c-4640-b813-eea2fdc80229",
    "name": "country_region",
    "databaseName": "postgres",
    "whenToUse": "Geographic reference model for global operations and analytics. Essential for international sales analysis, regional market planning, supply chain optimization, and tax compliance. Supports multi-national reporting, territory management, and global expansion strategy.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.country_region",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.08296+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "country_region",
    "ymlFile": "name: country_region\ndescription: >\n  Reference table of countries/regions with a short uppercase code and display\n  name. Use it to standardize country attribution and to join downstream models\n  that carry a country/region code (for example, state_province,\n  sales_territory, and country_region_currency). Typical usage includes grouping\n  and filtering by country, enriching records with a human-readable name, and\n  building rollups. Note that modifieddate reflects the source system's\n  last-modified timestamp and may not indicate business-change timing.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: countryregioncode\n    description: >\n      Country/Region code used as the primary key for this model and the join\n      key to related models. Values are short uppercase codes (commonly aligned\n      to ISO-style country codes, e.g., US, FR, ES), with occasional\n      deprecated/legacy codes. Use this for joins to state_province,\n      sales_territory, and country_region_currency.\n    type: character varying\n    searchable: false\n    options: null\n  - name: name\n    description: >\n      Human-readable country/region name suitable for display and grouping\n      (e.g., \"United States\", \"France\"). Use when presenting or aggregating by\n      country. Names are unique at this layer.\n    type: character varying\n    searchable: true\n    options: null\n  - name: modifieddate\n    description: >\n      Source \"last modified\" timestamp for the country/region record. Useful for\n      data freshness checks; not intended for business event sequencing. Appears\n      uniform for the current load.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: state_province\n    source_col: countryregioncode\n    ref_col: countryregioncode\n    type: left\n    cardinality: one-to-many\n    description: >\n      Countries/regions to their administrative subdivisions. Join on\n      countryregioncode; one country/region maps to many state/province records\n      where applicable.\n  - name: sales_territory\n    source_col: countryregioncode\n    ref_col: countryregioncode\n    type: left\n    cardinality: one-to-many\n    description: >\n      Countries/regions to sales territories configured for reporting and quota\n      management. Join on countryregioncode; one country/region may map to\n      multiple sales territories depending on GTM setup.\n  - name: country_region_currency\n    source_col: countryregioncode\n    ref_col: countryregioncode\n    type: left\n    cardinality: one-to-many\n    description: >\n      Countries/regions to their currency mappings. Join on countryregioncode; a\n      country/region may have one or more currency associations in this mapping\n      table.\nclarifications:\n  - >-\n    Confirm that countryregioncode strictly follows ISO 3166-1 alpha-2 (with any\n    known exceptions like deprecated codes such as \"CS\").\n  - >-\n    Validate that modifieddate is expected to be uniform for all rows in the\n    current dataset and represents the source snapshot time.\n  - >-\n    Confirm expected relationship coverage with state_province and\n    sales_territory (should be ≥95% on countryregioncode?).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "c7b08869-d967-46c8-8928-2cd1dd5cb51d",
    "name": "sales_reason",
    "databaseName": "postgres",
    "whenToUse": "Purchase motivation analysis model that captures why customers buy products. Essential for understanding buying triggers, marketing campaign effectiveness, and sales strategy refinement. Supports customer behavior analysis, promotional planning, and sales pitch optimization by revealing the most influential factors in purchasing decisions.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_reason",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082378+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_reason",
    "ymlFile": "name: sales_reason\ndescription: >\n  Dimension of reasons attached to sales orders. Use this model to segment and\n  explain why an order was placed (e.g., price, quality, advertising). Contains\n  a small, standardized set of reason names grouped into higher-level categories\n  (reasonType) such as Marketing, Promotion, and Other. Typical usage: join\n  through the sales_order_header_sales_reason bridge to slice sales performance\n  by reason or reason type, or to build cohorts based on purchase motivations.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable label for the sales reason (e.g., Price, Quality, Magazine\n      Advertisement). Usage notes: Low-cardinality set of standardized values\n      intended for segmentation and reporting. Join via the bridge to analyze\n      orders by specific reasons. Avoid free-text search; treat as an enum.\n    type: character varying\n    searchable: false\n    options:\n      - Price\n      - Quality\n      - Review\n      - Manufacturer\n      - Demo Event\n      - On Promotion\n      - Sponsorship\n      - Magazine Advertisement\n      - Television  Advertisement\n      - Other\n  - name: reasontype\n    description: >\n      High-level category for the reason. Useful for rollups and filters (e.g.,\n      compare Marketing vs Promotion vs Other). Values come from the source\n      system's controlled list.\n    type: character varying\n    searchable: false\n    options:\n      - Marketing\n      - Promotion\n      - Other\n  - name: modifieddate\n    description: >\n      Source system last modified timestamp for this reason record. Stored\n      without timezone. Usage notes: In this dataset the value appears constant\n      across rows; in practice, treat as an audit field rather than for\n      time-series analysis.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: salesreasonid\n    description: >\n      Unique identifier for the sales reason. Use as the join key to\n      sales_order_header_sales_reason; not meaningful to aggregate by itself.\n    type: integer\nmetrics: []\nfilters:\n  - name: is_marketing_reason\n    expr: LOWER(reasontype) = 'marketing'\n    description: Include only Marketing-related reasons.\n    args: []\n  - name: is_promotion_reason\n    expr: LOWER(reasontype) = 'promotion'\n    description: Include only Promotion-related reasons.\n    args: []\n  - name: is_other_reason\n    expr: LOWER(reasontype) = 'other'\n    description: Include only reasons categorized as Other.\n    args: []\nrelationships:\n  - name: sales_order_header_sales_reason\n    source_col: salesreasonid\n    ref_col: salesreasonid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Bridge table mapping sales orders to sales reasons. Join on salesreasonid\n      to analyze order volumes and revenue by reason.\nclarifications:\n  - >-\n    Is the double space in 'Television  Advertisement' intentional or should it\n    be normalized to a single space?\n  - >-\n    Should the set of reason 'name' values be treated as closed/fixed, or can\n    new values appear over time?\n  - >-\n    Is modifieddate expected to vary across records in production, or is it a\n    one-time load timestamp here? Any timezone normalization expectations?\n  - >-\n    Confirm relationship coverage with sales_order_header_sales_reason ≥ 95% on\n    salesreasonid (fk) = salesreasonid (pk).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "3c75d5f3-1cdb-4975-b64b-bc01747e5454",
    "name": "sales_person_quota_history",
    "databaseName": "postgres",
    "whenToUse": "Generated model for sales_person_quota_history",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.sales_person_quota_history",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082361+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "sales_person_quota_history",
    "ymlFile": "name: sales_person_quota_history\ndescription: >\n  Historical sales quota assignments for each salesperson. One row per\n  salesperson per quota period (typically quarterly). Use this to analyze\n  targets over time, track quota changes, and compare to actual sales\n  performance. Timestamps are normalized via project date-shifting macros; use\n  quotaDate as the analytical period anchor for reporting and period joins.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: quotadate\n    description: >\n      Effective date of the quota period for the salesperson (usually quarterly\n      checkpoints). Use this as the time anchor for grouping and trending. Cast\n      to date when joining to a calendar. Typical pattern shows recurring\n      quarterly dates across all salespeople.\n    type: timestamp without time zone\n    searchable: false\n  - name: rowguid\n    description: >\n      System-generated unique identifier for the quota record (UUID v4).\n      Primarily technical; not intended for analysis or joining.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: >\n      Timestamp when the quota record was last updated in the source. Useful for\n      auditing and incremental processing; not the business-effective time.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: businessentityid\n    description: >\n      Identifier of the salesperson/business entity associated with this quota.\n      Join key to sales_person.businessentityid. Expect many quota records per\n      salesperson.\n    type: integer\n  - name: salesquota\n    description: >\n      Target sales amount for the quota period defined by quotaDate (company\n      base currency). Represents goal/target, not realized sales.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: sales_person\n    source_col: businessentityid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Links each quota record to the salesperson. Many quota records per\n      salesperson.\n  - name: date_dimension\n    source_col: quotadate\n    ref_col: fulldate\n    type: left\n    cardinality: many-to-one\n    description: >\n      Aligns quota records to the calendar for period grouping and reporting.\n      Join on the date portion of quotaDate to date_dimension.fulldate.\nclarifications:\n  - >-\n    Confirm that quotas are set quarterly; sample dates appear roughly quarterly\n    (12 distinct dates across 2022–2025).\n  - >-\n    What currency are salesquota values denominated in? Is it consistent across\n    territories?\n  - >-\n    Should analysts treat quotadate as the period start date, end date, or a\n    representative anchor date?\n  - >-\n    Can there be more than one quota per salesperson per period? If so, which\n    record should be used?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "7a6ec01c-7718-4304-b8c6-38271b2db530",
    "name": "customer",
    "databaseName": "postgres",
    "whenToUse": "Comprehensive customer model that powers customer relationship management, market segmentation, and purchase behavior analysis. Supports customer lifetime value calculations, retention strategy development, and targeted marketing campaigns while enabling personalized customer experience optimization.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.customer",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082229+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "customer",
    "ymlFile": "name: customer\ndescription: >\n  Customer dimension representing Adventure Works customers (individual or store\n  accounts), enriched with purchase-derived behavioral segments. Includes core\n  identifiers (customerid, personid, storeid, territoryid), a stable source\n  GUID, and a standardized modifieddate. Typical usage: join to orders for\n  CLV/retention and cohorting analyses; segment by cycling frequency, purchase\n  motivation, technical knowledge, and maintenance behavior; roll up by sales\n  territory. Notes: exactly one of personid or storeid is populated per row;\n  territoryid maps to sales_territory; derived filters update as new orders\n  arrive.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: rowguid\n    description: >\n      Source-assigned GUID for the customer record. Stable unique identifier;\n      useful for lineage and deduplication checks but typically not used for\n      business joins.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Last-modified timestamp from the source, standardized/shifted to a\n      consistent reference date in this environment. May be batch-aligned; use\n      for coarse recency slicing rather than precise change auditing.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: filter_cycling_frequency\n    description: >\n      Behavioral segment estimating how often the customer rides, derived from\n      order count, active years, and product mix. Ordinal categories for\n      high-level segmentation.\n    type: text\n    searchable: false\n    options:\n      - Occasional\n      - Monthly\n      - Weekly\n      - Daily\n  - name: filter_purchase_motivation\n    description: >\n      Primary reason inferred for purchases based on categories and price levels\n      (e.g., bikes vs components/accessories and highest price purchased).\n    type: text\n    searchable: false\n    options:\n      - Recreation\n      - Transportation\n      - Competition\n      - Fitness\n  - name: filter_technical_knowledge\n    description: >\n      Estimated level of technical expertise inferred from component purchases\n      and category breadth. Use for audience targeting and messaging.\n    type: text\n    searchable: false\n    options:\n      - Basic\n      - Intermediate\n      - Advanced\n      - Expert\n  - name: filter_maintenance_behavior\n    description: >\n      Indicates how customers tend to handle maintenance based on\n      maintenance-related purchases and component buying patterns.\n    type: text\n    searchable: false\n    options:\n      - Emergency Only\n      - DIY\n      - Regular Service\nmeasures:\n  - name: customerid\n    description: >\n      Primary key for this model. Unique per row. Use as the join key to\n      sales_order_header and when computing distinct customer counts.\n    type: integer\n  - name: personid\n    description: >\n      Foreign key to person.businessentityid for individual customers. Null for\n      store accounts. Use for joining to the person model; not additive.\n    type: integer\n  - name: storeid\n    description: >\n      Foreign key to store.businessentityid for store accounts. Null for\n      individual customers. Multiple customers may map to the same store.\n    type: integer\n  - name: territoryid\n    description: >\n      Sales territory identifier. Join to sales_territory. Low-cardinality\n      (approximately 1–10) and useful for geographic rollups.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: sales_order_header\n    source_col: customerid\n    ref_col: customerid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Orders placed by this customer. One customer can have many orders. Default\n      left join when enriching customers with order attributes.\n  - name: person\n    source_col: personid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Link to individual customer identity and attributes. Null for store\n      accounts. Typically many customers do not share a person; treat as\n      many-to-one at this layer.\n  - name: store\n    source_col: storeid\n    ref_col: businessentityid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Link to store accounts and related attributes. Null for individual\n      customers. Multiple customers may relate to the same store.\n  - name: sales_territory\n    source_col: territoryid\n    ref_col: territoryid\n    type: left\n    cardinality: many-to-one\n    description: >\n      Mapping to the sales territory dimension for geographic/organizational\n      analysis.\nclarifications:\n  - >-\n    Confirm whether filter_technical_knowledge can produce the 'Expert' category\n    in production and how often.\n  - >-\n    Should 'Regular Service' appear in filter_maintenance_behavior, or is it\n    intentionally rare/absent in some environments?\n  - >-\n    Is personid strictly one-to-one with customerid for individuals, or can a\n    person map to multiple customer records?\n  - >-\n    modifieddate is standardized/shifted; confirm intended usage guidance for\n    analysts (e.g., safe for recency filters vs. change auditing).\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "9c08923a-fbf4-41c7-bc34-137fc3b57c5a",
    "name": "product_category",
    "databaseName": "postgres",
    "whenToUse": "A crucial model for product taxonomy management that organizes products into business-relevant categories, enabling category-level performance analysis, strategic merchandising decisions, and hierarchical navigation within the product catalog. Supports business questions related to category growth trends, comparative category performance, and product assortment planning across the business.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_category",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081806+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_category",
    "ymlFile": "name: product_category\ndescription: >\n  Top-level product category dimension for grouping products and subcategories\n  in the Adventure Works catalog. Contains one row per category (e.g., Bikes,\n  Components, Clothing, Accessories). Commonly used to segment product, sales,\n  and inventory analyses at the category level. Lineage: sourced from\n  Production.ProductCategory via stg_product_category.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable category name used for grouping and filters in reporting.\n      Values are stable and low-cardinality. Useful for faceted navigation and\n      category-level breakdowns.\n    type: character varying\n    searchable: true\n    options:\n      - Bikes\n      - Components\n      - Clothing\n      - Accessories\n  - name: rowguid\n    description: >\n      System-generated UUID for the category record (often used for replication\n      or lineage). Not recommended for analytics joins; prefer\n      productCategoryID.\n    type: uuid\n    searchable: false\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp when the category record was last updated (timezone-normalized\n      in staging). Typically changes infrequently across categories.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: productcategoryid\n    description: >\n      Primary key of the product category. Use for joins to subcategories,\n      products, and category-level metrics. For counts, prefer COUNT(DISTINCT\n      productCategoryID); avoid summing this field.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_subcategory\n    source_col: productCategoryID\n    ref_col: productCategoryID\n    type: left\n    cardinality: one-to-many\n    description: >\n      Product categories to their subcategories. Each category has many\n      subcategories; used to cascade category context into subcategory analyses.\n  - name: product\n    source_col: productCategoryID\n    ref_col: productCategoryID\n    type: left\n    cardinality: one-to-many\n    description: >\n      Product categories to products. Many products belong to each category (via\n      product_subcategory); used to roll product detail up to category.\n  - name: sales_by_product_category\n    source_col: productCategoryID\n    ref_col: productCategoryID\n    type: left\n    cardinality: one-to-one\n    description: >\n      Aggregated sales by category; typically one row per category. Join to\n      enrich metric rows with the canonical category attributes.\nclarifications:\n  - Confirm productCategoryID is the unique primary key across all environments.\n  - >-\n    Is modifiedDate normalized to UTC in staging and safe for cross-timezone\n    comparisons?\n  - >-\n    Is rowguid solely for replication/lineage and safe to ignore in analytics\n    joins?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "4bdf15c0-a57c-404c-a9da-0c2cc2aa2688",
    "name": "discount_impact",
    "databaseName": "postgres",
    "whenToUse": "Generated model for discount_impact",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.discount_impact",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081201+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "discount_impact",
    "ymlFile": "name: discount_impact\ndescription: >\n  Measures the total monetary value of discounts applied across all orders,\n  grouped by time periods.  This metric calculates the total discount amount by\n  summing (unit price × discount rate × quantity)  for all order line items\n  within each time period.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: metric_discountimpact\n    description: >-\n      Total discount amount calculated as SUM(unit price × discount rate ×\n      quantity) aggregated by time periods\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "f8f19df4-dd6c-428c-87b7-ad67c2ba3a56",
    "name": "discount_percentage",
    "databaseName": "postgres",
    "whenToUse": "Generated model for discount_percentage",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.discount_percentage",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081436+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "discount_percentage",
    "ymlFile": "name: discount_percentage\ndescription: >\n  Percentage of order value discounted across all orders, aggregated by calendar\n  year, quarter, and month. Use this model to monitor promotion intensity and\n  discounting trends over time, compare periods (MoM/QoQ/YoY), and benchmark\n  discount behavior alongside revenue and margin metrics. Derived from\n  SalesOrderDetail joined to SalesOrderHeader via salesOrderID.\n\n  Values are expressed as percentages (0–100). Typical values are in the low\n  single digits with occasional higher spikes during promotional periods.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: year\n    description: >\n      Calendar year extracted from SalesOrderHeader.orderDate. Use to group or\n      filter metrics by year. Present values include 2022–2025 in current data.\n    type: integer\n    searchable: false\n  - name: quarter\n    description: >\n      Calendar quarter (1–4) extracted from SalesOrderHeader.orderDate. Useful\n      for seasonal/quarterly comparisons.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n  - name: month\n    description: >\n      Calendar month number (1–12) extracted from SalesOrderHeader.orderDate.\n      Use for monthly trending and comparisons.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n      - 5\n      - 6\n      - 7\n      - 8\n      - 9\n      - 10\n      - 11\n      - 12\nmeasures:\n  - name: metric_discountpercentage\n    description: >\n      Percentage of order value discounted within the time bucket. Formula:\n      SUM(unitPrice * unitPriceDiscount * orderQty) / NULLIF(SUM(unitPrice *\n      orderQty), 0) * 100. Units: percent (%). Usage notes: Includes all order\n      lines in the denominator, so periods without discounts may show small\n      values near 0. Denominator is protected with NULLIF and can yield NULL\n      when there is no sales value in a given period. Observed distribution is\n      right‑skewed with most values in the low single digits and occasional\n      promotional spikes.\n    type: number\nmetrics: []\nfilters: []\nrelationships: []\nclarifications:\n  - >-\n    Confirm unit intent: metric_discountpercentage is a percent (0–100), not a\n    fraction (0–1); code multiplies by 100.\n  - >-\n    Scope: Are returns/cancellations included in both numerator and denominator,\n    or should they be excluded?\n  - >-\n    Cost/tax scope: The formula uses unitPrice and orderQty only; confirm taxes,\n    freight, and other charges should remain excluded.\n  - >-\n    Order status: Should the metric be limited to completed/fulfilled orders, or\n    include all order lines regardless of status?\n  - >-\n    Time joins: If downstream joins to a date dimension are desired, consider\n    adding a proper date key to avoid ambiguous joins on year/quarter/month\n    alone.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "c7d309ec-f258-40fd-953e-a2b76123434d",
    "name": "monthly_sales_growth_rate",
    "databaseName": "postgres",
    "whenToUse": "A time-series performance metric that measures month-over-month percentage change in sales revenue. This metric helps track business momentum, identify seasonal patterns, and evaluate the effectiveness of sales and marketing initiatives. Use it to spot emerging trends, diagnose revenue issues before they become critical, benchmark against performance goals, and inform resource allocation decisions. Regular monitoring helps distinguish between temporary fluctuations and long-term shifts in demand.\\n",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.monthly_sales_growth_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081695+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "monthly_sales_growth_rate",
    "ymlFile": "name: monthly_sales_growth_rate\ndescription: >\n  Month-over-month sales growth at a calendar-month grain. Provides the total\n  sales_amount per month and the percentage change versus the immediately\n  previous calendar month. Useful for tracking trend momentum, spotting\n  spikes/dips, and pairing with absolute revenue or order volume in monthly\n  dashboards. Values are derived from sales order line items (unitPrice ×\n  orderQty × (1 − unitPriceDiscount)) aggregated by orderDate month; taxes,\n  freight, and currency normalization are not included.\ndimensions:\n  - name: year\n    description: >\n      Calendar year extracted from sales order dates. Combine with month for\n      year-month analyses and joins to other monthly metric models.\n    type: integer\n    searchable: false\n  - name: month\n    description: >\n      Calendar month number (1–12). Use with year to define a specific period.\n      Typical slicer for monthly trend charts.\n    type: integer\n    searchable: false\n    options:\n      - 1\n      - 2\n      - 3\n      - 4\n      - 5\n      - 6\n      - 7\n      - 8\n      - 9\n      - 10\n      - 11\n      - 12\nmeasures:\n  - name: sales_amount\n    description: >\n      Total sales in the month computed as SUM(unitPrice × orderQty × (1 −\n      unitPriceDiscount)). Excludes taxes, freight/shipping, and\n      returns/cancellations. Units follow the underlying order currency\n      (commonly USD in AdventureWorks); no currency conversion applied.\n    type: decimal\n  - name: metric_mom_salesgrowthrate\n    description: >\n      Month-over-month percentage change in sales_amount relative to the\n      previous calendar month: (current_month − previous_month) / previous_month\n      × 100. Null when the previous month is missing or previous_month equals 0.\n      Can be negative and may exceed 100% for large increases.\n    type: float\nmetrics:\n  - name: avg_mom_growth\n    expr: AVG(metric_mom_salesgrowthrate)\n    description: >-\n      Average month-over-month sales growth across the selected period\n      (percent).\n    args: []\n  - name: months_with_positive_growth\n    expr: SUM(CASE WHEN metric_mom_salesgrowthrate > 0 THEN 1 ELSE 0 END)\n    description: Count of months with positive MoM growth in the selected period.\n    args: []\nfilters:\n  - name: has_prev_month\n    expr: metric_mom_salesgrowthrate IS NOT NULL\n    description: >-\n      Keep only months that have a valid previous-month comparison (non-null,\n      non-zero prev month).\n    args: []\nrelationships:\n  - name: total_sales_revenue\n    source_col: month\n    ref_col: month\n    type: inner\n    cardinality: one-to-one\n    description: >\n      Align monthly growth rates with absolute monthly revenue from\n      total_sales_revenue to show context for magnitude vs growth. Join on year\n      and month; one row per year-month in each model.\n  - name: number_of_orders\n    source_col: month\n    ref_col: month\n    type: inner\n    cardinality: one-to-one\n    description: >\n      Pair growth with order volume to assess whether changes are driven by\n      demand vs pricing/Mix. Join on year and month; one row per year-month in\n      each model.\n  - name: average_order_value\n    source_col: month\n    ref_col: month\n    type: inner\n    cardinality: one-to-one\n    description: >\n      Compare MoM growth with AOV changes to diagnose contribution of basket\n      size/pricing. Join on year and month; one row per year-month in each\n      model.\nclarifications:\n  - >-\n    Confirm currency: are sales captured in a single currency (USD) or mixed? No\n    conversion is applied here.\n  - >-\n    Are taxes, freight/shipping, and returns/cancellations intentionally\n    excluded from sales_amount?\n  - >-\n    Should months with no orders be backfilled as 0 to enable explicit\n    comparisons, or remain absent (yielding NULL growth for the next month)?\n  - >-\n    Confirm that orderDate is the intended time context and that calendar month\n    boundaries are correct for the business (no timezone effects).\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "6fc2d69d-770d-4e90-a9d5-04fb7d436db5",
    "name": "inventory_turnover_ratio",
    "databaseName": "postgres",
    "whenToUse": "A critical operational efficiency metric that measures how many times inventory is sold and replaced over a specific period. Use this metric to evaluate inventory management effectiveness, identify slow-moving products, optimize stock levels,  and assess working capital efficiency. High turnover indicates strong product demand and efficient operations,  while low turnover may signal overstock situations or declining product popularity.\\n",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.inventory_turnover_ratio",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081529+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "inventory_turnover_ratio",
    "ymlFile": "name: inventory_turnover_ratio\ndescription: >\n  Calculates how efficiently inventory is sold and replaced over time for each\n  product.  This metric measures inventory turnover by dividing quarterly sales\n  revenue by average  inventory value, helping identify fast-moving vs\n  slow-moving products.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: product_name\n    description: Name of the product for which inventory turnover is being calculated\n    type: character varying\n    searchable: true\n    options: null\nmeasures:\n  - name: productid\n    description: Unique identifier for the product\n    type: integer\n  - name: year\n    description: Year extracted from the order date for time-based analysis\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: metric_inventoryturnover\n    description: >-\n      Inventory turnover ratio calculated as quarterly sales revenue divided by\n      average inventory value (quantity × standard cost)\n    type: numeric\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "40ad4cf0-9098-451d-b1ce-8d9a87ba07c4",
    "name": "date_dimension",
    "databaseName": "postgres",
    "whenToUse": null,
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.date_dimension",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-09-19 19:50:55.389844+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "date_dimension",
    "ymlFile": "name: date_dimension\ndescription: >\n  Calendar/date dimension providing one row per calendar day with common\n  calendar attributes for analysis and joining to fact tables. Use it to build\n  time series (daily, monthly, quarterly), YOY/MTD/QTD calculations, seasonality\n  and weekday/weekend breakdowns. Designed to be the canonical source for date\n  labels and bucketing across the warehouse.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: fulldate\n    description: >\n      The calendar date for this row. Use as the primary join key to fact/event\n      timestamps (often via casting the fact timestamp to date). Useful for\n      daily grain reports and for rolling-window filters (e.g., last_30_days).\n    type: date\n    searchable: false\n  - name: datekey\n    description: >\n      Surrogate numeric key for the date. Typically represents Unix epoch\n      seconds at 00:00 UTC for the corresponding date. Useful for systems that\n      prefer integer keys. Prefer `fulldate` for human-readable joins and\n      filters.\n    type: integer\n    searchable: false\n  - name: year\n    description: Four-digit calendar year (e.g., 2024).\n    type: integer\n    searchable: false\n  - name: quarter\n    description: Calendar quarter number in the year 1–4.\n    type: integer\n    searchable: false\n  - name: month\n    description: Calendar month number in the year 1–12.\n    type: integer\n    searchable: false\n  - name: dayofmonth\n    description: Day number within the month 1–31.\n    type: integer\n    searchable: false\n  - name: monthname\n    description: Full month name corresponding to `month`.\n    type: text\n    searchable: false\n    options:\n      - January\n      - February\n      - March\n      - April\n      - May\n      - June\n      - July\n      - August\n      - September\n      - October\n      - November\n      - December\n  - name: dayname\n    description: Full weekday name for `fulldate`.\n    type: text\n    searchable: false\n    options:\n      - Monday\n      - Tuesday\n      - Wednesday\n      - Thursday\n      - Friday\n      - Saturday\n      - Sunday\nmeasures: []\nmetrics: []\nfilters:\n  - name: last_30_days\n    expr: fulldate >= CURRENT_DATE - INTERVAL '30 day'\n    description: Limit to the last 30 calendar days from today.\n    args: []\n  - name: current_year\n    expr: year = EXTRACT(YEAR FROM CURRENT_DATE)\n    description: Limit to rows in the current calendar year.\n    args: []\n  - name: weekends_only\n    expr: dayname IN ('Saturday', 'Sunday')\n    description: Include only Saturday and Sunday.\n    args: []\n  - name: business_days\n    expr: dayname NOT IN ('Saturday', 'Sunday')\n    description: Exclude weekends.\n    args: []\nrelationships:\n  - name: sales_order_header\n    source_col: fulldate\n    ref_col: orderdate\n    type: left\n    cardinality: one-to-many\n    description: >\n      Join on the sales order placement date to analyze orders by calendar date.\n      Cast may be required on the fact side (orderdate::date) depending on the\n      warehouse.\n  - name: sales_order_header\n    source_col: fulldate\n    ref_col: duedate\n    type: left\n    cardinality: one-to-many\n    description: |\n      Join on the sales order due date to analyze expected fulfillment dates.\n  - name: sales_order_header\n    source_col: fulldate\n    ref_col: shipdate\n    type: left\n    cardinality: one-to-many\n    description: >\n      Join on the sales order ship date to analyze logistics and shipping\n      timelines.\n  - name: purchase_order_header\n    source_col: fulldate\n    ref_col: orderdate\n    type: left\n    cardinality: one-to-many\n    description: Join on purchase order placement date for procurement timelines.\n  - name: purchase_order_header\n    source_col: fulldate\n    ref_col: shipdate\n    type: left\n    cardinality: one-to-many\n    description: Join on purchase order ship date for inbound logistics analysis.\n  - name: transaction_history\n    source_col: fulldate\n    ref_col: transactiondate\n    type: left\n    cardinality: one-to-many\n    description: Join on inventory transaction date to analyze movements over time.\n  - name: product_list_price_history\n    source_col: fulldate\n    ref_col: startdate\n    type: left\n    cardinality: one-to-many\n    description: Join on list price start date for pricing change analysis.\n  - name: product_list_price_history\n    source_col: fulldate\n    ref_col: enddate\n    type: left\n    cardinality: one-to-many\n    description: Join on list price end date for pricing change analysis.\n  - name: product_cost_history\n    source_col: fulldate\n    ref_col: startdate\n    type: left\n    cardinality: one-to-many\n    description: Join on standard cost start date for cost change analysis.\n  - name: product_cost_history\n    source_col: fulldate\n    ref_col: enddate\n    type: left\n    cardinality: one-to-many\n    description: Join on standard cost end date for cost change analysis.\n  - name: work_order\n    source_col: fulldate\n    ref_col: startdate\n    type: left\n    cardinality: one-to-many\n    description: Join on work order start date for manufacturing throughput analysis.\n  - name: work_order\n    source_col: fulldate\n    ref_col: enddate\n    type: left\n    cardinality: one-to-many\n    description: Join on work order end date for manufacturing throughput analysis.\n  - name: work_order\n    source_col: fulldate\n    ref_col: duedate\n    type: left\n    cardinality: one-to-many\n    description: Join on work order due date for SLA tracking.\n  - name: work_order_routing\n    source_col: fulldate\n    ref_col: scheduledstartdate\n    type: left\n    cardinality: one-to-many\n    description: Join on scheduled start date for routing capacity analysis.\n  - name: work_order_routing\n    source_col: fulldate\n    ref_col: scheduledenddate\n    type: left\n    cardinality: one-to-many\n    description: Join on scheduled end date for routing capacity analysis.\n  - name: work_order_routing\n    source_col: fulldate\n    ref_col: actualstartdate\n    type: left\n    cardinality: one-to-many\n    description: Join on actual start date for realized routing timelines.\n  - name: work_order_routing\n    source_col: fulldate\n    ref_col: actualenddate\n    type: left\n    cardinality: one-to-many\n    description: Join on actual end date for realized routing timelines.\nclarifications:\n  - >-\n    Confirm whether `datekey` is Unix epoch seconds at 00:00:00 UTC for the\n    date, and whether this is stable across environments.\n  - >-\n    Is `fulldate` stored as a DATE or TIMESTAMP in the warehouse? If TIMESTAMP,\n    confirm timezone handling and whether joins to fact timestamps require\n    explicit casting.\n  - >-\n    Do `monthname` and `dayname` values contain trailing spaces or localized\n    variants? If so, should we trim/standardize upstream?\n  - >-\n    What is the intended coverage (min/max) of the date dimension, and does it\n    include future-dated rows for planning?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "0b42455c-f00d-4887-aad2-34d1ade2d12a",
    "name": "location",
    "databaseName": "postgres",
    "whenToUse": "Strategic facility management model that supports inventory placement decisions, operational efficiency analysis, and production capacity planning. Enables cost optimization through facility utilization insights, resource allocation analysis, and geographical distribution assessments of manufacturing and warehouse operations.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.location",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083052+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "location",
    "ymlFile": "name: location\ndescription: >\n  Warehouse and manufacturing locations used across production and inventory\n  workflows. Each row represents a unique location/work center with attributes\n  used in routing and inventory analyses. Typical usage: join to\n  product_inventory to label stock by location, and to work_order_routing to\n  analyze throughput or capacity by location. Includes cost rate and planned\n  availability attributes.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: name\n    description: >\n      Human-readable location/work center name (e.g., \"Final Assembly\", \"Frame\n      Welding\", \"Paint Shop\"). Usage notes: Unique in this dataset and suitable\n      for display and searching; prefer locationid as the join key.\n    type: character varying\n    searchable: true\n  - name: modifieddate\n    description: >\n      Timestamp when this location record was last updated. Dates are normalized\n      via the shift_date macro in staging. Use for auditing and change tracking.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: locationid\n    description: >\n      Surrogate primary key for the location. Join key to\n      product_inventory.locationid and work_order_routing.locationid. Use as a\n      grouping key; not meaningful to sum.\n    type: integer\n  - name: costrate\n    description: >\n      Overhead cost rate associated with the location/work center. Units are\n      currency per hour (e.g., USD/hour). Common values observed: 0, 12.25,\n      14.5, 15.75, 18, 22.5, 25. Treat as an attribute; avoid summing across\n      locations.\n    type: numeric\n  - name: availability\n    description: >\n      Planned capacity/availability for the location in hours for the planning\n      period. Typical values include 0, 80, 96, 108, 120. Treat as an attribute;\n      not a percentage; avoid summing across locations without context.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: product_inventory\n    source_col: locationid\n    ref_col: locationid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Inventory records stored at this location. Join on locationid; one\n      location to many inventory rows.\n  - name: work_order_routing\n    source_col: locationid\n    ref_col: locationid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Manufacturing routing steps executed at this location. Join on locationid;\n      one location to many routing rows.\nclarifications:\n  - >-\n    Confirm units and currency for costrate (e.g., USD per hour) and whether it\n    includes labor vs. overhead.\n  - >-\n    Clarify the time basis for availability (hours per day/week or another\n    planning interval?).\n  - >-\n    Is name guaranteed to be unique and stable over time, or should only\n    locationid be treated as the durable key?\n  - Are modifieddate values stored/normalized to UTC after shift_date?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "20dfe9ea-c819-4277-85fb-7d058212d07a",
    "name": "currency",
    "databaseName": "postgres",
    "whenToUse": "Core financial model that enables international transaction analysis, exchange rate tracking, and multi-currency reporting. Supports financial risk assessment related to currency fluctuations and provides the foundation for global sales and procurement analysis.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.currency",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083164+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "currency",
    "ymlFile": "name: currency\ndescription: >\n  Reference dimension of currencies from the Sales system. Contains one row per\n  3-letter ISO currency code with its English name. Use this model to decode\n  currency codes and to join into exchange rates and country/region currency\n  mappings. Includes historical/obsolete codes as present in source (e.g., SIT,\n  ROL), which is useful for analyzing older transactions. Note: modifieddate\n  currently reflects a uniform snapshot/load timestamp rather than per-row\n  changes.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: currencycode\n    description: >\n      Three-letter ISO 4217 currency code (uppercase). Primary identifier for\n      the currency; join key to other finance models. Includes both current and\n      some historical codes.\n    type: character\n    searchable: false\n    options: null\n  - name: name\n    description: >\n      English currency name corresponding to currencycode. One-to-one with\n      currencycode and helpful for display/search (e.g., \"EURO\", \"United Kingdom\n      Pound\").\n    type: character varying\n    searchable: true\n    options: null\n  - name: modifieddate\n    description: >\n      Timestamp recorded in source for last modification/snapshot. In current\n      data, this value is the same for all rows, so it should not be used for\n      per-record change tracking.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures: []\nmetrics: []\nfilters: []\nrelationships:\n  - name: currency_rate_from\n    source_col: currencycode\n    ref_col: fromcurrencycode\n    type: left\n    cardinality: one-to-many\n    description: >\n      Exchange rates where this currency is the source (from) currency. Useful\n      to see how this currency converts into others over time.\n  - name: currency_rate_to\n    source_col: currencycode\n    ref_col: tocurrencycode\n    type: left\n    cardinality: one-to-many\n    description: >\n      Exchange rates where this currency is the target (to) currency. Useful to\n      analyze rates converting from other currencies into this one.\n  - name: country_region_currency\n    source_col: currencycode\n    ref_col: currencycode\n    type: left\n    cardinality: one-to-many\n    description: >\n      Countries/regions that use (or historically used) this currency. Useful\n      for geographic analyses and for mapping transactions to regions by\n      currency.\nclarifications:\n  - Confirm ISO 4217 compliance and casing rules (are all codes uppercase?).\n  - >-\n    Are historical/obsolete currency codes expected to remain for historical\n    reporting?\n  - >-\n    Does modifieddate represent source last modified or ETL load timestamp, and\n    is it reliable for recency filters?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "8c937b99-f342-49da-933e-25d77b86bbaa",
    "name": "orders_with_discount_count",
    "databaseName": "postgres",
    "whenToUse": "Generated model for orders_with_discount_count",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.orders_with_discount_count",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081722+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "orders_with_discount_count",
    "ymlFile": "name: orders_with_discount_count\ndescription: >\n  Counts the number of distinct orders that contain at least one discounted\n  item, grouped by  time periods. This metric helps track discount utilization\n  patterns and promotional  effectiveness over time.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions: []\nmeasures:\n  - name: year\n    description: Year extracted from the order date\n    type: numeric\n  - name: quarter\n    description: Quarter of the year (1-4) extracted from the order date\n    type: numeric\n  - name: month\n    description: Month of the year (1-12) extracted from the order date\n    type: numeric\n  - name: metric_orderswithdiscountcount\n    description: >-\n      Count of distinct orders that have at least one line item with a discount\n      (unit price discount > 0)\n    type: bigint\nmetrics: []\nfilters: []\nrelationships: []\nclarifications: []\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "9adef0bf-59f2-4ab9-bf40-aa3087e4a6eb",
    "name": "currency_rate",
    "databaseName": "postgres",
    "whenToUse": "Currency exchange rate model that supports international transaction analysis, financial forecasting with exchange rate impacts, and cost basis calculations across multiple currencies. This model enables users to analyze currency fluctuations over time, calculate accurate costs and revenues for cross-border transactions, and make informed financial decisions based on historical exchange rate trends.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.currency_rate",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.083132+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "currency_rate",
    "ymlFile": "name: currency_rate\ndescription: >\n  Exchange rates with USD as the base currency. Each row represents the\n  USD-to-target exchange rate for a given date and target currency. Includes\n  both an intraday average rate and the end-of-day closing rate. Dates are\n  standardized via a project date-shifting macro to ensure consistent timezone\n  handling. Useful for converting USD-denominated amounts into local currencies\n  on the rate date, valuation at close, and FX trend analysis. Note that the\n  dataset currently contains historical/obsolete currency codes in addition to\n  active ones.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: currencyratedate\n    description: >\n      Effective date for the FX rate. Time component reflects standardized\n      timezone handling from the staging layer; use the date portion for\n      day-level joins and analysis.\n    type: timestamp without time zone\n    searchable: false\n    options: null\n  - name: fromcurrencycode\n    description: >\n      ISO 4217 currency code for the base currency. Currently always 'USD' in\n      this dataset. Join to the currency model for display names/metadata.\n    type: character\n    searchable: true\n    options:\n      - USD\n  - name: tocurrencycode\n    description: >\n      ISO 4217 currency code for the quote/target currency. Join to the currency\n      model for display names and to country_region_currency for geographic\n      context.\n    type: character\n    searchable: true\n    options:\n      - ARS\n      - AUD\n      - BRL\n      - CAD\n      - CNY\n      - DEM\n      - EUR\n      - FRF\n      - GBP\n      - JPY\n      - MXN\n      - SAR\n      - USD\n      - VEB\n  - name: modifieddate\n    description: >\n      Timestamp of the last update to this record in the source. Use for\n      auditing/lineage; not the business-effective date of the rate.\n    type: timestamp without time zone\n    searchable: false\n    options: null\nmeasures:\n  - name: currencyrateid\n    description: >\n      Surrogate key for the currency rate record. Use for row-level reference or\n      counting rows; not intended for numeric aggregation beyond counts.\n    type: integer\n  - name: averagerate\n    description: >\n      Average FX rate over the trading day, expressed as target currency units\n      per 1 USD (e.g., MXN per USD). Use for average-of-day conversions and\n      general FX analysis.\n    type: numeric\n  - name: endofdayrate\n    description: >\n      Closing FX rate for the day, expressed as target currency units per 1 USD.\n      Use for end-of-day valuation and daily closing conversions.\n    type: numeric\nmetrics: []\nfilters: []\nrelationships:\n  - name: currency\n    source_col: fromcurrencycode\n    ref_col: currencycode\n    cardinality: many-to-one\n    description: >\n      From-currency reference to the Currency model for base currency metadata.\n      Join on fromcurrencycode = currency.currencycode. Many currency_rate rows\n      map to one currency.\n  - name: currency\n    source_col: tocurrencycode\n    ref_col: currencycode\n    cardinality: many-to-one\n    description: >\n      To-currency reference to the Currency model for quote currency metadata.\n      Join on tocurrencycode = currency.currencycode. Many currency_rate rows\n      map to one currency.\n  - name: country_region_currency\n    source_col: tocurrencycode\n    ref_col: currencycode\n    cardinality: many-to-one\n    description: >\n      Maps quote currency codes to countries/regions for geographic context.\n      Join on tocurrencycode = country_region_currency.currencycode (many rates\n      to one mapping row).\nclarifications:\n  - >-\n    Is fromcurrencycode expected to be 'USD' by design, or could other base\n    currencies appear in future loads?\n  - >-\n    For reporting, when should averageRate be used versus endOfDayRate? Provide\n    guidance by use case.\n  - >-\n    Should USD-to-USD rows be filtered out in analyses by default, or kept\n    explicitly?\n  - >-\n    Confirm historical code handling (DEM, FRF, VEB) and whether a mapping to\n    successor currencies should be applied for trend analyses.\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "abf11a4c-c909-41bc-8914-84d5f51b088c",
    "name": "person",
    "databaseName": "postgres",
    "whenToUse": "Core identity model that captures detailed personal information for employees, customers, and business contacts. Essential for contact management, personalization, demographic analysis, and relationship management across the organization. Supports customer segmentation, employee directories, and communication preferences.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.person",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082796+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "person",
    "ymlFile": "name: person\ndescription: >\n  Canonical person records for individuals and contacts in Adventure Works. Use\n  this model when you need display-ready names, basic contact preferences, and a\n  stable person key to join to related person-centric tables (email addresses,\n  phone numbers, contacts, customers, employees). Title/suffix are sparsely\n  populated; first/last names have medium-to-high cardinality and are suited for\n  search and display. Person type encodes the role/category of the record (e.g.,\n  individual vs. various contact roles). Two XML blobs are included:\n  additionalcontactinfo (rarely populated, ad-hoc contact notes) and\n  demographics (survey-style attributes such as income, gender, children counts,\n  etc.). These XML fields are stored as text—treat as semi-structured content\n  and avoid parsing unless necessary. Modified date reflects the last update\n  timestamp.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: persontype\n    description: >\n      Code indicating the category/role of the person (e.g., individual vs\n      contact roles). Usage notes: Low-cardinality enum. Use to filter to\n      individuals only or to segment by role. Confirm exact code meanings in\n      clarifications.\n    type: character\n    searchable: false\n    options:\n      - IN\n      - SC\n      - GC\n      - EM\n      - VC\n      - SP\n  - name: namestyle\n    description: >\n      Indicates naming convention. False typically represents Western name order\n      (First Last); true indicates Eastern style. All observed values are false.\n    type: boolean\n    searchable: false\n  - name: title\n    description: >\n      Honorific/prefix (e.g., Mr., Ms.). Very sparsely populated; avoid using\n      for joins.\n    type: character varying\n    searchable: false\n    options:\n      - Mr.\n      - Ms.\n      - Mrs.\n      - Sr.\n      - Sra.\n      - Ms\n  - name: firstname\n    description: >\n      Given name. High-cardinality free text used for display/search; not\n      suitable as a key.\n    type: character varying\n    searchable: true\n  - name: middlename\n    description: >\n      Middle name or initial. Often NULL; when present, commonly a single\n      letter.\n    type: character varying\n    searchable: true\n  - name: lastname\n    description: >\n      Family/surname. High-cardinality free text used for display/search; not\n      suitable as a key.\n    type: character varying\n    searchable: true\n  - name: suffix\n    description: |\n      Name suffix (e.g., Jr., Sr., II). Extremely sparse.\n    type: character varying\n    searchable: false\n    options:\n      - Jr.\n      - II\n      - Sr.\n      - III\n      - IV\n      - PhD\n  - name: emailpromotion\n    description: >\n      Marketing email preference code. Three-level flag used to model email\n      promotion preferences or frequency. See clarifications for exact mapping\n      of 0/1/2.\n    type: integer\n    searchable: false\n    options:\n      - 0\n      - 1\n      - 2\n  - name: additionalcontactinfo\n    description: >\n      XML blob with ancillary contact details (extra phones, pagers, addresses,\n      emails). Very rarely populated; treat as semi-structured text when\n      present.\n    type: xml\n    searchable: false\n  - name: demographics\n    description: >\n      XML blob with survey-style attributes. Common keys include:\n      TotalPurchaseYTD, DateFirstPurchase, BirthDate, MaritalStatus,\n      YearlyIncome, Gender, TotalChildren, NumberChildrenAtHome, Education,\n      Occupation, HomeOwnerFlag, NumberCarsOwned, CommuteDistance. Treat as\n      semi-structured text.\n    type: xml\n    searchable: false\n  - name: rowguid\n    description: >\n      Row-level UUID for cross-system traceability; not intended for business\n      logic.\n    type: uuid\n    searchable: false\n  - name: modifieddate\n    description: |\n      Last update timestamp for this record.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: businessentityid\n    description: >\n      Surrogate key for the person. Use COUNT DISTINCT for person counts; do not\n      sum.\n    type: integer\nmetrics: []\nfilters:\n  - name: individuals_only\n    expr: persontype = 'IN'\n    description: Filter to individual persons.\n    args: []\n  - name: receives_email_promotions\n    expr: emailpromotion > 0\n    description: Persons who accept email promotions (any non-zero level).\n    args: []\nrelationships:\n  - name: business_entity\n    source_col: businessentityid\n    ref_col: businessentityid\n    cardinality: one-to-one\n    description: >\n      Each person is also a business entity. Join on businessentityid for\n      entity-level metadata such as row GUID and audit fields.\n  - name: email_address\n    source_col: businessentityid\n    ref_col: businessentityid\n    cardinality: one-to-many\n    description: >\n      Person to email addresses (zero-to-many). Join on businessentityid to\n      enumerate all known email addresses for this person.\n  - name: person_phone\n    source_col: businessentityid\n    ref_col: businessentityid\n    cardinality: one-to-many\n    description: >\n      Person to phone numbers (zero-to-many). Join on businessentityid; use\n      phone_number_type for type labels.\n  - name: business_entity_contact\n    source_col: businessentityid\n    ref_col: personid\n    cardinality: one-to-many\n    description: >\n      Links a person as a contact for a business entity. Join on personid to see\n      that person’s contact roles; combine with contact_type for labels.\n  - name: person_credit_card\n    source_col: businessentityid\n    ref_col: businessentityid\n    cardinality: one-to-many\n    description: |\n      Credit cards associated with a person. Join on businessentityid.\n  - name: employee\n    source_col: businessentityid\n    ref_col: businessentityid\n    cardinality: one-to-one\n    description: >\n      Subset of persons who are employees. Join on businessentityid; expected\n      coverage < 100%.\n  - name: customer\n    source_col: businessentityid\n    ref_col: personid\n    cardinality: one-to-one\n    description: >\n      Subset of persons who are customers (individual accounts). Join on\n      customer.personid; expected coverage < 100%.\nclarifications:\n  - 'Confirm exact meanings of persontype codes: IN, SC, GC, EM, VC, SP.'\n  - >-\n    Confirm the business mapping of emailpromotion values 0/1/2 (e.g.,\n    none/standard/targeted?).\n  - Confirm namestyle semantics (true = Eastern naming?).\n  - Validate one-to-one coverage with employee and customer; expected < 100%.\n  - >-\n    Any PII handling constraints for XML fields additionalcontactinfo and\n    demographics?\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "fcfc6407-567a-4bc9-b616-a9ff097c6d47",
    "name": "phone_number_type",
    "databaseName": "postgres",
    "whenToUse": "Foundational model for contact channel categorization and communication preference analysis. Enables structured management of diverse phone contact channels across the organization. Valuable for analyzing communication pattern preferences, optimizing outreach strategies based on contact type effectiveness, and ensuring appropriate contact information utilization. Supports customer service, sales, and operations teams in selecting optimal communication channels, managing contact information integrity, and implementing channel-specific communication protocols. Critical for multi-channel communication strategies and comprehensive contact information management.",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.phone_number_type",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.082624+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "phone_number_type",
    "ymlFile": "name: phone_number_type\ndescription: >\n  Reference dimension listing the allowed phone number categories used in\n  person_phone (e.g., Cell, Home, Work). Use this to label or filter phone\n  numbers by type in reporting and analysis. This is a small, stable lookup\n  table; values rarely change. modifieddate reflects the last update timestamp\n  from the source and is mainly useful for auditing/freshness rather than\n  business logic.\ndimensions:\n  - name: name\n    description: >\n      Human-readable category for the phone number type. Typical values are the\n      three canonical categories used across the dataset. Usage notes: Treat as\n      a closed enum; use for labeling and filtering.\n    type: character varying\n    searchable: false\n    options:\n      - Cell\n      - Home\n      - Work\n  - name: modifieddate\n    description: >\n      Timestamp of the last recorded update for this type from the source\n      system. Usage notes: Useful for auditing/freshness checks; not typically\n      used for analysis. Timezone: normalized/shifted consistently in staging.\n    type: timestamp without time zone\n    searchable: false\nmeasures:\n  - name: phonenumbertypeid\n    description: >\n      Surrogate/technical identifier for the phone number type. Primary key of\n      this table. Use to join to person_phone.phonenumbertypeid.\n    type: integer\nmetrics: []\nfilters: []\nrelationships:\n  - name: person_phone\n    source_col: phonenumbertypeid\n    ref_col: phonenumbertypeid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Join to phone records to label each phone number with its category. One\n      type can apply to many phone numbers.\nclarifications:\n  - >-\n    Can additional phone number types be added, or is the set fixed to\n    Cell/Home/Work?\n  - Is `name` guaranteed to be unique and stable across locales/environments?\n  - >-\n    Confirm timezone normalization for `modifieddate` and whether it should be\n    used for SCD-style auditing.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\n",
    "databaseIdentifier": "postgres"
  },
  {
    "id": "710a5874-2e58-48c6-aa7c-e4172c7d2751",
    "name": "product_profitability_index",
    "databaseName": "postgres",
    "whenToUse": "A composite metric that evaluates overall product performance by combining revenue, costs, and product quality factors. This index supports product portfolio optimization by identifying both star performers and underperforming products. Use it to guide resource allocation decisions, prioritize product improvements, inform product lifecycle management, and optimize manufacturing and marketing investments. The index incorporates warranty costs to provide a more holistic view of true product profitability beyond simple margin calculations.\\n",
    "whenNotToUse": null,
    "type": "view",
    "definition": "SELECT * FROM postgres.ont_ont.product_profitability_index",
    "schema": "ont_ont",
    "enabled": true,
    "imported": true,
    "dataSourceId": "cc3ef3bc-44ec-4a43-8dc4-681cae5c996a",
    "organizationId": "bf58d19a-8bb9-4f1d-a257-2d2105e7f1ce",
    "createdBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "updatedBy": "c2dd64cd-f7f3-4884-bc91-d46ae431901e",
    "createdAt": "2025-05-02 17:10:46.081591+00",
    "updatedAt": "2025-09-19 19:50:55.389844+00",
    "deletedAt": null,
    "model": "product_profitability_index",
    "ymlFile": "name: product_profitability_index\ndescription: >\n  Product-level profitability summary that blends net sales revenue, production\n  cost, and warranty-related activity into a single view per product. Use this\n  model to compare products on profitability %, identify items with\n  thin/negative margins, and spot potential quality risk via warranty repairs.\n  Revenue is sourced from sales order line totals (net of line-level discounts).\n  Cost is estimated using product.standardCost multiplied by sold quantities;\n  this does not reflect historical cost changes. Warranty activity is\n  approximated from work orders with a non-null scrap reason, treated as\n  warranty repairs.\ndata_source_name: adventure_works\ndatabase: postgres\nschema: ont_ont\ndimensions:\n  - name: product_name\n    description: >\n      Human-readable product name from the product dimension. Helpful for\n      ranking and reporting; pair with productid to avoid ambiguity. Names\n      include size/color variants (e.g., \"HL Road Frame - Red, 62\").\n    type: character varying\n    searchable: true\nmeasures:\n  - name: productid\n    description: >\n      Unique product identifier. Use for joining to product-level models. Not a\n      true aggregate; avoid summing. When aggregating across products, prefer\n      COUNT(DISTINCT productid).\n    type: integer\n  - name: total_revenue\n    description: >\n      Net sales revenue aggregated from sales_order_detail.lineTotal for the\n      product. lineTotal reflects UnitPrice * OrderQty * (1 -\n      UnitPriceDiscount). Does not explicitly adjust for returns, freight, or\n      taxes.\n    type: numeric\n  - name: total_cost\n    description: >\n      Estimated production cost: SUM(orderQty * product.standardCost). Uses\n      current standardCost at the product level, not historical cost records;\n      may over/understate true historical margins when costs changed over time.\n    type: numeric\n  - name: warranty_repair_count\n    description: >\n      Count of warranty-related work orders, proxied as work_orders with\n      scrapReasonID IS NOT NULL for the product. Interpreted as warranty\n      repairs/returns; verify this proxy matches business meaning.\n    type: bigint\n  - name: warranty_cost\n    description: >\n      Total cost attributed to warranty repairs from\n      work_order_routing.actualCost joined to work orders flagged as warranty\n      (scrapReasonID IS NOT NULL).\n    type: numeric\n  - name: metric_profitabilityindex\n    description: >\n      Profitability percentage: (total_revenue - total_cost - warranty_cost) /\n      NULLIF(total_revenue, 0) * 100. Returns NULL when total_revenue is 0.\n      Values can be negative when costs exceed revenue.\n    type: numeric\n  - name: metric_productriskfactor\n    description: >\n      Warranty incidence rate: (warranty_repair_count / order_count) * 100 based\n      on distinct sales orders associated with the product. In current data this\n      is often 0; increases as warranty activity is recorded.\n    type: bigint\nmetrics: []\nfilters:\n  - name: positive_profitability\n    expr: metric_profitabilityindex > 0\n    description: Filter to include only products with positive profitability percentage.\n    args: []\n  - name: has_warranty_activity\n    expr: warranty_repair_count > 0\n    description: Filter to include products with one or more warranty repairs.\n    args: []\nrelationships:\n  - name: product\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: one-to-one\n    description: >\n      Join to product details for attributes like category, model, and\n      size/color. One row here per product present in sales; coverage may be\n      <100% of all products.\n  - name: sales_order_detail\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Underlying sales lines contributing to revenue. Join on product; expect\n      many detail rows per product.\n  - name: work_order\n    source_col: productid\n    ref_col: productid\n    type: left\n    cardinality: one-to-many\n    description: >\n      Work orders used to approximate warranty repairs (scrapReasonID IS NOT\n      NULL). Many work orders can relate to a single product.\nclarifications:\n  - >-\n    Confirm scrapReasonID != NULL as a proxy for warranty-related repairs vs.\n    other scrap.\n  - >-\n    Is using product.standardCost (current) acceptable, or should historical\n    cost (e.g., product_cost_history) be used?\n  - Should revenue be adjusted for returns, freight, or taxes beyond lineTotal?\n  - >-\n    Column names appear lowercase in the materialized model; confirm naming\n    convention for metrics (SQL uses mixed case).\n",
    "databaseIdentifier": "postgres"
  }
]
